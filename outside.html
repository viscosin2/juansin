 <!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin — props por capas + colisiones + debug</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html,body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  .screen::after{ content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%); z-index:5; }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:#000; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }
</style>
</head>
<body>
<div class="gameboy">
  <div class="screen-container"><div class="screen"><canvas id="game"></canvas></div></div>
  <div class="controls">
    <div class="dpad">
      <div></div><button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button><div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button><div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button><div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button><div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción" disabled></button>
  </div>
</div>

<script>
/* ========== CONFIG RÁPIDA ========== */
const ROOM = { w:512, h:350 };                 // ventana lógica (mantiene bandas)
const ZOOM = 2.5;                               // 1 = sin zoom; 2.5 como pediste
const START = { mode:'percent', x:5, y:90 };    // posición inicial
const FEET_RADIUS_X = 7;   // ancho (horizontal)
const FEET_RADIUS_Y = 10;    // alto (vertical)
const FEET_OFFSET_Y = 2;   // píxeles hacia abajo, ajusta a tu gusto
const DEBUG_OBS = true, DEBUG_PROPS = true;     // overlays SIEMPRE activos

/* ========== ASSETS ========== */
const BG_SRC = "assets/locations/outside.png";
const JUAN = { size:{w:36,h:40}, scale:0.9,
  idle:{down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"]},
  walk:{down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
        up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
        left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
        right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"]}
};

/* Catálogo de props: (x,y) = pie (bottom-center); collider relativo al pie */
const CATALOG = {
  tree:   { src:'assets/objects/arbolclaro.png',   scale:1, collider:{x:-10,y:-13,w:23,h:5} },
  bush:   { src:'assets/objects/arbustoclaro.png', scale:1, collider:{x:-16,y:-16,w:32,h:16} },
  rock:   { src:'assets/objects/piedra.png',       scale:1, collider:{x:-12,y:-10,w:24,h:10} },
  fence:  { src:'assets/objects/valla_clara.png',  scale:1, collider:{x:-16,y:-10,w:32,h:10} },
  house:  { src:'assets/objects/casajuan.png',     scale:1, collider:{x:-40,y:-18,w:80,h:40}, depthBand: 10},
  bridge: { src:'assets/objects/puente.png',       scale:1, collider:null },
  river: { src: 'assets/objects/rio.png',        scale:1, collider: null, wavy: true}
};

 const PLACED = {
  tree:  [{type:'percent',x:17,y:87.5},{type:'percent',x:22,y:64},{type:'percent',x:30,y:58}],
  house: [{type:'percent',x:7.2,y:82}],
  bush:  [{type:'percent',x:45,y:78},{type:'percent',x:48,y:79}],
  fence: [{type:'percent',x:15.25,y:99.75}],
  rock:  [{type:'percent',x:60,y:72}],
  bridge:[{type:'percent',x:55,y:65}],
  river: [{type:'percent', x:7, y:50}]
};

/* Obstáculos extra (además de los de props) */
const OBSTACLE_DEFS = [
  {type:'percent', x:29.8, y:30.55, w:31.1, h:80, name:'zona bloqueada 1'},
  {type:'percent', x:60, y:30.55, w:17.3, h:22.5, name:'zona bloqueada 2'}
];

/* ========== STATE BÁSICO ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

let bgImg=null, sprites=null, world={w:0,h:0};
let PROP_IMAGES={}, PROPS=[], OBSTACLES=[];

let cam={x:0,y:0,w:ROOM.w/ZOOM|0,h:ROOM.h/ZOOM|0};
let screenRect={dx:0,dy:0,dw:0,dh:0}, mapScaleX=1, mapScaleY=1;

const player={x:0,y:0,dir:'down',speed:150,moving:false,frame:0,frameTime:0};

/* ========== INPUT: SOLO D-PAD ========== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){ const start=e=>{e.preventDefault();on();}; const end=e=>{e.preventDefault();off();};
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
  btn.addEventListener('mousedown',start); window.addEventListener('mouseup',end);
}
bindHold(document.getElementById('btn-up'),   ()=>keys.up=true,   ()=>keys.up=false);
bindHold(document.getElementById('btn-down'), ()=>keys.down=true, ()=>keys.down=false);
bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);

/* ========== UTILS CORTAS ========== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const loadImage=src=>new Promise(r=>{
  const i=new Image(); i.onload=()=>r(i); i.onerror=()=>{console.warn('No carga',src); r(null)}; i.src=src;
});
async function preloadSprites(map){
  const out={idle:{},walk:{},size:map.size,scale:map.scale};
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
const percentToWorld=(p)=>({x:Math.round(world.w*(p.x/100)), y:Math.round(world.h*(p.y/100))});

/* ========== LAYOUT / CÁMARA ========== */
function resize(){
  const sc=document.querySelector('.screen');
  canvas.width=sc.clientWidth; canvas.height=sc.clientHeight;
  const k=Math.min(canvas.width/ROOM.w, canvas.height/ROOM.h);
  screenRect.dw=ROOM.w*k; screenRect.dh=ROOM.h*k;
  screenRect.dx=(canvas.width-screenRect.dw)/2;
  screenRect.dy=(canvas.height-screenRect.dh)/2;
  cam.w=Math.max(64,Math.round(ROOM.w/ZOOM));
  cam.h=Math.max(64,Math.round(ROOM.h/ZOOM));
  mapScaleX=screenRect.dw/cam.w; mapScaleY=screenRect.dh/cam.h;
  cam.x=clamp(cam.x,0,world.w-cam.w); cam.y=clamp(cam.y,0,world.h-cam.h);
}
addEventListener('resize',resize);

function centerCameraOnPlayer(){
  cam.x=clamp(player.x-cam.w/2,0,world.w-cam.w);
  cam.y=clamp(player.y-cam.h/2,0,world.h-cam.h);
}

/* ========== COLISIÓN ========== */
// Centro de los pies (cx,cy), radios rx,ry, rect = {x,y,w,h}
function ellipseRectOverlap(cx, cy, rx, ry, rect){
  const qx = clamp(cx, rect.x, rect.x + rect.w);
  const qy = clamp(cy, rect.y, rect.y + rect.h);
  const dx = (cx - qx) / rx;
  const dy = (cy - qy) / ry;
  return (dx*dx + dy*dy) <= 1;
}
function anyOverlap(cx, cy){
  for(const ob of OBSTACLES) if(ellipseRectOverlap(cx, cy + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) return true;
  return false;
}



/* ========== PROPS / OBSTÁCULOS ========== */
async function preloadCatalog(){
  const entries=Object.entries(CATALOG);
  const res=await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  res.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}
function buildPropsAndObstacles(){
  PROPS=[]; OBSTACLES=[];

  // props -> instancias + colliders
  for(const [type,list] of Object.entries(PLACED)){
    const spec=CATALOG[type]; const img=PROP_IMAGES[type];
    if(!spec){ console.warn('Tipo desconocido',type); continue; }
    if(!list||!list.length){ continue; }

    for(const p of list){
      const pos = (p.type==='percent') ? percentToWorld(p) : {x:p.x,y:p.y};
      const prop={ type, img, x:pos.x, y:pos.y, iw:img?img.naturalWidth:32, ih:img?img.naturalHeight:32, scale:spec.scale||1 };
      if(spec.collider){
        const c=spec.collider, s=prop.scale;
        const col={ x:prop.x + c.x*s, y:prop.y + (c.y*s) - (c.h*s), w:c.w*s, h:c.h*s };
        prop.collider=col; OBSTACLES.push({...col, name:type});
      }
      PROPS.push(prop);
    }
  }

  // obstáculos extra
  for(const o of OBSTACLE_DEFS){
    const r=(o.type==='percent') ? { ...percentToWorld(o), w:Math.round(world.w*(o.w/100)), h:Math.round(world.h*(o.h/100)) } : o;
    OBSTACLES.push({x:r.x,y:r.y,w:r.w,h:r.h,name:o.name||'extra'});
  }
}

/*=========== HELPERS =========== */

 // Efecto olas: desplaza en X cada franja con un seno, y añade brillos sutiles
function drawWavy(img, sx, sy, sw, sh, dx, dy, dw, dh, t){
  const SLICES = 36;         // más = más suave (coste un pelín mayor)
  const AMP    = 2.2;        // amplitud (px en pantalla)
  const FREQ   = 2.5;        // ondas a lo alto
  const SPEED  = 1.4;        // velocidad

  const srcSliceH = sh / SLICES;
  const dstSliceH = dh / SLICES;

  for (let i=0;i<SLICES;i++){
    const sy0 = sy + i*srcSliceH;
    const dy0 = dy + i*dstSliceH;
    const off = Math.sin((i/SLICES)*Math.PI*2*FREQ + t*SPEED) * AMP;

    // última franja: ajusta el alto para no acumular error
    const srcH = (i===SLICES-1) ? (sh - i*srcSliceH) : srcSliceH;
    const dstH = (i===SLICES-1) ? (dh - i*dstSliceH) : dstSliceH;

    // recorta y desplaza un poquito en X
    ctx.drawImage(img, sx, sy0, sw, srcH, Math.round(dx+off), Math.round(dy0), dw, Math.round(dstH));
  }

  // “brillos” muy suaves que se deslizan
  ctx.save();
  ctx.globalAlpha = 0.08;
  for (let k=0;k<6;k++){
    const yy = dy + ((k+0.5)/6)*dh + Math.sin(t*2 + k)*6;
    ctx.fillRect(dx, Math.round(yy), dw, 1);
  }
  ctx.restore();
}

 function cornerSlide(targetX, targetY, vx, vy){
  const SLIDE = 3; // píxeles mundo
  // Prioriza deslizar en el eje perpendicular al dominante
  if(Math.abs(vx) > Math.abs(vy)){
    // intenta subir/bajar un poco y luego aplicar X
    for(const off of [-SLIDE, SLIDE]){
      const ty = clamp(player.y + off, 0, world.h);
      if(!anyOverlap(targetX, ty)){ player.y = ty; player.x = targetX; return true; }
    }
  } else {
    // intenta izquierda/derecha un poco y luego aplicar Y
    for(const off of [-SLIDE, SLIDE]){
      const tx = clamp(player.x + off, 0, world.w);
      if(!anyOverlap(tx, targetY)){ player.x = tx; player.y = targetY; return true; }
    }
  }
  return false;
}

// Si por lo que sea aparece dentro, empuja hacia afuera con el mínimo movimiento
function nudgeOut(){
  let moved = false;
  for(const ob of OBSTACLES){
    if(!ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) continue;

    // Vector del centro de la elipse al punto más cercano del rect
    const qx = clamp(player.x, ob.x, ob.x + ob.w);
    const qy = clamp(player.y + FEET_OFFSET_Y, ob.y, ob.y + ob.h);
    let dx = player.x - qx, dy = (player.y + FEET_OFFSET_Y) - qy;

    // normalizamos por los radios para estimar penetración mínima
    const ndx = dx / FEET_RADIUS_X, ndy = dy / FEET_RADIUS_Y;
    const len = Math.hypot(ndx, ndy) || 1e-6;
    // cuánto falta para salir (1 = justo tocando)
    const overlap = 1 - len + 0.001; // epsilon
    if(overlap > 0){
      // empuje mínimo en espacio normalizado, luego des-escalamos
      const pushX = (ndx/len) * overlap * FEET_RADIUS_X;
      const pushY = (ndy/len) * overlap * FEET_RADIUS_Y;
      player.x += pushX;
      player.y += pushY;
      moved = true;
    }
  }
  return moved;
}

/* ========== UPDATE ========== */
function update(dt){
  const vx = (keys.left?-1:0) + (keys.right?1:0);
  const vy = (keys.up?-1:0) + (keys.down?1:0);
  player.moving = !!(vx||vy);

  if (player.moving){
    player.dir = Math.abs(vx)>Math.abs(vy) ? (vx<0?'left':'right') : (vy<0?'up':'down');
    const len = Math.hypot(vx,vy)||1;
    const stepx = (vx/len)*player.speed*dt;
    const stepy = (vy/len)*player.speed*dt;

    // límites por tamaño del sprite
    const sw=JUAN.size.w, sh=JUAN.size.h, s=JUAN.scale;
    const halfW=Math.round(sw*s)/2, halfH=Math.round(sh*s)/2;

    const nx = clamp(player.x + stepx, halfW, world.w - halfW);
    const ny = clamp(player.y + stepy, halfH, world.h - halfH);

    // prueba X
    let blockedX=false;
    for (const ob of OBSTACLES){
      if (ellipseRectOverlap(nx, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedX=true; break; }
    }
    if (!blockedX) player.x = nx;

    // prueba Y
    let blockedY=false;
    for (const ob of OBSTACLES){
      if (ellipseRectOverlap(player.x, ny + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedY=true; break; }
    }
    if (!blockedY) player.y = ny;

    // si ambos bloqueados, intenta deslizar; si no, empujón mínimo
    if (blockedX && blockedY){
      if (!cornerSlide(nx, ny, stepx, stepy)) nudgeOut();
    }

    // animación
    player.frameTime += dt;
    if (player.frameTime >= 0.12){ player.frame=(player.frame+1)%2; player.frameTime=0; }
  } else {
    player.frame = 0;
  }

  // seguridad por si quedó dentro de algo (spawn/resize)
  nudgeOut();

  centerCameraOnPlayer();
}


/* ========== DRAW ========== */
/* ========== DRAW ========== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Fondo dentro del rect de pantalla
  let sx = Math.round(cam.x), sy = Math.round(cam.y);
  sx = clamp(sx, 0, world.w - cam.w);
  sy = clamp(sy, 0, world.h - cam.h);
  ctx.drawImage(bgImg, sx, sy, cam.w, cam.h, screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  // ⬇️ Todo lo demás recortado a screenRect (evita dibujar fuera de las bandas)
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  // Proyectamos JUAN primero (para el sort con depthBand)
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);
  const jFoot = jy + jh/2; // pie de Juan en pantalla (bottom-center)

  // build draw list (orden por y del pie)
  const list = [];

  // props (incluye soporte para animados: p.e. river)
  for(const p of PROPS){
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY; // pie en pantalla
    const dw = Math.round(p.iw * p.scale * mapScaleX);
    const dh = Math.round(p.ih * p.scale * mapScaleY);
    const dx = Math.round(px - dw/2), dy = Math.round(py - dh);
    const spec = CATALOG[p.type] || {};
    const band = spec.depthBand ?? (typeof DEPTH_BAND !== 'undefined' ? DEPTH_BAND : 48);

    // regla de orden con banda de profundidad
const sortY =
  (jFoot < py - band) ? (py + 0.5) :      // Juan claramente delante → prop detrás
  (jFoot > py + band) ? (py - 0.5) :      // Juan claramente detrás  → prop delante
  py;                                     // zona gris → empate
                               // zona gris → empate natural

    list.push({
      y: sortY,
      draw: ()=>{
        if(!p.img){
          ctx.fillStyle='#777'; ctx.fillRect(dx,dy,dw,dh);
          ctx.strokeStyle='#222'; ctx.strokeRect(dx,dy,dw,dh);
          return;
        }
        if(spec.animated){
          const speed = spec.speed ?? 0.02, t = performance.now()*speed, iw=p.iw, ih=p.ih;
          const scroll = ((t % iw)+iw)%iw, aSrcW=iw-scroll, aDstW = dw*(aSrcW/iw);
          ctx.drawImage(p.img, scroll,0,aSrcW,ih, dx,dy, Math.round(aDstW), dh);
          if(scroll>0){
            const bSrcW=scroll, bDstW=dw*(bSrcW/iw);
            ctx.drawImage(p.img, 0,0,bSrcW,ih, Math.round(dx+aDstW),dy, Math.round(bDstW),dh);
          }
        } else {
          ctx.drawImage(p.img, 0,0, p.iw,p.ih, dx,dy, dw,dh);
        }
      },
      debug: ()=>{
        if(DEBUG_PROPS && p.collider){
          const c=p.collider;
          const cx=screenRect.dx+(c.x-cam.x)*mapScaleX, cy=screenRect.dy+(c.y-cam.y)*mapScaleY;
          const cw=c.w*mapScaleX, ch=c.h*mapScaleY;
          ctx.save(); ctx.globalAlpha=.45; ctx.fillStyle='#33ff66'; ctx.strokeStyle='#003300';
          ctx.fillRect(Math.round(cx),Math.round(cy),Math.round(cw),Math.round(ch));
          ctx.strokeRect(Math.round(cx),Math.round(cy),Math.round(cw),Math.round(ch));
          ctx.restore();
        }
      }
    });
  }

  // Juan
  list.push({
    y: jy,
    draw: () => {
      ctx.fillStyle = 'rgba(0,0,0,.3)';
      ctx.beginPath();
      ctx.ellipse(jx, jy + Math.round(jh/2) - 4, jw/2.5, jh/6, 0, 0, Math.PI*2);
      ctx.fill();
      const img = player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];
      ctx.drawImage(img, 0,0, sw,sh, Math.round(jx - jw/2), Math.round(jy - jh/2), jw, jh);
    }
  });

  // pinta ordenado
  list.sort((a,b)=>a.y - b.y).forEach(it=>it.draw());
  list.forEach(it=>it.debug && it.debug());

  // DEBUG: obstáculos + pies (también dentro del clip)
  if(DEBUG_OBS){
    ctx.save();
    ctx.globalAlpha = .95; ctx.fillStyle = '#00e0ff'; ctx.font = 'bold 12px monospace';
    ctx.fillText('DEBUG ON', screenRect.dx + 8, screenRect.dy + 14);

    ctx.globalAlpha = .5; ctx.fillStyle = '#ff3366'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
    for(const ob of OBSTACLES){
      const dx = screenRect.dx + (ob.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (ob.y - cam.y) * mapScaleY;
      const dw = ob.w * mapScaleX, dh = ob.h * mapScaleY;
      ctx.fillRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.strokeRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    }

    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(
      jx,
      jy + FEET_OFFSET_Y * mapScaleY,
      FEET_RADIUS_X * mapScaleX,
      FEET_RADIUS_Y * mapScaleY,
      0, 0, Math.PI * 2
    );
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore(); // ⬅️ salimos del clip
}



/* ========== LOOP ========== */
function loop(t){ if(!loop.last) loop.last=t; const dt=Math.min(1/60,(t-loop.last)/1000); loop.last=t; update(dt); draw(); requestAnimationFrame(loop); }

/* ========== INIT ========== */
async function init(){
  const [bg,spr] = await Promise.all([loadImage(BG_SRC), preloadSprites(JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog();

  world.w=bgImg.naturalWidth; world.h=bgImg.naturalHeight;
  resize();

  // posición inicial
  const sw=JUAN.size.w, sh=JUAN.size.h, ss=JUAN.scale;
  const halfW=Math.round(sw*ss)/2, halfH=Math.round(sh*ss)/2;
  if(START.mode==='percent'){ player.x=world.w*(START.x/100); player.y=world.h*(START.y/100); }
  else { player.x=START.x; player.y=START.y; }
  player.x=clamp(player.x,halfW,world.w-halfW);
  player.y=clamp(player.y,halfH,world.h-halfH);

  buildPropsAndObstacles();
  centerCameraOnPlayer();
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
