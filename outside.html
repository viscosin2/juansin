<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin — props por capas + colisiones + debug</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html,body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  .screen::after{ content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%); z-index:5; }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:#000; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }
</style>
</head>
<body>
<div class="gameboy">
  <div class="screen-container"><div class="screen"><canvas id="game"></canvas></div></div>
  <div class="controls">
    <div class="dpad">
      <div></div><button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button><div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button><div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button><div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button><div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción" disabled></button>
  </div>
</div>

<script>
/* ========== CONFIG RÁPIDA ========== */
const ROOM = { w:512, h:350 };
const ZOOM = 2.1;
const START = { mode:'percent', x:7, y:81 };
const FEET_RADIUS_X = 7;
const FEET_RADIUS_Y = 4;
const FEET_OFFSET_Y = 8;
const DEBUG_OBS = true, DEBUG_PROPS = true;
const DEPTH_BAND = 12;

/* ========== ASSETS ========== */
const BG_SRC = "assets/locations/outside.png";
const JUAN = { size:{w:36,h:40}, scale:0.9,
  idle:{down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"]},
  walk:{down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
        up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
        left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
        right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"]}
};

// ========== NIEBLA ==========
const FOG = {
  alpha: 0,
  target: 0,
  speed: 2.5,
  color: 'rgba(220, 230, 255, 0.65)',
  clearOnExitDirs: ['top','right'],
  forceClearIfOutside: true
};
let _fogZonesBuilt = [];
let _prevFeet = null;
let _wasInsideZone = false;
const FOG_ZONES = [{type:'percent', x:2, y:33, w:30, h:25}];

/* ========== CATALOGO / PLACEMENT ========== */
const CATALOG = {
  arbolclaro:   { src:'assets/objects/arbolclaro.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbustoclaro: { src:'assets/objects/arbustoclaro.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  rock:         { src:'assets/objects/piedra.png',       scale:1, collider:{x:-11.5,y:-10,w:23.5,h:10} },
  valla_clara:  { src:'assets/objects/valla_clara.png',  scale:1, collider:null },
  valla_media:  { src:'assets/objects/valla_media.png',  scale:1, collider:{x:-50,y:3,w:50,h:1} },
  valla_oscura: { src:'assets/objects/valla_oscura.png', scale:1, collider:{x:-90,y:-5,w:300,h:1}},
  casajuan:     { src:'assets/objects/casajuan.png',     scale:1, collider:{x:-46.5,y:-5,w:91, h:21}, depthBand:1, depthAnchorY:1},
  casaclara:    { src:'assets/objects/casaclara.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_amarilla:{ src:'assets/objects/casaclara_amarilla.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_azul:{ src:'assets/objects/casaclara_azul.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  bridge:       { src:'assets/objects/puente.png', scale:1, collider:{x:-20,y:-15,w:10, h:3} },
  river1:       { src:'assets/objects/rio1.png',   scale:1, collider:null },
  river2:       { src:'assets/objects/rio2.png',   scale:1, collider:null }
};

const PLACED = {
  arbolclaro:  [{type:'percent',x:4,y:85},{type:'percent',x:17,y:87.5},{type:'percent',x:2,y:64},{type:'percent',x:28.2,y:65.5},{type:'percent',x:17.5,y:52},{type:'percent',x:3,y:8}],
  casajuan:    [{type:'percent',x:7.2,y:82}],
  casaclara_amarilla:[{type:'percent',x:24.5,y:90}],
  casaclara_azul:    [{type:'percent',x:5.5,y:45}],
  casaclara:         [{type:'percent',x:7,y:20}],
  arbustoclaro: [{type:'percent',x:3.2,y:97},{type:'percent',x:18.5,y:89},{type:'percent',x:25,y:67},{type:'percent',x:27.5,y:52},{type:'percent',x:5.3,y:54}],
  valla_clara:  [{type:'percent',x:15.25,y:99.75}],
  valla_media:  [{type:'percent',x:53.61,y:31.9}],
  valla_oscura: [{type:'percent',x:80.17,y:99.15}],
  rock:         [{type:'percent',x:60,y:72}],
  bridge:       [{type:'percent',x:24,y:21}],
  river1:       [{type:'percent', x:5.73,  y:62.37}],
  river2:       [{type:'percent', x:22.97, y:62.37}]
};

/* Obstáculos extra */
const OBSTACLE_DEFS = [
  {type:'percent', x:29.4, y:30.6, w:31.85, h:80,   name:'zona bloqueada 1'},
  {type:'percent', x:60,   y:30.6, w:17.9,  h:24.5, name:'zona bloqueada 2'},
  {type:'percent', x:-4,   y:51.5, w:15,  h:9, name:'zona bloqueada rio 1'},
  {type:'percent', x:16,   y:51.5, w:20,  h:9, name:'zona bloqueada rio 2'},
  {type:'percent', x:20.8,   y:10, w:6,  h:1, name:'zona bloqueada puente 5'},
  {type:'percent', x:0,   y:1, w:1,  h:110, name:'zona bloqueada 5'}
];

/* ========== STATE BÁSICO ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

let bgImg=null, sprites=null, world={w:0,h:0};
let PROP_IMAGES={}, PROPS=[], OBSTACLES=[];

let cam={x:0,y:0,w:ROOM.w/ZOOM|0,h:ROOM.h/ZOOM|0};
let screenRect={dx:0,dy:0,dw:0,dh:0}, mapScaleX=1, mapScaleY=1;

const player={x:0,y:0,dir:'down',speed:150,moving:false,frame:0,frameTime:0};

/* ========== INPUT (D-PAD) ========== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){ const start=e=>{e.preventDefault();on();}; const end=e=>{e.preventDefault();off();};
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
  btn.addEventListener('mousedown',start); window.addEventListener('mouseup',end);
}
bindHold(document.getElementById('btn-up'),   ()=>keys.up=true,   ()=>keys.up=false);
bindHold(document.getElementById('btn-down'), ()=>keys.down=true, ()=>keys.down=false);
bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);

/* ========== UTILS ========== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const loadImage=src=>new Promise(r=>{
  const i=new Image(); i.onload=()=>r(i); i.onerror=()=>{console.warn('No carga',src); r(null)}; i.src=src;
});
async function preloadSprites(map){
  const out={idle:{},walk:{},size:map.size,scale:map.scale};
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
const percentToWorld=(p)=>({x:Math.round(world.w*(p.x/100)), y:Math.round(world.h*(p.y/100))});

/* ========== LAYOUT / CÁMARA ========== */
function resize(){
  const sc=document.querySelector('.screen');
  canvas.width=sc.clientWidth; canvas.height=sc.clientHeight;
  const k=Math.min(canvas.width/ROOM.w, canvas.height/ROOM.h);
  screenRect.dw=ROOM.w*k; screenRect.dh=ROOM.h*k;
  screenRect.dx=(canvas.width-screenRect.dw)/2;
  screenRect.dy=(canvas.height-screenRect.dh)/2;
  cam.w=Math.max(64,Math.round(ROOM.w/ZOOM));
  cam.h=Math.max(64,Math.round(ROOM.h/ZOOM));
  mapScaleX=screenRect.dw/cam.w; mapScaleY=screenRect.dh/cam.h;
  cam.x=clamp(cam.x,0,world.w-cam.w); cam.y=clamp(cam.y,0,world.h-cam.h);
}
addEventListener('resize',resize);

function centerCameraOnPlayer(){
  cam.x=clamp(player.x-cam.w/2,0,world.w-cam.w);
  cam.y=clamp(player.y-cam.h/2,0,world.h-cam.h);
}

/* ========== COLISIÓN ========== */
function ellipseRectOverlap(cx, cy, rx, ry, rect){
  const qx = clamp(cx, rect.x, rect.x + rect.w);
  const qy = clamp(cy, rect.y, rect.y + rect.h);
  const dx = (cx - qx) / rx;
  const dy = (cy - qy) / ry;
  return (dx*dx + dy*dy) <= 1;
}
function anyOverlap(cx, cy){
  for(const ob of OBSTACLES) if(ellipseRectOverlap(cx, cy + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) return true;
  return false;
}

/* ========== PROPS / OBSTÁCULOS ========== */
async function preloadCatalog(){
  const entries=Object.entries(CATALOG);
  const res=await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  res.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}
function buildPropsAndObstacles(){
  PROPS=[]; OBSTACLES=[];

  for(const [type,list] of Object.entries(PLACED)){
    const spec=CATALOG[type]; const img=PROP_IMAGES[type];
    if(!spec || !list?.length) continue;

    for (const p of list) {
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x: p.x, y: p.y };
      const prop = {
        type, img,
        x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth : 32,
        ih: img ? img.naturalHeight : 32,
        scale: spec.scale || 1,
      };

      if (spec.collider) {
        const c = spec.collider, s = prop.scale;
        const col = {
          x: prop.x + c.x * s,
          y: prop.y + (c.y * s) - (c.h * s),
          w: c.w * s,
          h: c.h * s
        };
        prop.collider = col;
        OBSTACLES.push({ ...col, name: type });
      }

      PROPS.push(prop);
    }
  }

  for(const o of OBSTACLE_DEFS){
    const r=(o.type==='percent') ? { ...percentToWorld(o), w:Math.round(world.w*(o.w/100)), h:Math.round(world.h*(o.h/100)) } : o;
    OBSTACLES.push({x:r.x,y:r.y,w:r.w,h:r.h,name:o.name||'extra'});
  }
}

/* ========== HELPERS NIEBLA ========== */
function feetWorld() { return { x: player.x, y: player.y + FEET_OFFSET_Y }; }
function pointInRect(px, py, r) { return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h; }
function exitSide(prev, now, zone) {
  const cx = Math.min(Math.max(now.x, zone.x), zone.x + zone.w);
  const cy = Math.min(Math.max(now.y, zone.y), zone.y + zone.h);
  const dx = now.x - cx, dy = now.y - cy;
  if (Math.abs(dx) > Math.abs(dy)) return (dx > 0) ? 'right' : 'left';
  return (dy > 0) ? 'bottom' : 'top';
}
function buildFogZones() {
  const out = [];
  for (const z of FOG_ZONES) {
    if (z.type === 'percent') {
      out.push({
        x: Math.round(world.w * (z.x/100)),
        y: Math.round(world.h * (z.y/100)),
        w: Math.round(world.w * (z.w/100)),
        h: Math.round(world.h * (z.h/100))
      });
    } else out.push({ ...z });
  }
  return out;
}

/* ========== MOVIMIENTO Y UPDATE ========== */
function cornerSlide(targetX, targetY, vx, vy){
  const SLIDE = 3;
  if(Math.abs(vx) > Math.abs(vy)){
    for(const off of [-SLIDE, SLIDE]){
      const ty = clamp(player.y + off, 0, world.h);
      if(!anyOverlap(targetX, ty)){ player.y = ty; player.x = targetX; return true; }
    }
  } else {
    for(const off of [-SLIDE, SLIDE]){
      const tx = clamp(player.x + off, 0, world.w);
      if(!anyOverlap(tx, targetY)){ player.x = tx; player.y = targetY; return true; }
    }
  }
  return false;
}
function nudgeOut(){
  let moved = false;
  for(const ob of OBSTACLES){
    if(!ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) continue;
    const qx = clamp(player.x, ob.x, ob.x + ob.w);
    const qy = clamp(player.y + FEET_OFFSET_Y, ob.y, ob.y + ob.h);
    let dx = player.x - qx, dy = (player.y + FEET_OFFSET_Y) - qy;
    const ndx = dx / FEET_RADIUS_X, ndy = dy / FEET_RADIUS_Y;
    const len = Math.hypot(ndx, ndy) || 1e-6;
    const overlap = 1 - len + 0.001;
    if(overlap > 0){
      const pushX = (ndx/len) * overlap * FEET_RADIUS_X;
      const pushY = (ndy/len) * overlap * FEET_RADIUS_Y;
      player.x += pushX; player.y += pushY; moved = true;
    }
  }
  return moved;
}

function update(dt){
  const vx = (keys.left?-1:0) + (keys.right?1:0);
  const vy = (keys.up?-1:0) + (keys.down?1:0);
  player.moving = !!(vx||vy);

  if (player.moving){
    player.dir = Math.abs(vx)>Math.abs(vy) ? (vx<0?'left':'right') : (vy<0?'up':'down');
    const len = Math.hypot(vx,vy)||1;
    const stepx = (vx/len)*player.speed*dt;
    const stepy = (vy/len)*player.speed*dt;

    const sw=JUAN.size.w, sh=JUAN.size.h, s=JUAN.scale;
    const halfW=Math.round(sw*s)/2, halfH=Math.round(sh*s)/2;

    const nx = clamp(player.x + stepx, halfW, world.w - halfW);
    const ny = clamp(player.y + stepy, halfH, world.h - halfH);

    let blockedX=false, blockedY=false;
    for (const ob of OBSTACLES) if (ellipseRectOverlap(nx, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedX=true; break; }
    if (!blockedX) player.x = nx;

    for (const ob of OBSTACLES) if (ellipseRectOverlap(player.x, ny + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedY=true; break; }
    if (!blockedY) player.y = ny;

    if (blockedX && blockedY){
      if (!cornerSlide(nx, ny, stepx, stepy)) nudgeOut();
    }

    player.frameTime += dt;
    if (player.frameTime >= 0.12){ player.frame=(player.frame+1)%2; player.frameTime=0; }
  } else {
    player.frame = 0;
  }

  nudgeOut();
  centerCameraOnPlayer();

  // ===== NIEBLA: entrada/salida y target =====
  const feet = feetWorld();
  const insideNow = _fogZonesBuilt.some(z => pointInRect(feet.x, feet.y, z));

  if (insideNow) {
    FOG.target = 1;
  } else {
    if (FOG.forceClearIfOutside) {
      FOG.target = 0;
    } else if (_wasInsideZone) {
      const z = _fogZonesBuilt.find(z => pointInRect(_prevFeet.x, _prevFeet.y, z));
      if (z) {
        const side = exitSide(_prevFeet, feet, z);
        if (FOG.clearOnExitDirs.includes(side)) FOG.target = 0;
      } else {
        FOG.target = 0;
      }
    }
  }

  FOG.alpha += (FOG.target - FOG.alpha) * Math.min(1, dt * FOG.speed);
  _prevFeet = feet;
  _wasInsideZone = insideNow;
}

/* ========== DRAW ========== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  let sx = Math.round(cam.x), sy = Math.round(cam.y);
  sx = clamp(sx, 0, world.w - cam.w);
  sy = clamp(sy, 0, world.h - cam.h);
  ctx.drawImage(bgImg, sx, sy, cam.w, cam.h, screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  // ——— jugador en coords pantalla
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);
  const jFoot = jy + jh/2;

  const list = [];

  // props
  for(const p of PROPS){
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
    const dw = Math.round(p.iw * p.scale * mapScaleX);
    const dh = Math.round(p.ih * p.scale * mapScaleY);
    const dx = Math.round(px - dw/2), dy = Math.round(py - dh);
    const spec = CATALOG[p.type] || {};
    const band = spec.depthBand ?? DEPTH_BAND;
    const anchor = (spec.depthAnchorY ?? 0) * mapScaleY;
    const pyCut = py + anchor;

    const sortY =
      (jFoot < pyCut - band) ? (py + 0.5) :
      (jFoot > pyCut + band) ? (py - 0.5) :
      py;

    list.push({
      y: sortY,
      draw: ()=>{
        if(!p.img){
          ctx.fillStyle='#777'; ctx.fillRect(dx,dy,dw,dh);
          ctx.strokeStyle='#222'; ctx.strokeRect(dx,dy,dw,dh);
          return;
        }
        if(spec.flipX){
          ctx.save();
          ctx.scale(-1,1);
          ctx.drawImage(p.img, 0,0, p.iw,p.ih, -dx-dw, dy, dw, dh);
          ctx.restore();
        } else {
          ctx.drawImage(p.img, 0,0, p.iw,p.ih, dx,dy, dw,dh);
        }
      },
      debug: ()=>{
        if(DEBUG_PROPS && p.collider){
          const c=p.collider;
          const cx=screenRect.dx+(c.x-cam.x)*mapScaleX, cy=screenRect.dy+(c.y-cam.y)*mapScaleY;
          const cw=c.w*mapScaleX, ch=c.h*mapScaleY;
          ctx.save(); ctx.globalAlpha=.45; ctx.fillStyle='#33ff66'; ctx.strokeStyle='#003300';
          ctx.fillRect(Math.round(cx),Math.round(cy),Math.round(cw),Math.round(ch));
          ctx.strokeRect(Math.round(cx),Math.round(cy),Math.round(cw),Math.round(ch));
          ctx.restore();
        }
      }
    });
  }

  // jugador
  list.push({
    y: jFoot,
    draw: () => {
      ctx.fillStyle = 'rgba(0,0,0,.3)';
      ctx.beginPath();
      ctx.ellipse(jx, jy + Math.round(jh/2) - 4, jw/2.5, jh/6, 0, 0, Math.PI*2);
      ctx.fill();
      const img = player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];
      ctx.drawImage(img, 0,0, sw,sh, Math.round(jx - jw/2), Math.round(jy - jh/2), jw, jh);
    }
  });

  // pintar ordenado
  list.sort((a,b)=>a.y - b.y).forEach(it=>it.draw());
  list.forEach(it=>it.debug && it.debug());

  // ===== NIEBLA A PANTALLA COMPLETA (fade con FOG.alpha)
  if (FOG.alpha > 0.001) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
    ctx.clip();
    ctx.globalAlpha = FOG.alpha;
    ctx.fillStyle = FOG.color;
    ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
    ctx.restore();
  }

  // ===== DEBUG: obstáculos + pies
  if(DEBUG_OBS){
    ctx.save();
    ctx.globalAlpha = .95; ctx.fillStyle = '#00e0ff'; ctx.font = 'bold 12px monospace';
    ctx.fillText('DEBUG ON', screenRect.dx + 8, screenRect.dy + 14);

    ctx.globalAlpha = .5; ctx.fillStyle = '#ff3366'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
    for(const ob of OBSTACLES){
      const dx = screenRect.dx + (ob.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (ob.y - cam.y) * mapScaleY;
      const dw = ob.w * mapScaleX, dh = ob.h * mapScaleY;
      ctx.fillRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.strokeRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    }

    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(
      jx,
      jy + FEET_OFFSET_Y * mapScaleY,
      FEET_RADIUS_X * mapScaleX,
      FEET_RADIUS_Y * mapScaleY,
      0, 0, Math.PI * 2
    );
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore(); // fin del clip de pantalla
}

/* ========== LOOP / INIT ========== */
function loop(t){ if(!loop.last) loop.last=t; const dt=Math.min(1/60,(t-loop.last)/1000); loop.last=t; update(dt); draw(); requestAnimationFrame(loop); }

async function init(){
  const [bg,spr] = await Promise.all([loadImage(BG_SRC), preloadSprites(JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog();

  world.w=bgImg.naturalWidth; world.h=bgImg.naturalHeight;
  _fogZonesBuilt = buildFogZones();
  resize();

  const sw=JUAN.size.w, sh=JUAN.size.h, ss=JUAN.scale;
  const halfW=Math.round(sw*ss)/2, halfH=Math.round(sh*ss)/2;
  if(START.mode==='percent'){ player.x=world.w*(START.x/100); player.y=world.h*(START.y/100); }
  else { player.x=START.x; player.y=START.y; }
  player.x=clamp(player.x,halfW,world.w-halfW);
  player.y=clamp(player.y,halfH,world.h-halfH);

  // postura inicial mirando abajo
  player.dir = 'down';
  player.moving = false;
  player.frame = 0;
  player.frameTime = 0;
  keys.up = keys.down = keys.left = keys.right = false;

  buildPropsAndObstacles();
  centerCameraOnPlayer();
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>