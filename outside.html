 <!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin — props por capas + colisiones + debug</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html,body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  .screen::after{ content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%); z-index:5; }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:#000; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }
</style>
</head>
<body>
<div class="gameboy">
  <div class="screen-container"><div class="screen"><canvas id="game"></canvas></div></div>
  <div class="controls">
    <div class="dpad">
      <div></div><button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button><div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button><div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button><div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button><div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción" disabled></button>
  </div>
</div>

<script>
/* ========== CONFIG RÁPIDA ========== */
const ROOM = { w:512, h:350 };                 // ventana lógica (mantiene bandas)
const ZOOM = 2.1;                               // 1 = sin zoom; 2.5 como pediste
const START = { mode:'percent', x:5, y:90 };    // posición inicial
const FEET_RADIUS_X = 7;   // ancho (horizontal)
const FEET_RADIUS_Y = 4;    // alto (vertical)
const FEET_OFFSET_Y = 8;   // píxeles hacia abajo, ajusta a tu gusto
const DEBUG_OBS = true, DEBUG_PROPS = true;     // overlays SIEMPRE activos
const DEPTH_BAND = 12; 

/* ========== ASSETS ========== */
const BG_SRC = "assets/locations/outside.png";
const JUAN = { size:{w:36,h:40}, scale:0.9,
  idle:{down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"]},
  walk:{down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
        up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
        left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
        right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"]}
};

/* Catálogo de props: (x,y) = pie (bottom-center); collider relativo al pie */
const CATALOG = {
  tree:   { src:'assets/objects/arbolclaro.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  bush:   { src:'assets/objects/arbustoclaro.png', scale:1, collider:{x:-16,y:-16,w:32,h:16} },
  rock:   { src:'assets/objects/piedra.png',       scale:1, collider:{x:-11.5,y:-10,w:23.5,h:10} },
  fence:  { src:'assets/objects/valla_clara.png',  scale:1, collider:null },
  house:  { src:'assets/objects/casajuan.png',     scale:1, collider:{x:-46.5,y:-5,w:91,h:21}, depthBand: 1, depthAnchorY: 1},
  bridge: { src:'assets/objects/puente.png',       scale:1, collider:null },
  river1: { src:'assets/objects/rio1.png', scale:1, collider:null, wavy:true,   innerMarginPct: 0.08, patches: 7, amp: 2.0,speed: 1.2, stretch: 0.03},
  river2: { src:'assets/objects/rio2.png', scale:1, collider:null, wavy:true,   innerMarginPct: 0.08, patches: 7, amp: 2.0,speed: 1.2, stretch: 0.03}
};

 const PLACED = {
  tree:  [{type:'percent',x:17,y:87.5},{type:'percent',x:22,y:64},{type:'percent',x:30,y:58}],
  house: [{type:'percent',x:7.2,y:82}],
  bush:  [{type:'percent',x:45,y:78},{type:'percent',x:48,y:79}],
  fence: [{type:'percent',x:15.25,y:99.75}],
  rock:  [{type:'percent',x:60,y:72}],
  bridge:[{type:'percent',x:55,y:65}],
  river1: [{type:'percent', x:5.8, y:62.3}],
  river2: [{type:'percent', x:23, y:62.3}]
};

/* Obstáculos extra (además de los de props) */
const OBSTACLE_DEFS = [
  {type:'percent', x:29.4, y:30.6, w:31.5, h:80, name:'zona bloqueada 1'},
  {type:'percent', x:60, y:30.6, w:19, h:24.5, name:'zona bloqueada 2'}
];

/* ========== STATE BÁSICO ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

let bgImg=null, sprites=null, world={w:0,h:0};
let PROP_IMAGES={}, PROPS=[], OBSTACLES=[];

let cam={x:0,y:0,w:ROOM.w/ZOOM|0,h:ROOM.h/ZOOM|0};
let screenRect={dx:0,dy:0,dw:0,dh:0}, mapScaleX=1, mapScaleY=1;

const player={x:0,y:0,dir:'down',speed:150,moving:false,frame:0,frameTime:0};

/* ========== INPUT: SOLO D-PAD ========== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){ const start=e=>{e.preventDefault();on();}; const end=e=>{e.preventDefault();off();};
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
  btn.addEventListener('mousedown',start); window.addEventListener('mouseup',end);
}
bindHold(document.getElementById('btn-up'),   ()=>keys.up=true,   ()=>keys.up=false);
bindHold(document.getElementById('btn-down'), ()=>keys.down=true, ()=>keys.down=false);
bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);

/* ========== UTILS CORTAS ========== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const loadImage=src=>new Promise(r=>{
  const i=new Image(); i.onload=()=>r(i); i.onerror=()=>{console.warn('No carga',src); r(null)}; i.src=src;
});
async function preloadSprites(map){
  const out={idle:{},walk:{},size:map.size,scale:map.scale};
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
const percentToWorld=(p)=>({x:Math.round(world.w*(p.x/100)), y:Math.round(world.h*(p.y/100))});

/* ========== LAYOUT / CÁMARA ========== */
function resize(){
  const sc=document.querySelector('.screen');
  canvas.width=sc.clientWidth; canvas.height=sc.clientHeight;
  const k=Math.min(canvas.width/ROOM.w, canvas.height/ROOM.h);
  screenRect.dw=ROOM.w*k; screenRect.dh=ROOM.h*k;
  screenRect.dx=(canvas.width-screenRect.dw)/2;
  screenRect.dy=(canvas.height-screenRect.dh)/2;
  cam.w=Math.max(64,Math.round(ROOM.w/ZOOM));
  cam.h=Math.max(64,Math.round(ROOM.h/ZOOM));
  mapScaleX=screenRect.dw/cam.w; mapScaleY=screenRect.dh/cam.h;
  cam.x=clamp(cam.x,0,world.w-cam.w); cam.y=clamp(cam.y,0,world.h-cam.h);
}
addEventListener('resize',resize);

function centerCameraOnPlayer(){
  cam.x=clamp(player.x-cam.w/2,0,world.w-cam.w);
  cam.y=clamp(player.y-cam.h/2,0,world.h-cam.h);
}

/* ========== COLISIÓN ========== */
// Centro de los pies (cx,cy), radios rx,ry, rect = {x,y,w,h}
function ellipseRectOverlap(cx, cy, rx, ry, rect){
  const qx = clamp(cx, rect.x, rect.x + rect.w);
  const qy = clamp(cy, rect.y, rect.y + rect.h);
  const dx = (cx - qx) / rx;
  const dy = (cy - qy) / ry;
  return (dx*dx + dy*dy) <= 1;
}
function anyOverlap(cx, cy){
  for(const ob of OBSTACLES) if(ellipseRectOverlap(cx, cy + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) return true;
  return false;
}



/* ========== PROPS / OBSTÁCULOS ========== */
async function preloadCatalog(){
  const entries=Object.entries(CATALOG);
  const res=await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  res.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}
function buildPropsAndObstacles(){
  PROPS=[]; OBSTACLES=[];

  // props -> instancias + colliders
  for(const [type,list] of Object.entries(PLACED)){
    const spec=CATALOG[type]; const img=PROP_IMAGES[type];
    if(!spec){ console.warn('Tipo desconocido',type); continue; }
    if(!list||!list.length){ continue; }

    for (const p of list) {
  const pos = (p.type === 'percent') ? percentToWorld(p) : { x: p.x, y: p.y };

  const prop = {
    type,
    img,
    x: pos.x,
    y: pos.y,
    iw: img ? img.naturalWidth : 32,
    ih: img ? img.naturalHeight : 32,
    scale: spec.scale || 1,
    // flags útiles por si quieres consultarlos luego
    wavy: !!spec.wavy,
    glint: !!spec.glint
  };

  // collider (si hay)
  if (spec.collider) {
    const c = spec.collider, s = prop.scale;
    const col = {
      x: prop.x + c.x * s,
      y: prop.y + (c.y * s) - (c.h * s),
      w: c.w * s,
      h: c.h * s
    };
    prop.collider = col;
    OBSTACLES.push({ ...col, name: type });
  }

  // si es “río animado”, prepara sus celdas internas (ventanas) 1 sola vez
  if (prop.wavy) {
    // puedes ajustar el 6 por prop o en spec.wavyCellCount
    prop._cells = makeWavyCells(prop, spec.wavyCellCount ?? 6);
  }

  PROPS.push(prop);
}

  }

  // obstáculos extra
  for(const o of OBSTACLE_DEFS){
    const r=(o.type==='percent') ? { ...percentToWorld(o), w:Math.round(world.w*(o.w/100)), h:Math.round(world.h*(o.h/100)) } : o;
    OBSTACLES.push({x:r.x,y:r.y,w:r.w,h:r.h,name:o.name||'extra'});
  }
}

/*=========== HELPERS =========== */

// ===== Helpers =====

// Marco interior: si margin < 1 lo tratamos como porcentaje; si no, como px.
function innerRect(dx,dy,dw,dh, margin){
  const m = (margin < 1) ? margin : (margin / Math.max(dw,dh));
  const ix = dx + dw*m, iy = dy + dh*m;
  const iw = dw * (1 - 2*m), ih = dh * (1 - 2*m);
  return {x:ix, y:iy, w:iw, h:ih};
}

// Genera parches fijos por prop: posiciones y tamaños relativos dentro del marco interior
function makeWavyPatches(prop, count=6){
  if (prop._patches) return prop._patches;
  const patches=[];
  for(let i=0;i<count;i++){
    const w = 0.18 + Math.random()*0.22;           // 18%–40% del ancho del marco
    const h = 0.18 + Math.random()*0.25;           // 18%–43% del alto del marco
    const x = Math.random()*(1-w);
    const y = Math.random()*(1-h);
    patches.push({
      x,y,w,h,
      phase: Math.random()*Math.PI*2,
      dir:   Math.random()<0.5 ? -1 : 1,          // izquierda/derecha
      speed: 0.8 + Math.random()*0.8,             // variación por parche
    });
  }
  return (prop._patches = patches);
}

// Dibuja “parches” wavy usando patrón repetido, con pequeño offset y estiramiento horizontal
function drawRiverWavy(img, dx,dy,dw,dh, spec, prop, t){
  // 1) borde intacto: sprite base
  ctx.drawImage(img, 0,0, img.naturalWidth,img.naturalHeight, dx,dy, dw,dh);

  // 2) dentro del marco interior aplicamos los parches
  const margin = spec.innerMarginPct ?? 0.06;      // 6% por defecto
  const IR = innerRect(dx,dy,dw,dh, margin);
  const patches = makeWavyPatches(prop, spec.patches ?? 6);

  // Escala del patrón para que coincida exactamente con dw x dh
  const baseSX = dw / img.naturalWidth;
  const baseSY = dh / img.naturalHeight;

  for(const p of patches){
    const px = IR.x + IR.w * p.x;
    const py = IR.y + IR.h * p.y;
    const pw = IR.w * p.w;
    const ph = IR.h * p.h;

    // animación por parche
    const j = Math.sin(t * (spec.speed ?? 1.2) * p.speed + p.phase);
    const off  = Math.round(j * (spec.amp ?? 2.0)) * p.dir;     // desplazamiento en px pantalla
    const sx   = baseSX * (1 + j * (spec.stretch ?? 0.03));     // estiramiento horizontal suave

    // clip al parche
    ctx.save();
    ctx.beginPath();
    ctx.rect(Math.floor(px), Math.floor(py), Math.ceil(pw), Math.ceil(ph));
    ctx.clip();

    // patrón repetido con transformación (solo mueve la textura)
    const pat = ctx.createPattern(img, 'repeat');
    const m = new DOMMatrix();
    m.a = sx;                 // scaleX (con “estirar”)
    m.d = baseSY;             // scaleY
    m.e = off;                // offset X
    m.f = 0;                  // offset Y
    pat.setTransform(m);

    ctx.fillStyle = pat;
    // rellenamos el marco interior (el clip deja visible solo el parche)
    ctx.fillRect(Math.floor(IR.x), Math.floor(IR.y), Math.ceil(IR.w), Math.ceil(IR.h));
    ctx.restore();
  }
}


 function cornerSlide(targetX, targetY, vx, vy){
  const SLIDE = 3; // píxeles mundo
  // Prioriza deslizar en el eje perpendicular al dominante
  if(Math.abs(vx) > Math.abs(vy)){
    // intenta subir/bajar un poco y luego aplicar X
    for(const off of [-SLIDE, SLIDE]){
      const ty = clamp(player.y + off, 0, world.h);
      if(!anyOverlap(targetX, ty)){ player.y = ty; player.x = targetX; return true; }
    }
  } else {
    // intenta izquierda/derecha un poco y luego aplicar Y
    for(const off of [-SLIDE, SLIDE]){
      const tx = clamp(player.x + off, 0, world.w);
      if(!anyOverlap(tx, targetY)){ player.x = tx; player.y = targetY; return true; }
    }
  }
  return false;
}

// Si por lo que sea aparece dentro, empuja hacia afuera con el mínimo movimiento
function nudgeOut(){
  let moved = false;
  for(const ob of OBSTACLES){
    if(!ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) continue;

    // Vector del centro de la elipse al punto más cercano del rect
    const qx = clamp(player.x, ob.x, ob.x + ob.w);
    const qy = clamp(player.y + FEET_OFFSET_Y, ob.y, ob.y + ob.h);
    let dx = player.x - qx, dy = (player.y + FEET_OFFSET_Y) - qy;

    // normalizamos por los radios para estimar penetración mínima
    const ndx = dx / FEET_RADIUS_X, ndy = dy / FEET_RADIUS_Y;
    const len = Math.hypot(ndx, ndy) || 1e-6;
    // cuánto falta para salir (1 = justo tocando)
    const overlap = 1 - len + 0.001; // epsilon
    if(overlap > 0){
      // empuje mínimo en espacio normalizado, luego des-escalamos
      const pushX = (ndx/len) * overlap * FEET_RADIUS_X;
      const pushY = (ndy/len) * overlap * FEET_RADIUS_Y;
      player.x += pushX;
      player.y += pushY;
      moved = true;
    }
  }
  return moved;
}

/* ========== UPDATE ========== */
function update(dt){
  const vx = (keys.left?-1:0) + (keys.right?1:0);
  const vy = (keys.up?-1:0) + (keys.down?1:0);
  player.moving = !!(vx||vy);

  if (player.moving){
    player.dir = Math.abs(vx)>Math.abs(vy) ? (vx<0?'left':'right') : (vy<0?'up':'down');
    const len = Math.hypot(vx,vy)||1;
    const stepx = (vx/len)*player.speed*dt;
    const stepy = (vy/len)*player.speed*dt;

    // límites por tamaño del sprite
    const sw=JUAN.size.w, sh=JUAN.size.h, s=JUAN.scale;
    const halfW=Math.round(sw*s)/2, halfH=Math.round(sh*s)/2;

    const nx = clamp(player.x + stepx, halfW, world.w - halfW);
    const ny = clamp(player.y + stepy, halfH, world.h - halfH);

    // prueba X
    let blockedX=false;
    for (const ob of OBSTACLES){
      if (ellipseRectOverlap(nx, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedX=true; break; }
    }
    if (!blockedX) player.x = nx;

    // prueba Y
    let blockedY=false;
    for (const ob of OBSTACLES){
      if (ellipseRectOverlap(player.x, ny + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedY=true; break; }
    }
    if (!blockedY) player.y = ny;

    // si ambos bloqueados, intenta deslizar; si no, empujón mínimo
    if (blockedX && blockedY){
      if (!cornerSlide(nx, ny, stepx, stepy)) nudgeOut();
    }

    // animación
    player.frameTime += dt;
    if (player.frameTime >= 0.12){ player.frame=(player.frame+1)%2; player.frameTime=0; }
  } else {
    player.frame = 0;
  }

  // seguridad por si quedó dentro de algo (spawn/resize)
  nudgeOut();

  centerCameraOnPlayer();
}

/* ========== DRAW ========== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Fondo dentro del rect de pantalla
  let sx = Math.round(cam.x), sy = Math.round(cam.y);
  sx = clamp(sx, 0, world.w - cam.w);
  sy = clamp(sy, 0, world.h - cam.h);
  ctx.drawImage(bgImg, sx, sy, cam.w, cam.h, screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  // ⬇️ Todo lo demás recortado a screenRect (evita dibujar fuera de las bandas)
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  // Proyectamos JUAN primero (para el sort con depthBand)
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);
  const jFoot = jy + jh/2; // pie de Juan en pantalla (bottom-center)

  // build draw list (orden por y del pie)
  const list = [];

  // props (incluye soporte para animados: p.e. river)
  for(const p of PROPS){
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY; // pie en pantalla
    const dw = Math.round(p.iw * p.scale * mapScaleX);
    const dh = Math.round(p.ih * p.scale * mapScaleY);
    const dx = Math.round(px - dw/2), dy = Math.round(py - dh);
    const spec = CATALOG[p.type] || {};
    const band = spec.depthBand ?? DEPTH_BAND;

    const anchor = (spec.depthAnchorY ?? 0) * mapScaleY;
    const pyCut = py + anchor;

    const sortY =
      (jFoot < pyCut - band) ? (py + 0.5) :
      (jFoot > pyCut + band) ? (py - 0.5) :
      py;

    list.push({
      y: sortY,
      draw: ()=>{
        if(!p.img){
          ctx.fillStyle='#777'; ctx.fillRect(dx,dy,dw,dh);
          ctx.strokeStyle='#222'; ctx.strokeRect(dx,dy,dw,dh);
          return;
        }

       if (spec.wavy) {
  const t = performance.now()/1000;
  drawRiverWavy(p.img, dx,dy, dw,dh, spec, p, t);
} else {
  ctx.drawImage(p.img, 0,0, p.iw,p.ih, dx,dy, dw,dh);
}

      },
      debug: ()=>{
        if(DEBUG_PROPS && p.collider){
          const c=p.collider;
          const cx=screenRect.dx+(c.x-cam.x)*mapScaleX, cy=screenRect.dy+(c.y-cam.y)*mapScaleY;
          const cw=c.w*mapScaleX, ch=c.h*mapScaleY;
          ctx.save(); ctx.globalAlpha=.45; ctx.fillStyle='#33ff66'; ctx.strokeStyle='#003300';
          ctx.fillRect(Math.round(cx),Math.round(cy),Math.round(cw),Math.round(ch));
          ctx.strokeRect(Math.round(cx),Math.round(cy),Math.round(cw),Math.round(ch));
          ctx.restore();
        }
      }
    });
  }

  // Juan
  list.push({
    y: jFoot,
    draw: () => {
      ctx.fillStyle = 'rgba(0,0,0,.3)';
      ctx.beginPath();
      ctx.ellipse(jx, jy + Math.round(jh/2) - 4, jw/2.5, jh/6, 0, 0, Math.PI*2);
      ctx.fill();
      const img = player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];
      ctx.drawImage(img, 0,0, sw,sh, Math.round(jx - jw/2), Math.round(jy - jh/2), jw, jh);
    }
  });

  // pinta ordenado
  list.sort((a,b)=>a.y - b.y).forEach(it=>it.draw());
  list.forEach(it=>it.debug && it.debug());

  // DEBUG: obstáculos + pies (también dentro del clip)
  if(DEBUG_OBS){
    ctx.save();
    ctx.globalAlpha = .95; ctx.fillStyle = '#00e0ff'; ctx.font = 'bold 12px monospace';
    ctx.fillText('DEBUG ON', screenRect.dx + 8, screenRect.dy + 14);

    ctx.globalAlpha = .5; ctx.fillStyle = '#ff3366'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
    for(const ob of OBSTACLES){
      const dx = screenRect.dx + (ob.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (ob.y - cam.y) * mapScaleY;
      const dw = ob.w * mapScaleX, dh = ob.h * mapScaleY;
      ctx.fillRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.strokeRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    }

    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(
      jx,
      jy + FEET_OFFSET_Y * mapScaleY,
      FEET_RADIUS_X * mapScaleX,
      FEET_RADIUS_Y * mapScaleY,
      0, 0, Math.PI * 2
    );
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore(); // ⬅️ salimos del clip
}


/* ========== LOOP ========== */
function loop(t){ if(!loop.last) loop.last=t; const dt=Math.min(1/60,(t-loop.last)/1000); loop.last=t; update(dt); draw(); requestAnimationFrame(loop); }

/* ========== INIT ========== */
async function init(){
  const [bg,spr] = await Promise.all([loadImage(BG_SRC), preloadSprites(JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog();

  world.w=bgImg.naturalWidth; world.h=bgImg.naturalHeight;
  resize();

  // posición inicial
  const sw=JUAN.size.w, sh=JUAN.size.h, ss=JUAN.scale;
  const halfW=Math.round(sw*ss)/2, halfH=Math.round(sh*ss)/2;
  if(START.mode==='percent'){ player.x=world.w*(START.x/100); player.y=world.h*(START.y/100); }
  else { player.x=START.x; player.y=START.y; }
  player.x=clamp(player.x,halfW,world.w-halfW);
  player.y=clamp(player.y,halfH,world.h-halfH);

  player.dir = 'down';
  player.moving = false;
  player.frame = 0;
  player.frameTime = 0;
  keys.up = keys.down = keys.left = keys.right = false;

  buildPropsAndObstacles();
  centerCameraOnPlayer();
  requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
