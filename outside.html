<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin — outside</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html,body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  .screen::after{ content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%); z-index:5; }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:#000; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }
  .img-act::before{
    content:""; display:block; width:100%; height:100%;
    background:url("assets/ui/action_btn.PNG") center/contain no-repeat; image-rendering:pixelated; transform:scale(1.02);
  }

  #blackfade{
  position:fixed; inset:0;
  background:#000;
  z-index:9999;
  opacity:1;
  transition: opacity 1.5s ease; /* duración del fade */
}
#blackfade.hide{
  opacity:0;
  pointer-events:none;
}


  /* Toast */
  .toast{
    position:absolute; top:19px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.8); color:#fff; font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px; border-radius:8px; opacity:0; transition:opacity .2s ease;
    white-space:nowrap; pointer-events:none; z-index:6;
  }
  .toast.show{ opacity:1; }

  /* Diálogo */
  .dialog{
    position:absolute; left:50%; bottom:10px; transform:translateX(-50%) scaleX(0); transform-origin:center bottom;
    width:calc(100% - 24px); max-width:460px; min-height:20px; box-sizing:border-box;
    padding:12px 16px 16px; display:flex; gap:10px; border-radius:10px; flex-direction:column; text-align:left;
    image-rendering:pixelated; z-index:7; transition:transform .22s ease;
    background:rgba(12,12,24,0.9); border-top:2px solid #3cf;
  }
  .dialog.show{ transform:translateX(-50%) scaleX(1); }
  .dialog-name.juan{ font-family:'Press Start 2P',system-ui; font-size:10px; color:#8df; margin-bottom:4px; text-shadow:0 1px 0 #000; }
  .dialog-name.other{ font-family:'Press Start 2P',system-ui; font-size:10px; color:#f98; margin-bottom:4px; text-shadow:0 1px 0 #000; }
  .dialog-text{ font-family:'VT323',monospace; font-size:18px; letter-spacing:1px; line-height:1.15; color:#E6F6FF; min-height:2.2em; }
  .dialog-hint{ margin-left:auto; color:#B8D7FF; font:600 12px/1 system-ui; opacity:0; transition:opacity .18s ease; }
  .dialog.ready .dialog-hint{ opacity:.9; }
</style>
</head>
<body>
<div class="gameboy">
  <div class="screen-container">
    <div class="screen">
      <div id="blackfade"></div>
      <div id="toast" class="toast"></div>

      <div id="dialog" class="dialog">
        <div id="dialogName" class="dialog-name"></div>
        <div id="dialogText" class="dialog-text"></div>
        <div id="dialogHint" class="dialog-hint">→</div>
      </div>

      <canvas id="game"></canvas>
    </div>
  </div>

  <div class="controls">
    <div class="dpad">
      <div></div><button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button><div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button><div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button><div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button><div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción"></button>
  </div>
</div>

<script>
/* ========== CONFIG RÁPIDA ========== */
const ROOM = { w:512, h:350 };
const ZOOM = 2.1;
const START = { mode:'percent', x:7, y:81 };
const FEET_RADIUS_X = 7, FEET_RADIUS_Y = 4, FEET_OFFSET_Y = 8;
const DEBUG_OBS = false;
const DEBUG_INTER = false;
const DEBUG_AMBIENT = false;
const DEBUG_CINE = true; 
const DEPTH_BAND = 12;
let interactBlocked = true;     
let initialDialogLock = false;  
let onDialogClosed = null;

/* ====== BACKBUFFER para blur en modo cine ====== */
let BACKBUF = document.createElement('canvas');
let BACKCTX = BACKBUF.getContext('2d');

/* ====== ESTADO CINEMÁTICA ====== */
const CUT = {
  active: false,        // hay cinemática en curso (bloquea input libre)
  id: null,             // 'cine1'...
  phase: null,          // subfase
  hijackAction: null,   // handler para el botón de acción durante la cine
  onEnd: null           // callback al terminar
};


const FOG = {
  active:false, parts:[],
  filling:false, tFill:0, fillDur:3000,      // 3s para “llenar”
  targetDensity: 200,                         // un pelín más denso
  baseAlpha: 0.03,                            // más opacidad por partícula
  seed: 1337,
  color: '255,255,255',
  layer: 'betweenBackAndActors',
  oneSideBias: 0.9,

  // fuerzas (más lento)
  swirl: 16,          // antes 32 → menos giro
  attract: 7,        // antes 18 → avanza más despacio al centro
  jitterAmp: 3,       // antes 6  → menos “tembleque”
  jitterFreq: 0.9,    // antes 1.3

  // banda superior (solo arriba)
  bandTop:    0.08,   // 8% desde arriba
  bandBottom: 0.50,_densityScale: 1,  // hasta mitad de pantalla aprox
  _aimAhead: false,     // si true, emite por delante de la cámara
  aheadBias: 0.24,      // cuánto adelantamos el “centro” (0 = centro, 0.24 ≈ 24% hacia arriba)
  space: 'screen',
  anchorWorld: null,
  areaW: 360,
  areaH: 140
};

// ******************************* SMOKE SUPER

  const SMOKE = {
  active: false,
  parts: [],
  anchor: null,            // {x,y} en mundo
  areaW: 90,              // ancho del “ovillo” de humo
  areaH: 35,               // alto del “ovillo”
  targetDensity: 80,       // densidad base
  color: '40,40,40',      // gris muy oscuro tirando a negro
  baseAlpha: 0.08,        // más denso (ajusta 0.07–0.1 según te guste)
  swirl: 10,               // remolino suave
  attract: 5,              // atracción al centro
  jitterAmp: 2.0,
  jitterFreq: 1.0,
  seed: 4242
};


/* ====== CAMERA TWEEN ====== */
const CAM_TWEEN = { on:false, t:0, dur:1000, sx:0, sy:0, ex:0, ey:0 };

/* ====== PORTRAITS (secuenciados) ====== */
const PORTRAITS = {
  active:false,
  blurPx:100,
  blurK:0,
  blurInMs:1000,
  blurOutMs:1000,
  slideMs:450,
  script:[],
  idx:0,
  left:{}, right:{},
  stage:'idle',
  forceBlurFallback: false
};

const PORTRAIT_SCALES = {
  Gandalf: 1.7,
  Juan:    1.7,
  SSJ:     1.7
};

const PORTRAIT_TOP_AIR = 15;   // aire fijo por arriba (px relativos a screenRect)
const PORTRAIT_BOTTOM_PAD = -40; // “colchón” desde abajo
const PORTRAIT_EDGE_INSET = -0.12;
  
const DEFAULT_SHADOW = {
  alpha: 0.28,     // opacidad de la elipse
  offsetY: -2,     // desplazamiento vertical desde los pies
  scaleX: 1/2.8,   // ancho relativo
  scaleY: 1/8      // alto relativo
};
// ====== BARRAS DE VIDA PARA CINE ======
const HPBARS = {
  active:false, alpha:0, fadeInMs:400, fadeOutMs:400,
  juan:100, ssj:100, juanT:100, ssjT:100, speed:120, // % por segundo
  show(juanPct=100, ssjPct=100){ this.active=true; this.alpha=0; this._showing=true; this._hiding=false; this.juan=this.juanT=juanPct; this.ssj=this.ssjT=ssjPct; },
  setTargets(juanPct, ssjPct){ if(juanPct!=null) this.juanT=juanPct; if(ssjPct!=null) this.ssjT=ssjPct; },
  hide(){ if(!this.active) return; this._hiding=true; this._showing=false; },
  update(dt){
    if(!this.active) return;
    const step = this.speed*dt;
    const lerp = (v,t)=> v + Math.sign(t-v)*Math.min(Math.abs(t-v), step);
    this.juan = lerp(this.juan, this.juanT);
    this.ssj  = lerp(this.ssj,  this.ssjT);
    if (this._showing){ this.alpha = Math.min(1, this.alpha + (dt*1000)/this.fadeInMs); if(this.alpha>=1) this._showing=false; }
    if (this._hiding){ this.alpha = Math.max(0, this.alpha - (dt*1000)/this.fadeOutMs); if(this.alpha<=0){ this._hiding=false; this.active=false; } }
  }
};

  function _ease(t){
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
}

function drawHPBars(){
  if(!HPBARS.active || HPBARS.alpha<=0) return;
  const a = Math.max(0, Math.min(1, HPBARS.alpha));

  const padSide   = Math.round(screenRect.dw * 0.02);  // margen lateral
  const gapCenter = Math.round(screenRect.dw * 0.04);  // hueco central
  const barW      = Math.round(screenRect.dw * 0.46);  // ancho de cada barra
  const barH      = 14;                                // alto barra
  const nameGap   = 10;                                // espacio entre nombre y barra
  const yTop      = Math.round(screenRect.dy + 16);    // todo pegado arriba

  const leftX  = Math.round(screenRect.dx + padSide);
  const rightX = Math.round(screenRect.dx + screenRect.dw - padSide - barW);

  const bgStyle   = 'rgba(255,255,255,0.18)';
  const frameStyle= 'rgba(255,255,255,0.35)';

  // Fuentes/nombres (rollo retro)
  const nameFont  = '12px "Press Start 2P", system-ui, sans-serif';
  const nameColor = '#E6F6FF';

  // Escalas de relleno
  const wSSJ  = Math.round(barW * (HPBARS.ssj/100));
  const wJuan = Math.round(barW * (HPBARS.juan/100));

  ctx.save();
  ctx.globalAlpha = a;

  // Nombres encima
  ctx.font = nameFont;
  ctx.fillStyle = nameColor;
  ctx.textBaseline = 'bottom';

  ctx.fillText('SSJ',  leftX,  yTop - 2);           // izquierda
  ctx.fillText('Juan', rightX + barW - ctx.measureText('Juan').width, yTop - 2); // derecha alineado dcha

  // Barras: fondo + relleno + marco
  // -- SSJ (izquierda)
  ctx.fillStyle = bgStyle;
  ctx.fillRect(leftX, yTop + nameGap, barW, barH);
  ctx.fillStyle = '#e03232'; // rojo SSJ
  ctx.fillRect(leftX, yTop + nameGap, wSSJ, barH);
  ctx.strokeStyle = frameStyle;
  ctx.strokeRect(leftX + 0.5, yTop + nameGap + 0.5, barW - 1, barH - 1);

  // -- Juan (derecha)
  ctx.fillStyle = bgStyle;
  ctx.fillRect(rightX, yTop + nameGap, barW, barH);
  ctx.fillStyle = '#3c88ff'; // azul Juan
  ctx.fillRect(rightX, yTop + nameGap, wJuan, barH);
  ctx.strokeStyle = frameStyle;
  ctx.strokeRect(rightX + 0.5, yTop + nameGap + 0.5, barW - 1, barH - 1);

  ctx.restore();
}


/* ========== ASSETS ========== */
const BG_SRC = "assets/locations/outside.png";
const JUAN = { size:{w:36,h:40}, scale:0.9,
  idle:{down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"]},
  walk:{down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
        up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
        left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
        right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"]}
};

  // justo debajo de: const player={x:0,y:0,dir:'down',speed:150,...};
const BREATH = {
  amp: 0.0,       // píxeles de subida/bajada
  scaleAmp: 0.01, // 2% de zoom al respirar (muy sutil)
  speed: 4      // Hz ~ velocidad del ciclo
};
let _nowSec = 0;  // tiempo en segundos (lo llenamos en loop)

const GAME_FLAGS = {
  talked_gunner: false,
  juansin_other_halo: false
};

  

/* ========== LINTERNA (opcional) ========== */
const LIGHT = {
  enabled: false,
  mode: 'cone',
  radius: 70,
  feather: 0.45,
  coneLen: 150,
  coneWidth: Math.PI/5,
  flicker: 0.03,
  brightness: 0.4,
  tint: '255,230,180'
};

async function preloadCinematicImages(){
  IMG_GANDALF_SMALL = await loadImage('assets/npcs/gandalf.png');
  IMG_GANDALF       = await loadImage('assets/portraits/gandalf_portrait.png');
  IMG_JUAN_BIG      = await loadImage('assets/portraits/juansin_portrait.png');
  IMG_JUAN_SSJ      = await loadImage('assets/portraits/juansin_ssj_portrait.png');
}

  // ------------------------ ZONAS CINE
  const CINE_ZONES = [
  { id:'cine1', rect:{type:'percent', x:10, y:50, w:10, h:5}, _done:true },
  { id:'cine3', rect:{type:'percent', x:84, y:79, w:1, h:50}, _done:false }

];
  function buildCineZones(){
  return CINE_ZONES.map(z=>{
    const r=z.rect;
    if (r.type==='percent'){
      return { ...z,
        x: Math.round(world.w*(r.x/100)), y: Math.round(world.h*(r.y/100)),
        w: Math.round(world.w*(r.w/100)), h: Math.round(world.h*(r.h/100))
      };
    }
    return {...z, x:r.x,y:r.y,w:r.w,h:r.h};
  });
}
let CINE_BUILT = [];

/* ========== ZONAS AMBIENTE (alphas por paleta, sin saltos) ========== */
const AMBIENT = {
  k: 0,            // intensidad global (sube en la intro)
  introMs: 1200,   // fade-in inicial de k
  fadeMs: 2000,    // duración del crossfade entre paletas
  alphas:  { peach: 1, bluehour: 0, hell: 0 },
  targets: { peach: 1, bluehour: 0, hell: 0 }
};

const AMBIENT_ZONES = [
  {
    name:'Bluehour zone', palette:'bluehour',
    dialogOnEnter:[
      { speaker:'Juan', text:'...' },
      { speaker:'Juan', text:'Mensaje rollo válgame qué oscuro el bosque.' }
    ],
    dialogDelayMs: 500, lockMs: 1000,rect:{type:'percent', x:24, y:0, w:100, h:35}
  },
  {
    name:'Infierno super', palette:'hell',rect:{type:'percent', x:60, y:35, w:50, h:100}
  }
];

let ambientLock = false;
let ambientLockOwner = null;
let AMBIENT_BUILT = [];
let _ambientCurrentZone = null;
let introActive = true;
let initialDialogShown = false;
let NPC_IMAGES = {}, NPCS = [];


  /* ========== NPCs ========== */
// Catálogo de tipos de NPC (sprite, escala, collider, etc.)
const NPC_CATALOG = {
  abuela: { src: 'assets/npcs/abuela.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }},
  gato1: { src: 'assets/npcs/gato1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }},
  voldemort_perfil: { src: 'assets/npcs/voldemort_perfil.png', scale: 0.5, collider: { x:-20, y:0, w:30, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 },halo: { color: '80,255,140', radius: 34, alpha: 0.55 }},
  soldado1: { src: 'assets/npcs/soldado1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,muzzleOffset: { x: -20, y: -12 },shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 },fireFxMs: 140},
  soldado2: { src: 'assets/npcs/soldado2.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }},
  juansin_idle: { src: 'assets/juan_character/idle_down_shoes.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 }, depthBand: 8, depthAnchorY: 1, shadow:{ alpha:0.30, offsetY:-3, scaleX:1/2.4, scaleY:1/7 } },

};

const NPC_PLACED = {
  abuela: [{type:'percent', x: 2.5, y: 9, interact: { x:-14, y: 12, w:28, h:16 }, 
     dialog: [{ speaker:'Abuelita', text:'Buenas tardes, Juan. ¿Has visto a mi gato?' }, { speaker:'Juan',text:'Mmm… creo que estaba por el río.' }]
    }],
  gato1: [{type:'percent', x: 21, y: 61, interact: { x:-14, y: 12, w:28, h:16 }, 
     dialog: [{ speaker:'Gato', text:'Hola, buenas.' }, { speaker:'Juan',text:'WTF' }],sound: "assets/sounds/miau.mp3"
    }],
  voldemort_perfil: [{type:'percent', x: 82, y: 15.5, interact: { x:-35, y: 12, w:50, h:16 }, 
     dialog: [{ speaker:'Voldemort', text:'Ye.' }, { speaker:'Juan',text:'WTF' }]
    }],
  soldado1: [{id:'gunner1', type:'percent', x: 94, y: 66, interact: { x:-14, y: 12, w:28, h:16 },onFire:true, 
     dialog: [{ speaker:'Armiche', text:'Ahí te va un pequeño perdigón.'}],sound: "assets/sounds/shot.mp3"
    }],
  soldado2: [{id:'guard1', type:'percent', x: 86, y: 66, interact: { x:-14, y: 12, w:28, h:16 },requiresFlag:'talked_gunner', 
     dialogBlocked:[ {speaker:'Boliche', text:'¡Como en el Call of Duty, señores!'}], dialog: [{ speaker:'Boliche', text:'¡Ah! ¡Mi lentilla!' }]
    }],
  juansin_idle: [{id:'juansin_other', type:'percent', x: 77, y: 76, interact: { x:-14, y: 12, w:28, h:16 }
  }],
};


/* ========== CATALOGO / PLACEMENT ========== */
const CATALOG = {
  arbolclaro:   { src:'assets/objects/arbolclaro.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbolmedio:   { src:'assets/objects/arbolmedio.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arboloscuro:  { src:'assets/objects/arboloscuro.png',  scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbustoclaro: { src:'assets/objects/arbustoclaro.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustomedio: { src:'assets/objects/arbustomedio.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustooscuro:{ src:'assets/objects/arbustooscuro.png',scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustooscuroescondite:{ src:'assets/objects/arbustooscuro.png', scale:1, collider:null },
  piedra:       { src:'assets/objects/piedra.png',       scale:1, collider:{x:-28,y:-4,w:55,h:27} },
  piedraFlip:   { src:'assets/objects/piedra.png',       scale:1, collider:{x:-28,y:-4,w:55,h:27}, flipX:true },
  piedraBig:    { src:'assets/objects/piedra.png',       scale:1.2, collider:{x:-28,y:-4,w:55,h:27} },
  valla_clara:  { src:'assets/objects/valla_clara.png',  scale:1, collider:null },
  valla_media:  { src:'assets/objects/valla_media.png',  scale:1, collider:{x:-50,y:3,w:50,h:1} },
  valla_oscura: { src:'assets/objects/valla_oscura.png', scale:1, collider:{x:-210,y:-4.5,w:500,h:1}},
  casajuan:     { src:'assets/objects/casajuan.png',     scale:1, collider:{x:-46.5,y:-5,w:91, h:21}, depthBand:1, depthAnchorY:1, interact:{x:-20,y:5,w:38,h:18}},
  casaclara:    { src:'assets/objects/casaclara.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_amarilla:{ src:'assets/objects/casaclara_amarilla.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_azul:{ src:'assets/objects/casaclara_azul.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casamedia:    { src:'assets/objects/casamedia.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casamedia_roja:{ src:'assets/objects/casamedia_roja.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casamedia_rosa:{ src:'assets/objects/casamedia_rosa.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casaoscura:    { src:'assets/objects/casaoscura.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaoscura_roja:{ src:'assets/objects/casaoscura_roja.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaoscura_rosa:{ src:'assets/objects/casaoscura_rosa.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  puente:       { src:'assets/objects/puente.png', scale:1, collider:{x:-33.5,y:0,w:67.8, h:11} },
  puente2:      { src:'assets/objects/puente2.png', scale:1, collider:null},
  river1:       { src:'assets/objects/rio1.png',   scale:1, collider:null, forceBack: true},
  river2:       { src:'assets/objects/rio2.png',   scale:1, collider:null, forceBack: true},
  super:        { src:'assets/objects/super.png',  scale:1, collider:{x:-63,y:-5,w:120, h:23}, depthBand:1, depthAnchorY:1}
};

const PLACED = {
  arbolclaro:  [{type:'percent',x:4,y:85},{type:'percent',x:17,y:87.5},{type:'percent',x:2,y:64},{type:'percent',x:28.2,y:64},{type:'percent',x:17.5,y:52},{type:'percent',x:22.5,y:31.5},{type:'percent',x:3,y:8}],
  arbolmedio:  [{type:'percent',x:25.8,y:30},{type:'percent',x:25.3,y:12},{type:'percent',x:37,y:19},{type:'percent',x:47,y:19},{type:'percent',x:57,y:20},{type:'percent',x:70,y:14},{type:'percent',x:33,y:10},
                {type:'percent',x:40,y:30},{type:'percent',x:50,y:30},{type:'percent',x:60,y:30},{type:'percent',x:70,y:30},{type:'percent',x:76.5,y:22.5},{type:'percent',x:86.5,y:22.5},{type:'percent',x:78,y:10},
                {type:'percent',x:83,y:10.5},{type:'percent',x:85,y:32},{type:'percent',x:79,y:35},{type:'percent',x:96,y:9},{type:'percent',x:94,y:20},{type:'percent',x:96.5,y:30}],
  arboloscuro:  [{type:'percent',x:83,y:55},{type:'percent',x:78.5,y:58},{type:'percent',x:63,y:61},{type:'percent',x:85,y:79},{type:'percent',x:78,y:100.5}],
  casajuan:    [{type:'percent',x:7.2,y:82,say:'Tengo una misión.'}],
  casaclara_amarilla:[{type:'percent',x:24.5,y:90,interact:[{x:-22,y:5,w:19,h:18,say:'Puerta'},{x:12,y:5,w:13,h:18,say:'Un girasol.'}]}],
  casaclara_azul:    [{type:'percent',x:5.5,y:45}],
  casaclara:         [{type:'percent',x:7,y:20}],
  casamedia_roja:    [{type:'percent',x:42,y:17}],
  casamedia_rosa:    [{type:'percent',x:62,y:17}],
  casamedia:         [{type:'percent',x:52,y:17}],
  casaoscura_roja:   [{type:'percent',x:95.5,y:62}],
  casaoscura_rosa:   [{type:'percent',x:65,y:92}],
  casaoscura:        [{type:'percent',x:95.5,y:85}],
  arbustoclaro: [{type:'percent',x:3.2,y:97},{type:'percent',x:18.5,y:89},{type:'percent',x:25,y:66},{type:'percent',x:17,y:63},{type:'percent',x:9,y:62.5},{type:'percent',x:27.8,y:52},{type:'percent',x:5.3,y:54},
                 {type:'percent',x:23,y:40},{type:'percent',x:22,y:35.5},{type:'percent',x:23.5,y:10}],
  arbustomedio: [{type:'percent',x:27.5,y:33.5},{type:'percent',x:30,y:12},{type:'percent',x:46,y:20},{type:'percent',x:57,y:31},{type:'percent',x:37,y:31},{type:'percent',x:68,y:16},{type:'percent',x:84.5,y:13},
                 {type:'percent',x:72,y:11},{type:'percent',x:74,y:13.5},{type:'percent',x:80,y:12},{type:'percent',x:86,y:9},{type:'percent',x:90,y:12},{type:'percent',x:97,y:11},{type:'percent',x:76,y:25},
                 {type:'percent',x:96,y:25},{type:'percent',x:82,y:33},{type:'percent',x:94,y:32}],
  arbustooscuro: [{type:'percent',x:97,y:49},{type:'percent',x:86,y:57},{type:'percent',x:65,y:63},{type:'percent',x:83,y:79},{type:'percent',x:97,y:96}],
  arbustooscuroescondite: [{type:'percent',x:86,y:81}],
  valla_clara:  [{type:'percent',x:15.25,y:99.75}],
  valla_media:  [{type:'percent',x:53.61,y:31.9}],
  valla_oscura: [{type:'percent',x:80.17,y:99.15}],
  piedra:       [{type:'percent',x:84.66,y:44}],
  piedraFlip:   [{type:'percent',x:80.35,y:41}],
  piedraBig:    [{type:'percent',x:96.1,y:43}],
  puente:       [{type:'percent',x:23.97,y:20.95}],
  puente2:      [{type:'percent',x:23.97,y:13.23}],
  river1:       [{type:'percent', x:5.73,  y:62.37}],
  river2:       [{type:'percent', x:22.91, y:62.37}],
  super:        [{type:'percent', x:72.9, y:74}]
};

/* Obstáculos extra */
const OBSTACLE_DEFS = [
  {type:'percent', x:29.4, y:30.6, w:31.85, h:80,   name:'zona bloqueada 1'},
  {type:'percent', x:60,   y:30.6, w:17.9,  h:24.5, name:'zona bloqueada 2'},
  {type:'percent', x:-4,   y:52,   w:15.5,  h:9.7,  name:'zona bloqueada rio 1'},
  {type:'percent', x:15.3, y:51,   w:22,    h:8.5,  name:'zona bloqueada rio 2'},
  {type:'percent', x:20.6, y:11.5, w:6.5,   h:1.5,  name:'zona bloqueada puente 5'},
  {type:'percent', x:21.8, y:36.5, w:12,    h:1,    name:'zona bloqueada valla pequeña clara'},
  {type:'percent', x:24,   y:20.4, w:0.5,   h:15.7, name:'zona bloqueada valla pequeña clara 2'},
  {type:'percent', x:24,   y:0,    w:0.5,   h:10,   name:'zona bloqueada valla pequeña clara 3'},
  {type:'percent', x:0,    y:1,    w:1,     h:110,  name:'zona bloqueada valla izquiera larga'},
  {type:'percent', x:77.5, y:45.5, w:4,     h:9.5,  name:'zona bloqueada pequeña final bosque'},
  {type:'percent', x:87.3, y:34.8, w:0.8,   h:10.2, name:'zona bloqueada puente oscuro 1'},
  {type:'percent', x:92.1, y:34.8, w:0.8,   h:10.2, name:'zona bloqueada puente oscuro 2'},
  {type:'percent', x:81,   y:45.5, w:0.7,   h:32,   name:'zona bloqueada valla oscura central'}
];

/* ========== STATE BÁSICO ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

let bgImg=null, sprites=null, world={w:0,h:0};
let PROP_IMAGES={}, PROPS=[], OBSTACLES=[];
let cam={x:0,y:0,w:ROOM.w/ZOOM|0,h:ROOM.h/ZOOM|0};
let screenRect={dx:0,dy:0,dw:0,dh:0}, mapScaleX=1, mapScaleY=1;

const player={x:0,y:0,dir:'down',speed:150,moving:false,frame:0,frameTime:0};

/* ========== INPUT (SOLO D-PAD EN PANTALLA) ========== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){
  const start=e=>{e.preventDefault();on();};
  const end=e=>{e.preventDefault();off();};
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
}
bindHold(document.getElementById('btn-up'),   ()=>keys.up=true,   ()=>keys.up=false);
bindHold(document.getElementById('btn-down'), ()=>keys.down=true, ()=>keys.down=false);
bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);
function bindPressVisual(el){
  const on=()=>el.classList.add('pressed'), off=()=>el.classList.remove('pressed');
  el.addEventListener('touchstart',e=>{e.preventDefault();on()},{passive:false});
  el.addEventListener('touchend',off,{passive:false}); el.addEventListener('touchcancel',off,{passive:false});
}
bindPressVisual(document.getElementById('btn-act'));

/* ====== TOAST ====== */
function showToast(msg, ms=1800){
  const t = document.getElementById('toast');
  t.textContent = msg; t.classList.add('show');
  clearTimeout(showToast._to);
  showToast._to = setTimeout(()=>t.classList.remove('show'), ms);
}

  
/* ====== NPCS ====== */

  
  async function preloadNPCs(){
  const entries = Object.entries(NPC_CATALOG);
  const res = await Promise.all(entries.map(([k,v]) => loadImage(v.src).then(img => [k,img])));
  res.forEach(([k,img]) => { NPC_IMAGES[k] = img; });
}

function buildNPCs(){
  NPCS = [];
  for (const [type, list] of Object.entries(NPC_PLACED)){
    const spec = NPC_CATALOG[type];
    const img  = NPC_IMAGES[type];
    if(!spec || !list?.length) continue;

    for (const p of list){
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x:p.x, y:p.y };
      const s   = spec.scale || 1;
      const npc = {
        id: p.id || `${type}_${Math.random().toString(36).slice(2,7)}`,
        type, img,
        x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth  : 32,
        ih: img ? img.naturalHeight : 32,
        scale: s,
        depthBand: spec.depthBand ?? DEPTH_BAND,
        depthAnchorY: spec.depthAnchorY ?? 0,
        dialog: Array.isArray(p.dialog) ? p.dialog : null,
        sound: p.sound ? new Audio(p.sound) : null,
        dialogBlocked: Array.isArray(p.dialogBlocked) ? p.dialogBlocked : null,
        requiresFlag: p.requiresFlag || null,
        onFire: !!p.onFire,
        muzzleOffset: spec.muzzleOffset || {x:0,y:0},
        fireFxMs: spec.fireFxMs || 120,
        _fxActive: false,
        _fxUntil: 0,
        shadow: { ...DEFAULT_SHADOW, ...(spec.shadow||{}), ...(p.shadow||{}) }
      };
      // heredar halo del catálogo y permitir override desde placement
if ((NPC_CATALOG[type] && NPC_CATALOG[type].halo) || p.halo){
  npc.halo = { ...(NPC_CATALOG[type].halo || {}), ...(p.halo || {}) };
}


      // collider opcional (bloquea como obstáculo)
      if (spec.collider){
        const c = spec.collider;
        const col = { x: npc.x + c.x*s, y: npc.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
        npc.collider = col;
        OBSTACLES.push({ ...col, name:`npc:${type}` });
      }

      // zona de interacción para abrir diálogo
      if (p.interact){
  const i = p.interact;
  npc.interacts = [{
    x: npc.x + i.x*s,
    y: npc.y + (i.y*s) - (i.h*s),
    w: i.w*s,
    h: i.h*s,
    npcRefId: npc.id,     // << clave para que el handler encuentre al NPC
    dialog: npc.dialog,
    sound: npc.sound
  }];
}
if (npc.id === 'juansin_other' && GAME_FLAGS.juansin_other_halo) {
  npc.halo = { color:'255,255,160', radius:30, alpha:0.6, pulse:0.05, offsetY:0.62 };
}
      NPCS.push(npc);
    }
  }
}


/* ====== DIÁLOGO ====== */
const dialogEl     = document.getElementById('dialog');
const dialogNameEl = document.getElementById('dialogName');
const dialogTextEl = document.getElementById('dialogText');
const dialogHintEl = document.getElementById('dialogHint');

let dialogOpen=false, isTyping=false, typingTimer=null, typingSpeed=22, dialogIndex=0;
let dialogScript = [];
const DIALOG_BEEP = new Audio("assets/sounds/bip.mp3");
DIALOG_BEEP.volume = 0.5;

function openDialog(lines, startTyping=true){
  dialogScript = lines || [];
  dialogIndex = 0;
  dialogEl.classList.add('show');
  dialogEl.classList.remove('ready');
  dialogOpen = true;
  renderCurrentLine(startTyping);
}
function closeDialog(){
  dialogEl.classList.remove('show','ready');
  dialogOpen=false;

  // si el diálogo que se cierra es el inicial, liberamos interacciones
  if (initialDialogLock){
    initialDialogLock = false;
    interactBlocked = false;
  }

  if (ambientLock && ambientLockOwner){
    ambientLock = false;
    ambientLockOwner = null;
  }

  if (typeof onDialogClosed === 'function'){
    const fn = onDialogClosed;
    onDialogClosed = null;   // limpiar para que sea one–shot
    fn();
  }
}


  function closeCurrentDialogNow(){
  if (!dialogOpen) return;
  if (isTyping) advanceDialog();  // termina de escribir
  if (dialogOpen) advanceDialog(); // y cierra
}

function renderCurrentLine(startTyping=false){
  const line = dialogScript[dialogIndex] || {speaker:'', text:''};
  dialogNameEl.textContent = line.speaker || '';
  if (line.speaker === 'Juan'){
    dialogNameEl.className = 'dialog-name juan';
  } else {
    dialogNameEl.className = 'dialog-name other';
  }
  dialogTextEl.textContent = '';
  dialogHintEl.style.opacity = 0;
  if(startTyping) startTypingEffect(line.text);
  else { dialogTextEl.textContent = line.text; dialogEl.classList.add('ready'); }
}
function startTypingEffect(text){
  clearInterval(typingTimer);
  isTyping = true; let i=0;
  typingTimer = setInterval(()=>{
    if(i < text.length){
      const ch = text[i++]; dialogTextEl.textContent += ch;
      if(i % 2 === 0){ try { DIALOG_BEEP.currentTime = 0; DIALOG_BEEP.play(); } catch(e){} }
    } else {
      clearInterval(typingTimer);
      isTyping=false; dialogEl.classList.add('ready'); dialogHintEl.style.opacity=1;
    }
  }, typingSpeed);
}
function advanceDialog(){
  if(!dialogOpen) return;
  const full = dialogScript[dialogIndex]?.text ?? '';
  if(isTyping){
    clearInterval(typingTimer);
    isTyping=false;
    dialogTextEl.textContent = full;
    dialogEl.classList.add('ready'); dialogHintEl.style.opacity=1;
    return;
  }
  dialogIndex++;
  if(dialogIndex < dialogScript.length){
    dialogEl.classList.remove('ready'); dialogHintEl.style.opacity=0;
    renderCurrentLine(true);
  } else {
    closeDialog();
  }
}
document.getElementById('btn-act').addEventListener('touchstart', e=>{
  e.preventDefault();

  // si hay cinemática con hijack, primero eso
  if (CUT.active && typeof CUT.hijackAction === 'function'){
    CUT.hijackAction();
    return;
  }

  // si hay diálogo abierto: avanzar SIEMPRE
  if (dialogOpen){
    advanceDialog();
    return;
  }

  // si el sistema de interacciones está bloqueado (p. ej. al inicio), no hagas nada
  if (interactBlocked) return;

  // ——— A partir de aquí, interacciones normales ———

  // 1) NPCs con diálogo / lógica especial
  const npcHit = getNPCInteractHit();
  if (npcHit){
    const npc = NPCS.find(n => n.id === npcHit.npcRefId) || null;
    if (npc){   
      
    if (npc.id === 'juansin_other' && !GAME_FLAGS.juansin_other_halo){
      npc.halo = { color:'255,255,160', radius:30, alpha:0.6, pulse:0.05, offsetY:0.62 };
      GAME_FLAGS.juansin_other_halo = true;

      // (Opcional) mini destello de 300ms al activarse
      npc._fxActive = true;
      npc._fxUntil  = performance.now() + 1000;
    }

      if (npc.requiresFlag && !GAME_FLAGS[npc.requiresFlag]){
        if (npc.dialogBlocked && npc.dialogBlocked.length){
          openDialog(npc.dialogBlocked, true);
        } else {
          showToast('No parece querer hablar ahora.', 1400);
        }
        return;
      }
      if (npc.dialog && npc.dialog.length){
        openDialog(npc.dialog, true);
      }
      if (npc.onFire){
        setTimeout(() => { triggerNPCShot(npc); }, 1500);
        GAME_FLAGS.talked_gunner = true;
      }
      return;
    }
  }

  // 2) Props con "say" => toast
  const propHit = getInteractHit();
  if (propHit && propHit.say){
    showToast(propHit.say, 1800);
    return;
  }
}, {passive:false});


/* ========== UTILS ========== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const loadImage=src=>new Promise(r=>{ const i=new Image(); i.onload=()=>r(i); i.onerror=()=>{console.warn('No carga',src); r(null)}; i.src=src; });
async function preloadSprites(map){
  const out={idle:{},walk:{},size:map.size,scale:map.scale};
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
const percentToWorld=(p)=>({x:Math.round(world.w*(p.x/100)), y:Math.round(world.h*(p.y/100))});
const lerpT=(t,dt,ms)=> (ms<=0?1: Math.min(1, t + (dt*1000)/ms));
function triggerNPCShot(npc){
  npc._fxActive = true;
  npc._fxUntil  = performance.now() + npc.fireFxMs;

  // sonido si existe (mapa y sample)
  if (typeof NPC_SOUNDS !== 'undefined' && NPC_SOUNDS && NPC_SOUNDS[npc.type]) {
    const snd = NPC_SOUNDS[npc.type];
    try { snd.currentTime = 0; snd.play(); } catch(e){}
  }
}


function isNPCFxActive(npc){
  if (!npc._fxActive) return false;
  if (performance.now() > npc._fxUntil){
    npc._fxActive = false;
    return false;
  }
  return true;
}

// --------------------- FUNCIONES PORTRAITS

function _makeSide(img, side, name, slotOverride){
  if (!img) {
    img = { naturalWidth: 64, naturalHeight: 64 };
  }

  // área horizontal base (seguimos respetando el ancho del área de juego para insets)
  const maxW = Math.floor(screenRect.dw * 0.52);
  const charScale = (PORTRAIT_SCALES && PORTRAIT_SCALES[name]) ? PORTRAIT_SCALES[name] : 1;

  // ---- cálculo de altura disponible:
  // modo normal -> dentro del área de juego
  // modo letterbox -> dentro de la banda negra superior/inferior
  const useLetterbox = (PORTRAITS.layout === 'letterbox');
  const topBarH    = Math.max(0, Math.round(screenRect.dy));
  const bottomBarH = Math.max(0, Math.round(canvas.height - (screenRect.dy + screenRect.dh)));
  const padTop = 6, padBottom = 8; // acolchados discretos

  let availH, yBottom;

  if (useLetterbox){
    const slot = slotOverride || (side === 'left' ? 'top' : 'bottom');
    if (slot === 'top'){
      // ocupa la banda negra superior
      availH  = Math.max(0, topBarH - padTop - padBottom);
      yBottom = screenRect.dy - padBottom; // borde inferior de la banda superior
    } else {
      // ocupa la banda negra inferior
      availH  = Math.max(0, bottomBarH - padTop - padBottom);
      yBottom = canvas.height - padBottom; // borde inferior del canvas
    }
  } else {
    // diseño clásico (dentro del área del juego)
    const PORTRAIT_TOP_AIR = 15;
    const PORTRAIT_BOTTOM_PAD = -40;
    const yBaseBottom = screenRect.dy + screenRect.dh - PORTRAIT_BOTTOM_PAD;
    const availInGame = screenRect.dh - (PORTRAIT_TOP_AIR + PORTRAIT_BOTTOM_PAD);
    availH  = Math.max(0, availInGame);
    yBottom = yBaseBottom;
  }

  // escala base (por ancho) y clamp por alto disponible
  let s = Math.min(1, (maxW / img.naturalWidth)) * charScale;
  let w = Math.round(img.naturalWidth  * s);
  let h = Math.round(img.naturalHeight * s);
  if (availH > 0 && h > availH){
    s *= (availH / h);
    w = Math.round(img.naturalWidth  * s);
    h = Math.round(img.naturalHeight * s);
  }

  const common = {
    img, name, side,
    w, h,
    yBottom,            // límite inferior donde “apoya” el retrato
    t:0, from:0, to:0, anim:false, onDone:null,
    alpha:0, aFrom:0, aTo:1
  };

  // inset horizontal relativo al área de juego (queda elegante)
  const PORTRAIT_EDGE_INSET = -0.12;
  const inset = Math.round(screenRect.dw * PORTRAIT_EDGE_INSET);

  if (side === 'left'){
    return {
      ...common,
      x:   screenRect.dx - w - 80,
      inX: screenRect.dx + inset,
      outX: screenRect.dx - w - 80
    };
  } else {
    return {
      ...common,
      x:   screenRect.dx + screenRect.dw + 80,
      inX: screenRect.dx + screenRect.dw - inset - w,
      outX: screenRect.dx + screenRect.dw + 80
    };
  }
}



function _startSlide(node, toX, cb){
  node.anim = true;
  node.t = 0;
  node.from = node.x;
  node.to = toX;
  node.onDone = (typeof cb === 'function') ? cb : null;

 if (toX === node.inX){
    node.aFrom = 0; node.aTo = 1;
    node.sFrom = 1.03; node.sTo = 1.00;   // ← entra 3% grande y asienta
  } else if (toX === node.outX){
    node.aFrom = 1; node.aTo = 0;
    node.sFrom = 1.00; node.sTo = 0.98;   // ← sale encogiendo 2%
  } else {
    node.aFrom = node.alpha ?? 1; node.aTo = node.alpha ?? 1;
    node.sFrom = node.sFrom ?? 1.00; node.sTo = node.sTo ?? 1.00;
  }
}



function _nodeForSpeaker(name){
  if (name === 'Gandalf' || name === 'SSJ') return PORTRAITS.left;
  return PORTRAITS.right;
}

function portraitsOpen(script){
  PORTRAITS.active = true;
  PORTRAITS.script = script.slice();
  PORTRAITS.idx = 0;
  PORTRAITS.blurK = 0;
  PORTRAITS.stage = 'entering';

  PORTRAITS.left  = _makeSide(IMG_GANDALF,  'left',  'Gandalf');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG, 'right', 'Juan');

  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  const line0 = PORTRAITS.script[PORTRAITS.idx];
  const node0 = _nodeForSpeaker(line0.speaker);
  _startSlide(node0, node0.inX, ()=>{
    PORTRAITS.stage = 'speaking';
    openDialog([line0], true);
  });

  CUT.hijackAction = () => {
    if (!PORTRAITS.active) return;
    if (dialogOpen){
      if (isTyping){
        clearInterval(typingTimer);
        isTyping = false;
        const full = dialogScript[dialogIndex]?.text ?? '';
        dialogTextEl.textContent = full;
        dialogEl.classList.add('ready');
        dialogHintEl.style.opacity = 1;
        return;
      }
      // cerrar y pasar al siguiente speaker en UNA sola pulsación
      closeDialog();
      _nextPortraitLine();
      return;
    }
  };
}


function _nextPortraitLine(){
  // si el texto ya se cerró, preparamos la transición al siguiente speaker
  PORTRAITS.idx++;
  if (PORTRAITS.idx >= PORTRAITS.script.length){
    // fin
    _endPortraits(); 
    return;
  }

  const prev = PORTRAITS.script[PORTRAITS.idx-1];
  const next = PORTRAITS.script[PORTRAITS.idx];

  const prevNode = _nodeForSpeaker(prev.speaker);
  const nextNode = _nodeForSpeaker(next.speaker);

  PORTRAITS.stage = 'exiting';
  // 1) sale el anterior
  _startSlide(prevNode, prevNode.outX, ()=>{
    // 2) entra el nuevo
    PORTRAITS.stage = 'entering';
    _startSlide(nextNode, nextNode.inX, ()=>{
      // 3) cuando el nuevo terminó de entrar → mostrar texto
      PORTRAITS.stage = 'speaking';
      openDialog([next], true);
    });
  });
}

function _endPortraits(){
  PORTRAITS.stage = 'ending';
  const t0 = performance.now();
  const dur = PORTRAITS.blurOutMs;
  function tick(){
    const k = Math.min(1, (performance.now()-t0)/dur);
    PORTRAITS.blurK = 1 - k;
    if (k<1) requestAnimationFrame(tick);
    else {
      PORTRAITS.active = false;
      CUT.hijackAction = null;
      if (typeof CUT.onEnd === 'function') CUT.onEnd();
    }
  }
  requestAnimationFrame(tick);
}

function portraitsUpdate(dt){
  if (!PORTRAITS.active) return;

  // blur in como ya tenías
  if (PORTRAITS.stage !== 'ending' && PORTRAITS.blurK < 1){
    PORTRAITS.blurK = Math.min(1, PORTRAITS.blurK + (dt*1000)/PORTRAITS.blurInMs);
  }

  const upd = (node)=>{
    if (!node?.anim) return;
    node.t = Math.min(1, node.t + (dt*1000)/PORTRAITS.slideMs);
const k = _ease(node.t);
const kA = Math.min(1, _ease(node.t * 1.12)); // alpha ~12% más rápida
node.x = node.from + (node.to - node.from) * k;
node.alpha = node.aFrom + (node.aTo - node.aFrom) * kA;
    node.scaleTemp = (node.sFrom ?? 1) + ((node.sTo ?? 1) - (node.sFrom ?? 1)) * k;


    if (node.t>=1){
      node.anim = false;
      node.x = node.to;
      node.alpha = node.aTo;
      if (node.onDone){ const cb = node.onDone; node.onDone=null; cb(); }
    }
  };

  upd(PORTRAITS.left);
  upd(PORTRAITS.right);
}
// ——— BLUR SUPPORT + FALLBACK ———
function supportsCanvasFilter(){
  // algunos navegadores exponen ctx.filter pero lo ignoran; probamos con un draw mínimo
  try{
    const c = document.createElement('canvas');
    c.width = c.height = 2;
    const x = c.getContext('2d');
    x.fillStyle = '#fff'; x.fillRect(0,0,2,2);
    x.filter = 'blur(1px)';
    x.drawImage(c,0,0);
    return typeof x.filter === 'string';
  }catch(e){ return false; }
}

// buffer para blur barato
const _BLURBUF = document.createElement('canvas');
const _BLURCTX = _BLURBUF.getContext('2d');

// “barato”: baja resolución y la vuelves a subir para simular blur
function drawBlurFallback(srcCanvas, dstCtx, clipRect){
  const w = srcCanvas.width, h = srcCanvas.height;

  // tamaño de reducción: cuanto menor, más blur
  const scale = 0.15; // 15% → blur potente
  const tw = Math.max(2, (w*scale)|0);
  const th = Math.max(2, (h*scale)|0);

  _BLURBUF.width = tw; _BLURBUF.height = th;

  // 1) baja
  _BLURCTX.imageSmoothingEnabled = true;
  _BLURCTX.clearRect(0,0,tw,th);
  _BLURCTX.drawImage(srcCanvas, 0,0, w,h, 0,0, tw,th);

  // 2) sube (ya “lavado”)
  dstCtx.save();
  dstCtx.beginPath();
  dstCtx.rect(clipRect.dx, clipRect.dy, clipRect.dw, clipRect.dh);
  dstCtx.clip();
  dstCtx.globalCompositeOperation = 'source-over';
  dstCtx.globalAlpha = 1; // cubre totalmente lo nítido
  dstCtx.drawImage(_BLURBUF, 0,0, tw,th, 0,0, w,h);
  dstCtx.restore();
}

  
function portraitsDrawOverlay(){
  if (!PORTRAITS.active) return;

  if (BACKBUF.width !== canvas.width || BACKBUF.height !== canvas.height){
    BACKBUF.width = canvas.width; BACKBUF.height = canvas.height;
  }

  // --- blur del fondo dentro del rectángulo de juego ---
  BACKCTX.clearRect(0, 0, BACKBUF.width, BACKBUF.height);
  BACKCTX.drawImage(canvas, 0, 0);
  const blurPx = Math.round((PORTRAITS.blurPx || 100) * (PORTRAITS.blurK || 0));

    if (supportsCanvasFilter() && !PORTRAITS.forceBlurFallback){
    ctx.save();
    ctx.beginPath();
    ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
    ctx.clip();
    ctx.filter = `blur(${blurPx}px)`;
    ctx.drawImage(BACKBUF, 0, 0);
    ctx.filter = 'none';
    ctx.restore();
  } else {
    // ← fallback robusto que ya tienes implementado
    drawBlurFallback(BACKBUF, ctx, screenRect);
  }


  const drawSide = (N)=>{
    if (!N?.img) return;
    const s = N.scaleTemp ?? 1;
    const w = Math.round(N.w * s);
    const h = Math.round(N.h * s);
    const x = Math.round(N.x);
    const y = Math.round(N.yBottom - h);

    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, N.alpha ?? 1));
    if (N.flipX){
      ctx.translate(x + w/2, y);
      ctx.scale(-1, 1);
      ctx.drawImage(N.img, 0, 0, N.img.naturalWidth, N.img.naturalHeight, -w/2, 0, w, h);
    } else {
      ctx.drawImage(N.img, 0, 0, N.img.naturalWidth, N.img.naturalHeight, x, y, w, h);
    }
    ctx.restore();
  };

  drawSide(PORTRAITS.left);
  drawSide(PORTRAITS.right);
}



// ************************** FUNCIONES SMOKE

  function smokeRand(){
  SMOKE.seed = (SMOKE.seed * 1664525 + 1013904223) | 0;
  return ((SMOKE.seed >>> 0) / 4294967296);
}
function smokeStart(anchor){
  SMOKE.anchor = anchor ? {x:anchor.x, y:anchor.y} : null;
  SMOKE.parts.length = 0;
  SMOKE.active = !!SMOKE.anchor;
}
function spawnSmokeParticle(side = (Math.random()<0.5?'L':'R')){
  if (!SMOKE.anchor) return;
  const fromLeft = side === 'L';
  const halfW = SMOKE.areaW * 0.5;
  const halfH = SMOKE.areaH * 0.5;

  const x = fromLeft ? (SMOKE.anchor.x - halfW - 30) : (SMOKE.anchor.x + halfW + 30);
  const y = (SMOKE.anchor.y - halfH) + smokeRand() * (SMOKE.areaH);

  // centro de fuerzas = la propia ancla (ligeramente alto)
  const cx = SMOKE.anchor.x;
  const cy = SMOKE.anchor.y - halfH * 0.2;

  const r = 14 + smokeRand()*18;
  const life = 5.5 + smokeRand()*2.0;
  const alpha0 = SMOKE.baseAlpha * (0.9 + 0.25*smokeRand());

  const dir = fromLeft ? 1 : -1;
  const vx0 = ((cx - x) * 0.1 + 4*dir) / life;
  const vy0 = ((cy - y) * 0.08 + (smokeRand()-0.5)*4) / life;

  SMOKE.parts.push({
    x, y, r, life, age:0, alpha0, vx:vx0, vy:vy0,
    side: dir, phase: smokeRand()*Math.PI*2
  });
}
function smokeUpdate(dt){
  if (!SMOKE.active || !SMOKE.anchor) return;

  // emitir
  const want = SMOKE.targetDensity * dt;
  const toSpawn = Math.floor(want);
  for (let i=0;i<toSpawn;i++) spawnSmokeParticle(i%2===0?'L':'R');

  const cx = SMOKE.anchor.x;
  const cy = SMOKE.anchor.y - SMOKE.areaH*0.2;
  const yMin = SMOKE.anchor.y - SMOKE.areaH*0.5;
  const yMax = SMOKE.anchor.y + SMOKE.areaH*0.5;

  for (let i=SMOKE.parts.length-1; i>=0; i--){
    const p = SMOKE.parts[i];
    p.age += dt;
    if (p.age >= p.life){ SMOKE.parts.splice(i,1); continue; }

    const dx = cx - p.x, dy = cy - p.y;
    const len = Math.hypot(dx,dy) || 1;
    const ux = dx/len,  uy = dy/len;
    const tx = -uy,     ty = ux;

    // fuerzas
    const ax = ux*SMOKE.attract + tx*SMOKE.swirl*p.side;
    const ay = uy*SMOKE.attract + ty*SMOKE.swirl*p.side;

    // jitter
    const j = Math.sin(p.phase + p.age*SMOKE.jitterFreq*2*Math.PI) * SMOKE.jitterAmp;
    const jx = -uy * j * 0.18;
    const jy =  ux * j * 0.18;

    p.vx = p.vx*0.965 + (ax*0.035);
    p.vy = p.vy*0.965 + (ay*0.035);

    p.x += (p.vx + jx) * dt * 10;
    p.y += (p.vy + jy) * dt * 10;

    // mantener banda vertical
    if (p.y > yMax) p.vy -= 10 * dt;
    if (p.y < yMin) p.vy +=  8 * dt;
  }
}
function smokeDraw(){
  if (!SMOKE.active || !SMOKE.parts.length) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  ctx.globalCompositeOperation = 'screen';
  for (const p of SMOKE.parts){
    const k = p.age / p.life;
    const fade = (k<0.25) ? (k/0.25) : (k>0.85 ? (1-(k-0.85)/0.15) : 1);
    const alpha = p.alpha0 * fade;
    if (alpha <= 0.002) continue;

    // mundo -> pantalla
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
    const pr = p.r * Math.max(mapScaleX, mapScaleY);

    const g = ctx.createRadialGradient(px, py, 0, px, py, pr);
    g.addColorStop(0.00, `rgba(${SMOKE.color}, ${alpha})`);
    g.addColorStop(0.65, `rgba(${SMOKE.color}, ${alpha*0.6})`);
    g.addColorStop(1.00,  `rgba(${SMOKE.color}, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

  // -------------------- FUNCIONES NIEBLA
function fogUseWorld(anchor){
  FOG.space = 'world';
  FOG.anchorWorld = anchor || { x: player.x, y: player.y - 40 };
}

function fogUseScreen(){
  FOG.space = 'screen';
  FOG.anchorWorld = null;
}

  function fogAimAhead(on=true){ FOG._aimAhead = !!on; }
function fogResetAim(){ FOG._aimAhead = false; }
  
  function fogRand(){
  FOG.seed = (FOG.seed * 1664525 + 1013904223) | 0;
  return ((FOG.seed >>> 0) / 4294967296);
}
function smoothstep(a,b,x){ x = Math.max(0, Math.min(1,(x-a)/(b-a))); return x*x*(3-2*x); }

function fogStart(){
  FOG.active = true;
  FOG.parts.length = 0;
}

function fogStop(){
  FOG.active=false;
  FOG.parts.length=0;
  FOG.filling=false; FOG.tFill=0;
}

function fogBeginFill(opts = FOG.fillDur){
  // Compatibilidad: si te pasan un número, es la duración
  if (typeof opts === 'number'){
    FOG.fillDur = opts;
  } else if (opts && typeof opts === 'object'){
    FOG.fillDur = opts.dur ?? FOG.fillDur;
    // ancla opcional (en coordenadas de pantalla porque las partículas son "screen-space")
    if (opts.anchor){
      // anchor {x,y} en pantalla
      FOG.anchor = { x: opts.anchor.x, y: opts.anchor.y };
    } else {
      // por defecto, ancla al centro-alto de la pantalla útil
      FOG.anchor = {
        x: screenRect.dx + screenRect.dw * 0.5,
        y: screenRect.dy + screenRect.dh * 0.25
      };
    }
    // ancho/alto del área del velo
    if (opts.areaW) FOG.areaW = opts.areaW;
    if (opts.areaH) FOG.areaH = opts.areaH;
    // densidad "lógica" (escala la targetDensity si quieres)
    if (opts.density != null){
      // ejemplo: 1.0 = igual, 0.5 = mitad, 2.0 = doble
      FOG._densityScale = opts.density;
    }
  }

  FOG.filling = true;
  FOG.tFill   = 0;
  if (!FOG.active) fogStart();
}

function spawnFogParticle(side){
  const fromLeft = side === 'L';
  const dir = fromLeft ? 1 : -1;

  let yMin, yMax, x, cx, cy;

  if (FOG.space === 'world' && FOG.anchorWorld){
    // --- WORLD SPACE: emitir alrededor del anchorWorld y no de la cámara ---
    const halfW = (FOG.areaW || 360) * 0.5;
    const halfH = (FOG.areaH || 140) * 0.5;

    // banda vertical centrada en el anchorWorld (puedes estrechar si quieres)
    yMin = FOG.anchorWorld.y - halfH;
    yMax = FOG.anchorWorld.y + halfH;

    // emite a izquierda/derecha del área (en mundo)
    x = fromLeft ? (FOG.anchorWorld.x - halfW - 40) : (FOG.anchorWorld.x + halfW + 40);

    // “atractor” = el propio anchorWorld (desplazable con aheadBias si quieres)
    cx = FOG.anchorWorld.x;
    cy = FOG.anchorWorld.y - (FOG.aheadBias||0) * halfH; // empuja un poco hacia arriba

  } else {
    // --- SCREEN SPACE (como antes) ---
    const tTop    = FOG._aimAhead ? 0.00 : FOG.bandTop;
    const tBottom = FOG._aimAhead ? 0.38 : FOG.bandBottom;
    yMin = screenRect.dy + screenRect.dh * tTop;
    yMax = screenRect.dy + screenRect.dh * tBottom;

    x = fromLeft ? screenRect.dx - 60 : screenRect.dx + screenRect.dw + 60;

    cx = screenRect.dx + screenRect.dw*0.5;
    const baseCy = 0.42;
    cy = screenRect.dy + screenRect.dh * (FOG._aimAhead ? (baseCy - FOG.aheadBias) : baseCy);
  }

  const y = yMin + (yMax - yMin) * fogRand();

  const r = 16 + fogRand()*24;
  const life = 4.8 + fogRand()*1.6;
  const alpha0 = FOG.baseAlpha * (0.9 + 0.25*fogRand());

  // velocidades suaves hacia el centro
  const vx0 = ((cx - x) * 0.10 + 6*dir) / life;
  const vy0 = ((cy - y) * 0.08 + (fogRand()-0.5)*6) / life;

  // Guarda SIEMPRE las coords en MUNDO; si estás en screen-space, las convertimos en draw()
  FOG.parts.push({
    x: (FOG.space==='world') ? x : (cam.x + (x - screenRect.dx)/mapScaleX),
    y: (FOG.space==='world') ? y : (cam.y + (y - screenRect.dy)/mapScaleY),
    r, life, age:0, alpha0, vx:vx0, vy:vy0, phase: fogRand()*Math.PI*2, side: dir
  });
}


function fogUpdate(dt){
  if (!FOG.active) return;

  let spawnScale = 1;
  if (FOG.filling){
    FOG.tFill = Math.min(FOG.fillDur, FOG.tFill + dt*1000);
    const t = FOG.tFill / FOG.fillDur;
    spawnScale = smoothstep(0.0, 1.0, t);
    if (t>=1) FOG.filling = false;
  }
  const spawnRate = FOG.targetDensity * (FOG._densityScale || 1) * spawnScale;

  // emitir alternando lados
  const want = spawnRate * dt;
  const toSpawn = Math.floor(want);
  for (let i=0; i<toSpawn; i++) spawnFogParticle(i%2===0?'L':'R');

  // centro de fuerzas en MUNDO
  let cx, cy, yMin, yMax;
  if (FOG.space==='world' && FOG.anchorWorld){
    cx = FOG.anchorWorld.x;
    const halfH = (FOG.areaH || 140)*0.5;
    cy = FOG.anchorWorld.y - (FOG.aheadBias||0)*halfH;
    yMin = FOG.anchorWorld.y - halfH;
    yMax = FOG.anchorWorld.y + halfH;
  } else {
    cx = cam.x + cam.w*0.5;
    const baseCy = 0.42;
    cy = cam.y + cam.h * (FOG._aimAhead ? (baseCy - FOG.aheadBias) : baseCy);
    yMin = cam.y + cam.h * (FOG._aimAhead ? 0.00 : FOG.bandTop);
    yMax = cam.y + cam.h * (FOG._aimAhead ? 0.38 : FOG.bandBottom);
  }

  for (let i=FOG.parts.length-1;i>=0;i--){
    const p = FOG.parts[i];
    p.age += dt;
    if (p.age >= p.life){ FOG.parts.splice(i,1); continue; }

    // fuerzas
    const dx = cx - p.x, dy = cy - p.y;
    const len = Math.hypot(dx,dy) || 0.0001;
    const ux = dx/len,    uy = dy/len;
    const tx = -uy,       ty = ux;

    const ax = ux*FOG.attract + tx*FOG.swirl*p.side;
    const ay = uy*FOG.attract + ty*FOG.swirl*p.side;

    const j = Math.sin(p.phase + p.age*FOG.jitterFreq*2*Math.PI) * FOG.jitterAmp;
    const jx = -uy * j * 0.18;
    const jy =  ux * j * 0.18;

    p.vx = p.vx*0.965 + (ax*0.035);
    p.vy = p.vy*0.965 + (ay*0.035);

    p.x += (p.vx + jx) * dt * 10;
    p.y += (p.vy + jy) * dt * 10;

    // mantener banda
    if (p.y > yMax) p.vy -= 12 * dt;
    if (p.y < yMin) p.vy +=  8 * dt;
  }
}

function fogDraw(){
  if (!FOG.active || !FOG.parts.length) return;

  // centro de fuerzas en mundo (sólo para el bias de gradiente)
  const cx = (FOG.space==='world' && FOG.anchorWorld) ? FOG.anchorWorld.x : (cam.x + cam.w*0.5);
  const cy = (FOG.space==='world' && FOG.anchorWorld)
              ? (FOG.anchorWorld.y - (FOG.aheadBias||0)*( (FOG.areaH||140)*0.5 ))
              : (cam.y + cam.h*0.42);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  for (const p of FOG.parts){
    const k = p.age / p.life;
    const fade = (k<0.2) ? smoothstep(0,0.2,k) :
                 (k>0.8) ? (1 - smoothstep(0.8,1,k)) : 1;

    const alpha = p.alpha0 * fade;
    if (alpha <= 0.002) continue;

    // proyección mundo -> pantalla
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
    const pr = p.r * Math.max(mapScaleX, mapScaleY);

    // foco desplazado (engorda hacia fuera)
    const vx = p.x - cx, vy = p.y - cy;
    const len = Math.hypot(vx,vy) || 1;
    const nx = vx / len, ny = vy / len;
    const bias = FOG.oneSideBias || 0;
    const fx = px - nx * pr * bias;
    const fy = py - ny * pr * bias;

    const g = ctx.createRadialGradient(fx, fy, 0, px, py, pr);
    g.addColorStop(0.00, `rgba(${FOG.color}, ${alpha})`);
    g.addColorStop(0.65, `rgba(${FOG.color}, ${alpha*0.7})`);
    g.addColorStop(1.00, `rgba(${FOG.color}, 0)`);

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();
}




/* ========== LAYOUT / CÁMARA ========== */
function resize(){
  const sc=document.querySelector('.screen');
  canvas.width=sc.clientWidth; canvas.height=sc.clientHeight;
  const k=Math.min(canvas.width/ROOM.w, canvas.height/ROOM.h);
  screenRect.dw=ROOM.w*k; screenRect.dh=ROOM.h*k;
  screenRect.dx=(canvas.width-screenRect.dw)/2;
  screenRect.dy=(canvas.height-screenRect.dh)/2;
  cam.w=Math.max(64,Math.round(ROOM.w/ZOOM));
  cam.h=Math.max(64,Math.round(ROOM.h/ZOOM));
  mapScaleX=screenRect.dw/cam.w; mapScaleY=screenRect.dh/cam.h;
  cam.x=clamp(cam.x,0,world.w-cam.w); cam.y=clamp(cam.y,0,world.h-cam.h);
  BACKBUF.width = canvas.width; BACKBUF.height = canvas.height;
}
addEventListener('resize',resize);
function centerCameraOnPlayer(){
  cam.x=clamp(player.x-cam.w/2,0,world.w-cam.w);
  cam.y=clamp(player.y-cam.h/2,0,world.h-cam.h);
}

  function cameraPanTo(x, y, ms=1200){
  CAM_TWEEN.on = true; CAM_TWEEN.t = 0; CAM_TWEEN.dur = ms;
  CAM_TWEEN.sx = cam.x; CAM_TWEEN.sy = cam.y;
  CAM_TWEEN.ex = clamp(x, 0, world.w - cam.w);
  CAM_TWEEN.ey = clamp(y, 0, world.h - cam.h);
}


/* ========== COLISIÓN ========== */
function ellipseRectOverlap(cx, cy, rx, ry, rect){
  const qx = clamp(cx, rect.x, rect.x + rect.w);
  const qy = clamp(cy, rect.y, rect.y + rect.h);
  const dx = (cx - qx) / rx;
  const dy = (cy - qy) / ry;
  return (dx*dx + dy*dy) <= 1;
}
function anyOverlap(cx, cy){
  for(const ob of OBSTACLES) if(ellipseRectOverlap(cx, cy + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) return true;
  return false;
}

/* ========== PROPS / OBSTÁCULOS ========== */
function getInteractHit(){
  for (const pr of PROPS){
    if(!pr.interacts) continue;
    for (const zone of pr.interacts){
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
        return zone; // devolvemos la zona encontrada
      }
    }
  }
  return null;
}

  function getNPCInteractHit(){
  for (const npc of NPCS){
    if (!npc.interacts) continue;
    for (const zone of npc.interacts){
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
        return zone; // trae .dialog si existe
      }
    }
  }
  return null;
}


async function preloadCatalog(){
  const entries=Object.entries(CATALOG);
  const res=await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  res.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}
function buildPropsAndObstacles(){
  PROPS=[]; OBSTACLES=[];
  for(const [type,list] of Object.entries(PLACED)){
    const spec=CATALOG[type]; const img=PROP_IMAGES[type];
    if(!spec || !list?.length) continue;
    for (const p of list) {
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x: p.x, y: p.y };
      const prop = { type, img, x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth : 32, ih: img ? img.naturalHeight : 32, scale: spec.scale || 1 };
      if (spec.collider){
        const c = spec.collider, s = prop.scale;
        const col = { x: prop.x + c.x*s, y: prop.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
        prop.collider = col; OBSTACLES.push({ ...col, name: type });
      }
      const s = prop.scale;
      const srcInteract = p.interact ?? spec.interact ?? null;

if (srcInteract){
  const inters = Array.isArray(srcInteract) ? srcInteract : [srcInteract];
  prop.interacts = inters.map(i => ({
    x: prop.x + i.x*s,
    y: prop.y + (i.y*s) - (i.h*s),
    w: i.w*s,
    h: i.h*s,
    say: (typeof i.say === 'string' ? i.say : (typeof p.say === 'string' ? p.say : null))
  }));
}

      if (typeof p.say === 'string') prop.say = p.say;

      PROPS.push(prop);
    }
  }
  for(const o of OBSTACLE_DEFS){
    const r=(o.type==='percent') ? { ...percentToWorld(o), w:Math.round(world.w*(o.w/100)), h:Math.round(world.h*(o.h/100)) } : o;
    OBSTACLES.push({x:r.x,y:r.y,w:r.w,h:r.h,name:o.name||'extra'});
  }
}


/* ========== AMBIENTE: zonas + overlay ========== */
function buildAmbientZones(){
  const out=[];
  for (const z of AMBIENT_ZONES){
    if (z.rect?.type==='percent'){
      out.push({
        ...z,
        x: Math.round(world.w*(z.rect.x/100)),
        y: Math.round(world.h*(z.rect.y/100)),
        w: Math.round(world.w*(z.rect.w/100)),
        h: Math.round(world.h*(z.rect.h/100)),
      });
    } else out.push({...z, x:z.rect.x, y:z.rect.y, w:z.rect.w, h:z.rect.h});
  }
  return out;
}
function feetWorld(){ return { x: player.x, y: player.y + FEET_OFFSET_Y }; }
function pointInRect(px,py,r){return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;}

/* === LINTERNA: helpers + draw === */
function dirToAngle(dir){
  switch(dir){
    case 'up': return -Math.PI/2;
    case 'down': return  Math.PI/2;
    case 'left': return  Math.PI;
    case 'right': return  0;
    default: return 0;
  }
}

function drawFlashlightEnhance(){
  if (!LIGHT.enabled) return;

  // tamaño y posición del jugador en pantalla
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);

  const t = performance.now() * 0.003;
  const flick = 1 + (Math.sin(t*2.3)+Math.sin(t*1.7))*0.5*LIGHT.flicker;

  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = LIGHT.brightness;

  // halo circular
  if (LIGHT.mode === 'circle' || LIGHT.mode === 'both'){
    const baseR = LIGHT.radius * Math.max(mapScaleX, mapScaleY);
    const R = baseR * flick;
    const inner = R * (1 - LIGHT.feather);
    const g = ctx.createRadialGradient(jx, jy, inner, jx, jy, R);
    g.addColorStop(0.00, `rgba(${LIGHT.tint}, 0.95)`);
    g.addColorStop(0.50, `rgba(${LIGHT.tint}, 0.35)`);
    g.addColorStop(1.00,  'rgba(255,255,255, 0.00)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(jx, jy, R, 0, Math.PI*2); ctx.fill();
  }

  // haz cónico
  if (LIGHT.mode === 'cone' || LIGHT.mode === 'both'){
    const ang = dirToAngle(player.dir);
    const len = LIGHT.coneLen * Math.max(mapScaleX, mapScaleY);
    const half = LIGHT.coneWidth * 0.5;

    ctx.save();
    ctx.translate(jx, jy);
    ctx.rotate(ang);

    const lg = ctx.createLinearGradient(0, 0, len, 0);
    lg.addColorStop(0.00, `rgba(${LIGHT.tint}, 0.70)`);
    lg.addColorStop(0.25, `rgba(${LIGHT.tint}, 0.38)`);
    lg.addColorStop(1.00,  'rgba(255,255,255, 0.00)');
    ctx.fillStyle = lg;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(len,  Math.tan(half)*len);
    ctx.lineTo(len, -Math.tan(half)*len);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  ctx.restore();
}

/* Gradientes por paleta */
function makePaletteGradient(palette){
  const g = ctx.createLinearGradient(screenRect.dx, screenRect.dy, screenRect.dx, screenRect.dy + screenRect.dh);
  if (palette === 'bluehour'){
    g.addColorStop(0.00, '#0A516B');
    g.addColorStop(0.50, '#164D8C');
    g.addColorStop(1.00, '#0C3F62');
    return { gradient:g, mode:'multiply', alpha:0.85 };
  }
  if (palette === 'hell'){
    // Evitamos rojo puro con multiply (apagaba todo). Usamos screen y tonos cálidos.
    g.addColorStop(0.00, '#EB9460');
    g.addColorStop(0.55, '#DF5800');
    g.addColorStop(1.00, '#DF5800');
    return { gradient:g, mode:'multiply', alpha:0.45 };
  }
  // peach (base)
  g.addColorStop(0.00, '#FB557C');
  g.addColorStop(0.55, '#FB557C');
  g.addColorStop(1.00, '#DF5800');
  return { gradient:g, mode:'multiply', alpha:0.65 };
}

function drawPalette(palette, alphaScale){
  if (alphaScale <= 0) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  const { gradient, mode, alpha } = makePaletteGradient(palette);
  ctx.globalCompositeOperation = mode;
  ctx.globalAlpha = Math.min(1, alpha * alphaScale);
  ctx.fillStyle = gradient;
  ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  ctx.restore();
}

  // ========== CINEMÁTICA 1 ==========
function startCinematic1(){
  CUT.active = true; CUT.id='cine1'; CUT.phase='lock';
  ambientLock = true; player.moving=false;

  // F1: bloquea y muestra "¿Qué pasa?"
  setTimeout(() => {
    openDialog([{speaker:'Juan', text:'...'},{speaker:'Juan', text:'Algo pasa...'}], true);
  }, 1000);
  

  // Acción → cerrar y pasar a F2 (niebla)
  CUT.hijackAction = ()=>{
    closeCurrentDialogNow();
    CUT.hijackAction = null;
     setTimeout(()=>{
    if (CUT.active && CUT.id==='cine1'){ 
      phaseFogFill();
    }
  }, 1000);
};
  }
function phaseQuestionThenWalk(){
  CUT.phase = 'question';
  openDialog([{ speaker:'Juan', text:'...?' }], true);

  // Acción: cerrar "?" y arrancar caminata YA
  CUT.hijackAction = ()=>{
    if (dialogOpen) closeDialog();
    CUT.hijackAction = null;
    phaseJuanAutoWalk();   // ← empieza a caminar al instante
  };
}

  
function phaseFogFill(){
  CUT.phase='fogFill';

  const g = NPCS.find(n => n.id === 'gandalf_temp');
  const anchorWorld = g
    ? { x: g.x, y: g.y - 45 }
    : { x: player.x, y: cam.y + cam.h*0.25 };  // coords de mundo

  fogUseWorld(anchorWorld);   // <<<<< NIEBLA EN MUNDO (no se mueve con cámara)

  fogBeginFill({
    dur: 3000,
    areaW: 360,
    areaH: 140,
    density: 1.0
  });

  const check = ()=>{
  if (FOG.filling){
    requestAnimationFrame(check);
  } else {
    // Espera 1s antes del paneo
    CUT.phase = 'prePanDelay';
    setTimeout(()=>{
      if (CUT.active && CUT.id==='cine1'){  // por si se canceló la cine
        phaseCameraPan();
      }
    }, 3700);
  }
};
requestAnimationFrame(check);
}



function phaseCameraPan(){
  CUT.phase='pan';
  const targetY = clamp(cam.y - 70, 0, world.h - cam.h);
  

  cameraPanTo(cam.x, targetY, 1200);
  spawnTempGandalfAhead(targetY);

  const waitPan = setInterval(()=>{
    if (!CAM_TWEEN.on){
      clearInterval(waitPan);

      CUT.phase = 'preWalkDialog';
      phaseQuestionThenWalk();
    }
  }, 16);
}


function spawnTempGandalfAhead(targetCamY){
  const gx = player.x;
  const gy = targetCamY + cam.h/2 - 35; // más cerca del centro → seguro en pantalla
  const iw = IMG_GANDALF_SMALL ? IMG_GANDALF_SMALL.naturalWidth  : 32;
  const ih = IMG_GANDALF_SMALL ? IMG_GANDALF_SMALL.naturalHeight : 32;

  const npc = {
    id:'gandalf_temp', type:'gandalf_temp', img: IMG_GANDALF_SMALL,
    x: gx, y: gy, iw, ih,
    scale: 0.5,                   // más visible
    depthBand: DEPTH_BAND, depthAnchorY: 1,
    _debug: true                // flag para overlay de depuración
  };

  NPCS.push(npc);
}



  function phaseJuanAutoWalk(){
  CUT.phase='autowalk';
  const targetY = cam.y + cam.h/2;
  const startY  = player.y;
  const dy = targetY - startY;
  CUT.autoDir = (dy >= 0) ? 'down' : 'up';
  const dur = Math.max(400, Math.min(1200, Math.abs(dy)*16));
  const t0  = performance.now();

  (function step(){
    if (!CUT.active || CUT.id!=='cine1') return;
    const t = Math.min(1, (performance.now()-t0)/dur);
    player.y = startY + dy*t;
    if (t<1) requestAnimationFrame(step);
    else phaseWorldDialogue();
  })();
}


  function phaseWorldDialogue(){
  CUT.phase='worldTalk';
  const script = [
    {speaker:'???',  text:'Hola, muchacho...'},
    {speaker:'Juan', text:'¡Yias! Pero si tu eres...'},
    {speaker:'???', text:'En efecto.'}
  ];
  // Abre TODAS las líneas
  openDialog(script, true);

  onDialogClosed = ()=>{
    CUT.hijackAction = null;
    phasePortraits();
  };

  // mientras esté abierto, el botón Acción sólo avanza
  CUT.hijackAction = ()=>{
    if (dialogOpen){
      advanceDialog();
    }
  };
}


  function phasePortraits(){
  CUT.phase='cineOverlay';
  const cineScript = [
    { speaker:'Gandalf', text:'Gandalf el Gris.' },
    { speaker:'Juan',    text:'Wow.' }
  ];
  portraitsOpen(cineScript);
  CUT.onEnd = ()=>{ fadeOutFogThenEnd(); }; // lo que ya tenías
}

  function fadeOutFogThenEnd(){
  CUT.phase='fadeFog';
  let t0 = performance.now(), dur=800;
  function tick(){
    if (!CUT.active || CUT.id!=='cine1') return;
    const k = Math.min(1, (performance.now()-t0)/dur);

    // ✅ usar tFill (existe), no fillT
    FOG.tFill = (1 - k) * FOG.tFill;

    for (const p of FOG.parts) {}
    if (k<1) requestAnimationFrame(tick);
    else {
      fogStop();
      const i = NPCS.findIndex(n=>n.id==='gandalf_temp');
      if (i>=0) NPCS.splice(i,1);
      endCine();
    }
  }
  requestAnimationFrame(tick);
}


  function endCine(){
    CUT.active=false; CUT.id=null; CUT.phase=null; CUT.hijackAction=null; CUT.onEnd=null;
    ambientLock=false;
    fogResetAim();   
    fogUseScreen();   // vuelve al modo normal si lo quieres así tras la cine

  }

// **************************** CINEMATICA 3

// === Helpers globales para la cine 3 ===
async function applyOtherJuanSSJ({boostHalo=true} = {}){
  const other = NPCS.find(n => n.id === 'juansin_other');
  if(!other) return null;
  const img = await loadImage('assets/npcs/juan_ssj.png');
  if (img){
    other.img = img;
    other.iw  = img.naturalWidth  || other.iw;
    other.ih  = img.naturalHeight || other.ih;
  }
  if (boostHalo){
    other.halo = { color:'255,255,160', radius:38, alpha:0.8, pulse:0.08, offsetY:0.62 };
    other._fxActive = true;
    other._fxUntil  = performance.now() + 600;
  }
  GAME_FLAGS.juansin_other_halo = true;
  return other;
}

function cineAutoWalkTo(targetX, targetY, ms, onDone, { followCam = false } = {}){
  CUT.phase = 'autowalk';
  const sx = player.x, sy = player.y;
  const t0 = performance.now();
  const dur = Math.max(200, ms|0);

  const face = ()=>{
    const dx = targetX - player.x, dy = targetY - player.y;
    player.dir = Math.abs(dx) > Math.abs(dy) ? (dx < 0 ? 'left' : 'right') : (dy < 0 ? 'up' : 'down');
  };

  (function step(){
    const k = Math.min(1, (performance.now() - t0) / dur);
    player.x = sx + (targetX - sx) * k;
    player.y = sy + (targetY - sy) * k;
    face();

    // animación de caminar
    player.moving = true;
    player.frameTime += 1/60;
    if (player.frameTime >= 0.12){ player.frame = (player.frame + 1) % 2; player.frameTime = 0; }

    // 👇 hace que la cámara siga a Juan durante este autowalk
    if (followCam) centerCameraOnPlayer();

    if (k < 1){
      requestAnimationFrame(step);
    } else {
      player.moving = false;
      player.frame = 0;          // frame base de idle
      player.frameTime = 0;      // reset del tiempo de animación
      if (typeof onDone === 'function') onDone();
    }
  })();
}



async function startCinematic3(){
  CUT.active = true; CUT.id='cine3'; CUT.phase='start';
  ambientLock = true; player.moving = false;

  setTimeout(() => {
    // 1) Diálogo doble: "...?" -> "¿Ese soy yo?"
    openDialog([
      { speaker:'Juan', text:'...?' },
      { speaker:'Juan', text:'¿Ese soy yo?' }
    ], true);

    CUT.hijackAction = () => {
      if (!dialogOpen) return;

      // Si aún está escribiendo, completa
      if (isTyping){ advanceDialog(); return; }

      // Si estamos en la primera línea, avanzamos a la segunda
      if (dialogIndex < dialogScript.length - 1){
        advanceDialog();
        return;
      }

      // 2) Aquí estamos en la segunda línea y se pulsa Acción para cerrar:
      //    cerrar, cambiar a SSJ (PNG + destello) y NO caminar todavía
      closeDialog();
      CUT.hijackAction = null;

      (async () => {
        const other = await applyOtherJuanSSJ({ boostHalo: true });

        // 3) Espera 1s y muestra "Ah, pues no."
        setTimeout(() => {
          openDialog([{ speaker:'Juan', text:'Ah, pues no.' }], true);

          CUT.hijackAction = () => {
            if (!dialogOpen) return;
            // cerrar "Ah, pues no." y entonces caminar
            closeDialog();
            CUT.hijackAction = null;

            // 4) Autowalk hasta delante del SSJ, quedarse en idle up
            const offset  = 22;
            // 4) Caminata en dos tramos: primero a la X del SSJ, luego subir hasta y = SSJ.y - 20
const targetX1 = other.x;        // alinearse a la X del SSJ
const targetY1 = player.y;       // misma Y actual

cineAutoWalkTo(targetX1, targetY1, 500, () => {
  const targetX2 = other.x;      // mantiene X del SSJ
  const targetY2 = other.y + 30; // parar 20px por encima del SSJ
  cineAutoWalkTo(targetX2, targetY2, 700, () => {
    CUT.phase = 'idle'; 
    player.dir = 'up';
player.moving = false;
player.frame = 0;      // idle total
player.frameTime = 0;


  setTimeout(() => {
  openDialog([{ speaker:'Juan Super Saiyan Legendario', text:'Grr' }], true);

  CUT.hijackAction = () => {
    if (dialogOpen){
      closeDialog();
      CUT.hijackAction = null;
      cine3_beginPortraits();
    }
  };
}, 2000);

  }, { followCam:true });
}, { followCam:true });

          };
        }, 1000);
      })();
    };
  }, 1000);
}


function cine3_beginPortraits(){
  // Activa layout en bandas negras
  PORTRAITS.layout = 'letterbox';
  PORTRAITS.forceBlurFallback = !supportsCanvasFilter();

  PORTRAITS.active = true;
  PORTRAITS.blurK = 0;
  PORTRAITS.forceBlurFallback = false;
  PORTRAITS.stage = 'entering';

  // Construidos en letterbox: SSJ arriba, Juan abajo
  PORTRAITS.left  = _makeSide(IMG_JUAN_SSJ || IMG_JUAN_BIG, 'left',  'SSJ',  'top');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG,                  'right', 'Juan', 'bottom');

  PORTRAITS.left.flipX = true;

  // Parten fuera
  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  // Barras de vida
  HPBARS.show(10, 100);

  // Entra primero SSJ por la izquierda
  _startSlide(PORTRAITS.left, PORTRAITS.left.inX, ()=>{
    // >>> Espera 1 segundo antes del ataque <<<
    setTimeout(()=>{
      // dash in + back (ataque)
      cine3_attackSequence(()=>{
        // sale SSJ y entra Juan
        _startSlide(PORTRAITS.left, PORTRAITS.left.outX, ()=>{
          _startSlide(PORTRAITS.right, PORTRAITS.right.inX, ()=>{
            // >>> Espera 1 segundo antes de "recibir el golpe" <<<
            setTimeout(()=>{
              cine3_hitReaction(PORTRAITS.right);
              HPBARS.setTargets(1, 100);
              cine3_openNarrator();
            }, 1000);
          });
        });
      });
    }, 1000);
  });

  // Durante esta coreografía el botón acción no hace nada
  CUT.hijackAction = null;
}



function cine3_attackSequence(done){
  // Dash de SSJ hacia el centro y atrás
  const L = PORTRAITS.left;
  const mid = L.inX + Math.round(screenRect.dw*0.04);
  const back = L.inX;
  // dash in
  L.sFrom=1.00; L.sTo=1.06;
  _startSlide(L, mid, ()=>{
    // y vuelve al sitio
    L.sFrom=1.06; L.sTo=1.00;
    _startSlide(L, back, ()=>{ if (typeof done==='function') done(); });
  });
}

function cine3_hitReaction(node){
  // pequeño temblor/retroceso
  const orig = node.inX;
  const kick = orig + Math.round(screenRect.dw*0.02);
  node.sFrom=1.00; node.sTo=0.96;
  _startSlide(node, kick, ()=>{
    node.sFrom=0.96; node.sTo=1.00;
    _startSlide(node, orig, null);
  });
}

function cine3_openNarrator(){
  openDialog([
    {speaker:'', text:'Juan Super Saiyan Legendario te ataca con una bola de energía.' }
  ], true);

  CUT.hijackAction = ()=>{
    if (isTyping){ advanceDialog(); return; }
    if (dialogOpen){
      // mostrar segunda línea
      closeDialog();
      openDialog([{ speaker:'', text:'Estás muy debilitado.' },{ speaker:'', text:'¡Rápido! Escóndete en algún sitio.' }], true);
      // siguiente Acción cierra y hace fade out total
      CUT.hijackAction = ()=>{
        if (dialogOpen){ closeDialog(); }
        CUT.hijackAction = null;
        // Fade out de barras + retratos y volver al mundo
        HPBARS.hide();
        // al terminar retratos, reset
        CUT.onEnd = ()=>{ endCine3(); };
        _endPortraits(); // usa tu cierre estándar con blur out
      };
    }
  };
}


async function swapOtherJuanToSSJ(){
  // Busca el NPC con id fijo
  const other = NPCS.find(n => n.id === 'juansin_other');
  if(!other){
    console.warn('cine3: no se encontró el NPC juansin_other');
    endCine3();
    return;
  }

  // Carga el nuevo PNG y aplica (actualiza tamaño si cambia)
  const img = await loadImage('assets/npcs/juan_ssj.png');
  if (img){
    other.img = img;
    other.iw  = img.naturalWidth  || other.iw;
    other.ih  = img.naturalHeight || other.ih;
  }

  // (Opcional) pequeño destello para remarcar el cambio
  other._fxActive = true;
  other._fxUntil  = performance.now() + 300;

  // asegúrate de que el halo quede permanente tras el cambio de sprite
if (!GAME_FLAGS.juansin_other_halo){
  other.halo = { color:'255,255,160', radius:30, alpha:0.6, pulse:0.05, offsetY:0.62 };
  GAME_FLAGS.juansin_other_halo = true;
}

  // Termina la cine
  endCine3();
}

function endCine3(){
  CUT.active=false; CUT.id=null; CUT.phase=null; CUT.hijackAction=null; CUT.onEnd=null;
  ambientLock=false;
}

  
/* ========== MOVIMIENTO / MEGAUPDATE ========== */
function cornerSlide(targetX, targetY, vx, vy){
  const SLIDE = 3;
  if(Math.abs(vx) > Math.abs(vy)){
    for(const off of [-SLIDE, SLIDE]){
      const ty = clamp(player.y + off, 0, world.h);
      if(!anyOverlap(targetX, ty)){ player.y = ty; player.x = targetX; return true; }
    }
  } else {
    for(const off of [-SLIDE, SLIDE]){
      const tx = clamp(player.x + off, 0, world.w);
      if(!anyOverlap(tx, targetY)){ player.x = tx; player.y = targetY; return true; }
    }
  }
  return false;
}
  
function nudgeOut(){
  let moved = false;
  for(const ob of OBSTACLES){
    if(!ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) continue;
    const qx = clamp(player.x, ob.x, ob.x + ob.w);
    const qy = clamp(player.y + FEET_OFFSET_Y, ob.y, ob.y + ob.h);
    let dx = player.x - qx, dy = (player.y + FEET_OFFSET_Y) - qy;
    const ndx = dx / FEET_RADIUS_X, ndy = dy / FEET_RADIUS_Y;
    const len = Math.hypot(ndx, ndy) || 1e-6;
    const overlap = 1 - len + 0.001;
    if(overlap > 0){
      const pushX = (ndx/len) * overlap * FEET_RADIUS_X;
      const pushY = (ndy/len) * overlap * FEET_RADIUS_Y;
      player.x += pushX; player.y += pushY; moved = true;
    }
  }
  return moved;
}

function update(dt){
  const vx = (keys.left?-1:0) + (keys.right?1:0);
  const vy = (keys.up?-1:0) + (keys.down?1:0);

  if (!dialogOpen && ambientLock && !ambientLockOwner) ambientLock = false;

  // Intro: sube intensidad global y lanza primer diálogo
  if (introActive){
    AMBIENT.k = Math.min(1, AMBIENT.k + dt / (AMBIENT.introMs / 1000));
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
    if (canCenterCam) centerCameraOnPlayer();

    if (AMBIENT.k >= 1 && !initialDialogShown){
  initialDialogShown = true;
  setTimeout(()=>{
    initialDialogLock = true;   // ← marca que el lock pertenece al diálogo inicial
    interactBlocked = true;     // ← bloquea interacciones
    openDialog([{speaker:'Juan', text:'Se está haciendo tarde...'}], true);
    introActive = false;
  }, 300);
}

    return;
  }

   if (!CUT.active){
    const feet = feetWorld();
    const cz = CINE_BUILT.find(z=> !z._done && feet.x>=z.x && feet.x<=z.x+z.w && feet.y>=z.y && feet.y<=z.y+z.h);
    if (cz){
      cz._done = true;
      if (cz.id === 'cine1'){ startCinematic1(); return; }
      if (cz.id === 'cine3'){ startCinematic3(); return; }
    }
  }


  // Si hay diálogo Y NO estamos en cinemática, paramos aquí (como antes).
  // En cinemática NO hacemos return para que sigan fog/cámara/retratos.
  if (!CUT.active && dialogOpen){
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
    if (canCenterCam) centerCameraOnPlayer();
    return;
  }

  // Si hay ambientLock, congelamos animación de Juan (pero seguimos actualizando resto)
  if (ambientLock){
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
    if (canCenterCam) centerCameraOnPlayer();
  }
  HPBARS.update(dt);

  // Retratos y tween de cámara siguen siempre
  portraitsUpdate(dt);
  if (CAM_TWEEN.on){
    CAM_TWEEN.t = Math.min(1, CAM_TWEEN.t + dt*1000 / CAM_TWEEN.dur);
    const ease = (x)=> x<0.5 ? 2*x*x : 1 - Math.pow(-2*x+2,2)/2;
    const k = ease(CAM_TWEEN.t);
    cam.x = CAM_TWEEN.sx + (CAM_TWEEN.ex - CAM_TWEEN.sx)*k;
    cam.y = CAM_TWEEN.sy + (CAM_TWEEN.ey - CAM_TWEEN.sy)*k;
    if (CAM_TWEEN.t>=1) CAM_TWEEN.on=false;
  }

  // ---------------- Movimiento (bloqueado completamente si CUT.active) ----------------
  if (CUT.active){
  if (CUT.phase === 'autowalk'){
    // animar como si estuviera andando
    player.moving = true;
    if (CUT.autoDir) player.dir = CUT.autoDir;
    player.frameTime += dt;
    if (player.frameTime >= 0.12){
      player.frame = (player.frame + 1) % 2;
      player.frameTime = 0;
    }
  } else {
    // resto de fases: congelado
    player.moving = false;
    player.frame = 0;
  }
} else {
    const wantsToMove = !!(vx || vy);
    player.moving = !ambientLock && wantsToMove;

    if (player.moving){
      player.dir = Math.abs(vx) > Math.abs(vy) ? (vx < 0 ? 'left' : 'right') : (vy < 0 ? 'up' : 'down');
      const len   = Math.hypot(vx, vy) || 1;
      const stepx = (vx/len) * player.speed * dt;
      const stepy = (vy/len) * player.speed * dt;

      const s = JUAN.scale, halfW = Math.round(JUAN.size.w*s)/2, halfH = Math.round(JUAN.size.h*s)/2;
      const nx = clamp(player.x + stepx, halfW, world.w - halfW);
      const ny = clamp(player.y + stepy, halfH, world.h - halfH);

      let blockedX = false, blockedY = false;
      for (const ob of OBSTACLES) if (ellipseRectOverlap(nx, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedX = true; break; }
      if (!blockedX) player.x = nx;
      for (const ob of OBSTACLES) if (ellipseRectOverlap(player.x, ny + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedY = true; break; }
      if (!blockedY) player.y = ny;

      if (blockedX && blockedY){
        if (!cornerSlide(nx, ny, stepx, stepy)) nudgeOut();
      }

      player.frameTime += dt;
      if (player.frameTime >= 0.12){ player.frame = (player.frame + 1) % 2; player.frameTime = 0; }
    } else {
      player.frame = 0;
    }
  }

  if (!ambientLock) nudgeOut();

  const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
  if (canCenterCam) centerCameraOnPlayer();

  // La niebla debe actualizar SIEMPRE (incluida la cinemática)
  fogUpdate(dt);

  // ---------------- Zonas de ambiente ----------------
  const feet = feetWorld();
  const newZone = AMBIENT_BUILT.find(z => pointInRect(feet.x, feet.y, z));
  const prevZone = _ambientCurrentZone;

  if (newZone !== prevZone){
    // limpiar anterior
    if (prevZone){
      if (ambientLockOwner === prevZone){
        ambientLock = false;
        ambientLockOwner = null;
      }
      clearTimeout(prevZone._lockTO);
      clearTimeout(prevZone._dialogTO);
    }

    // bloqueo SOLO si habrá diálogo y solo primera vez
    if (newZone){
      const willShowDialog =
        Array.isArray(newZone.dialogOnEnter) &&
        newZone.dialogOnEnter.length > 0 &&
        !newZone._dialogShown;

      const lockMs   = newZone.lockMs ?? 0;
      const talkWait = newZone.dialogDelayMs ?? 0;

      if (willShowDialog && lockMs > 0){
        ambientLock = true;
        ambientLockOwner = newZone;
        newZone._lockTO = setTimeout(() => {
          if (!newZone._dialogShown){
            newZone._dialogShown = true;
            newZone._dialogTO = setTimeout(() => openDialog(newZone.dialogOnEnter, true), talkWait);
          }
        }, lockMs);
      } else if (willShowDialog){
        newZone._dialogShown = true;
        newZone._dialogTO = setTimeout(() => openDialog(newZone.dialogOnEnter, true), talkWait);
      }
    }

    // Objetivos de paleta (crossfade sin saltos)
    const targetPal = newZone ? newZone.palette : 'peach';
    AMBIENT.targets.peach    = (targetPal === 'peach')    ? 1 : 0;
    AMBIENT.targets.bluehour = (targetPal === 'bluehour') ? 1 : 0;
    AMBIENT.targets.hell     = (targetPal === 'hell')     ? 1 : 0;

    _ambientCurrentZone = newZone;
  }

  // Sube la intensidad global durante la intro (si lo mantienes así)
  AMBIENT.k = Math.min(1, AMBIENT.k + dt / (AMBIENT.introMs / 1000));

  // Interpolar alphas hacia sus objetivos (crossfade continuo)
  for (const key of Object.keys(AMBIENT.alphas)) {
    const a = AMBIENT.alphas[key];
    const t = AMBIENT.targets[key];
    AMBIENT.alphas[key] = (AMBIENT.fadeMs <= 0)
      ? t
      : a + (t - a) * Math.min(1, (dt * 1000) / AMBIENT.fadeMs);
  }
  smokeUpdate(dt);
}


/* ========== MEGADRAW ========== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // fondo
  let sx = Math.round(cam.x), sy = Math.round(cam.y);
  sx = clamp(sx, 0, world.w - cam.w);
  sy = clamp(sy, 0, world.h - cam.h);
  ctx.drawImage(bgImg, sx, sy, cam.w, cam.h, screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  // clip principal
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  // ----- cálculos del jugador -----
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);
  const jFoot = jy + jh/2;

// ----- z-list unificado (props + npcs + juan) -----
const zlist = [];

// props
for (const p of PROPS){
  const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
  const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
  const dw = Math.round(p.iw * p.scale * mapScaleX);
  const dh = Math.round(p.ih * p.scale * mapScaleY);
  const dx = Math.round(px - dw/2), dy = Math.round(py - dh);
  const spec = CATALOG[p.type] || {};
  const band = spec.depthBand ?? DEPTH_BAND;
  const anchor = (spec.depthAnchorY ?? 0) * mapScaleY;
  const pyCut = py + anchor;

  const sortY = spec.forceBack ? -9999 :
                (jFoot < pyCut - band) ? (py + 0.5) :
                (jFoot > pyCut + band) ? (py - 0.5) :
                py;

  zlist.push({
    y: sortY,
    draw(){
      if(!p.img){
        ctx.fillStyle='#777'; ctx.fillRect(dx,dy,dw,dh);
        ctx.strokeStyle='#222'; ctx.strokeRect(dx,dy,dw,dh);
        return;
      }
      if(spec.flipX){
        ctx.save(); ctx.scale(-1,1);
        ctx.drawImage(p.img, 0,0, p.iw,p.ih, -dx-dw, dy, dw, dh);
        ctx.restore();
      } else {
        ctx.drawImage(p.img, 0,0, p.iw,p.ih, dx,dy, dw,dh);
      }
    }
  });
}

// NPCs
for (const n of NPCS){
  const px = screenRect.dx + (n.x - cam.x) * mapScaleX;
  const py = screenRect.dy + (n.y - cam.y) * mapScaleY;
  const dw = Math.round(n.iw * n.scale * mapScaleX);
  const dh = Math.round(n.ih * n.scale * mapScaleY);
  const dx = Math.round(px - dw/2), dy = Math.round(py - dh);

  const band   = n.depthBand ?? DEPTH_BAND;
  const anchor = (n.depthAnchorY ?? 0) * mapScaleY;
  const pyCut  = py + anchor;

  const sortY = (jFoot < pyCut - band) ? (py + 0.5) :
                (jFoot > pyCut + band) ? (py - 0.5) :
                py;

  zlist.push({
    y: sortY,
    draw(){
      // sombra
      const sh = (n.shadow || DEFAULT_SHADOW);
      const footX = Math.round(px);
      const footY = Math.round(py);
      const shadowW = Math.max(6, Math.round(dw * sh.scaleX));
      const shadowH = Math.max(3, Math.round(dh * sh.scaleY));
      ctx.save();
      ctx.globalAlpha = sh.alpha;
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.ellipse(footX, footY + sh.offsetY, shadowW, shadowH, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

if (n.halo) {
  const halo = {
    color: '255,255,160',
    radius: 34,
    alpha: 0.55,
    pulse: 0.04,      // 0 si no quieres “respirar”
    offsetY: 0.6,     // altura relativa
    ...n.halo
  };
  const cx = Math.round(px);
  const cy = Math.round(py - dh * halo.offsetY);
  const R  = Math.max(10, halo.radius * Math.max(mapScaleX, mapScaleY));
  const t  = performance.now() * 0.0015;
  const Rp = R * (1 + Math.sin(t * 2.7) * halo.pulse);

  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, Rp);
  g.addColorStop(0.00, `rgba(${halo.color}, ${halo.alpha})`);
  g.addColorStop(0.55, `rgba(${halo.color}, ${halo.alpha * 0.35})`);
  g.addColorStop(1.00, `rgba(${halo.color}, 0)`);

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx, cy, Rp, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}




// (después de esto, dibujas el sprite como ya haces)
if (!n.img) { ctx.fillStyle='#999'; ctx.fillRect(dx,dy,dw,dh); }
else { ctx.drawImage(n.img,0,0,n.iw,n.ih,dx,dy,dw,dh); }

      // FX disparo (igual que antes)
     if (isNPCFxActive(n)) {
  const mx = Math.round(px + (n.muzzleOffset.x * mapScaleX));
  const my = Math.round(py + (n.muzzleOffset.y * mapScaleY));

  // 🔥 radio base + pulso
  const baseR = 20 * Math.max(mapScaleX, mapScaleY);
  const t = performance.now() * 0.02; // velocidad del parpadeo
  const pulsito = 1 + 0.25 * Math.sin(t * 12); // 25% de variación
  const r = baseR * pulsito;

  const g = ctx.createRadialGradient(mx, my, 0, mx, my, r);
  g.addColorStop(0, 'rgba(255,240,200,.95)');
  g.addColorStop(0.5, 'rgba(255,200,80,.55)');
  g.addColorStop(1, 'rgba(255,255,255,0)');

  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(mx, my, r, 0, Math.PI * 2); ctx.fill();
  ctx.globalCompositeOperation = 'source-over';
}

    }
  });
}

// Juan
zlist.push({
  y: jFoot,
  draw(){
    const img = player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];
    const footX = Math.round(jx);
    const footY = Math.round(jy + jh/2);

    // sombra
    ctx.fillStyle = 'rgba(0,0,0,.3)';
    ctx.beginPath();
    ctx.ellipse(footX, footY - 4, jw/2.5, jh/6, 0, 0, Math.PI*2);
    ctx.fill();

    // respiración
    const canBreathe = !player.moving && !dialogOpen && !ambientLock && !introActive;
    const phase  = canBreathe ? Math.sin(_nowSec * BREATH.speed) : 0;
    const sY     = 1 + phase * BREATH.scaleAmp;
    const sX     = 1 - phase * BREATH.scaleAmp*0.6;
    const compY  = (1 - sY) * jh;

    ctx.save();
    ctx.translate(footX, footY);
    ctx.translate(0, compY);
    ctx.scale(sX, sY);
    ctx.drawImage(img, 0, 0, sw, sh, Math.round(-jw/2), -jh, jw, jh);
    ctx.restore();
  }
});

// pinta TODO junto segun y
zlist.sort((a,b)=>a.y - b.y).forEach(it=>it.draw());

  ctx.restore();                                               // (salimos del clip para overlays)

  // Overlays de ambiente y linterna (quedarán por DEBAJO de la niebla)
  if (AMBIENT.k > 0.001){
    const order = ['peach','bluehour','hell'];
    for (const pal of order){
      const a = AMBIENT.alphas[pal] || 0;
      if (a > 0.001) drawPalette(pal, a * AMBIENT.k);
    }
  }
  drawFlashlightEnhance();

  // Debug (si lo usas)
  if (DEBUG_AMBIENT && AMBIENT_BUILT.length){ /* ... igual que antes ... */ }
  if (DEBUG_OBS){ /* ... igual que antes ... */ }
  if (DEBUG_INTER){ /* ... igual que antes ... */ }
if (DEBUG_CINE && CINE_BUILT.length){
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  ctx.lineWidth = 2;
  ctx.setLineDash([6,4]);

  for (const z of CINE_BUILT){
    const sx = Math.round(screenRect.dx + (z.x - cam.x) * mapScaleX);
    const sy = Math.round(screenRect.dy + (z.y - cam.y) * mapScaleY);
    const sw = Math.round(z.w * mapScaleX);
    const sh = Math.round(z.h * mapScaleY);

    // relleno suave
    ctx.fillStyle = 'rgba(0,255,255,0.15)'; // cian semitransparente
    ctx.fillRect(sx, sy, sw, sh);

    // borde
    ctx.strokeStyle = '#00FFFF';
    ctx.strokeRect(sx, sy, sw, sh);

    // etiqueta
    ctx.setLineDash([]);
    ctx.font = '600 12px system-ui, sans-serif';
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(sx+4, sy+4, ctx.measureText(z.id).width + 8, 18);
    ctx.fillStyle = '#00FFFF';
    ctx.fillText(z.id, sx+8, sy+18);
    ctx.setLineDash([6,4]);
  }

  ctx.restore();
}

  

  // >>>> NIEBLA AL FINAL DEL TODO (encima de todo lo anterior) <<<<
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();
  fogDraw();
  smokeDraw();
  ctx.restore();

  // Retratos / modo cine
  portraitsDrawOverlay();
  drawHPBars();
}


/* ========== LOOP / MEGAINIT ========== */
function loop(t){ if(!loop.last) loop.last=t; const dt=Math.min(1/60,(t-loop.last)/1000); loop.last=t; _nowSec = t / 1000;  update(dt); draw(); requestAnimationFrame(loop); }

async function init(){
  const [bg,spr] = await Promise.all([loadImage(BG_SRC), preloadSprites(JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog();
  await preloadNPCs();
  await preloadCinematicImages();

  world.w=bgImg.naturalWidth; world.h=bgImg.naturalHeight;
  CINE_BUILT = buildCineZones();
  AMBIENT_BUILT = buildAmbientZones();
  resize();

  const s=JUAN.scale; const halfW=Math.round(JUAN.size.w*s)/2, halfH=Math.round(JUAN.size.h*s)/2;
  if(START.mode==='percent'){ player.x=world.w*(START.x/100); player.y=world.h*(START.y/100); } else { player.x=START.x; player.y=START.y; }
  player.x=clamp(player.x,halfW,world.w-halfW); player.y=clamp(player.y,halfH,world.h-halfH);
  player.dir='down'; player.moving=false; player.frame=0; player.frameTime=0;
  keys.up=keys.down=keys.left=keys.right=false;

  buildPropsAndObstacles();
    buildNPCs();   

  const superProp = PROPS.find(p => p.type === 'super');
  if (superProp){
    smokeStart({ x: superProp.x, y: superProp.y - 50 });
     //SMOKE.areaW = 150; SMOKE.areaH = 90; //SMOKE.targetDensity = 100;
  }

  centerCameraOnPlayer();

  // Arranque del ambiente base desde 0 con fade
  AMBIENT.k = 0;
AMBIENT.alphas  = { peach:1, bluehour:0, hell:0 };
AMBIENT.targets = { peach:1, bluehour:0, hell:0 };
  requestAnimationFrame(loop);
  // fade negro inicial
setTimeout(()=> document.getElementById('blackfade').classList.add('hide'), 50);

}
init();
</script>
</body>
</html>
