<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin — outside</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html,body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  .screen::after{ content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%); z-index:5; }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:#000; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }
  .img-act::before{
    content:""; display:block; width:100%; height:100%;
    background:url("assets/ui/action_btn.PNG") center/contain no-repeat; image-rendering:pixelated; transform:scale(1.02);
  }

  #blackfade{
  position:fixed; inset:0;
  background:#000;
  z-index:9999;
  opacity:1;
  transition: opacity 1.5s ease; /* duración del fade */
}
#blackfade.hide{
  opacity:0;
  pointer-events:none;
}


  /* Toast */
  .toast{
    position:absolute; top:19px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.8); color:#fff; font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px; border-radius:8px; opacity:0; transition:opacity .2s ease;
    white-space:nowrap; pointer-events:none; z-index:6;
  }
  .toast.show{ opacity:1; }

  .dialog{
    position:absolute; left:50%; bottom:10px; transform:translateX(-50%) scaleX(0); transform-origin:center bottom;
    width:calc(100% - 24px); max-width:460px; min-height:20px; box-sizing:border-box;
    padding:12px 16px 16px; display:flex; gap:10px; border-radius:10px; flex-direction:column; text-align:left;
    image-rendering:pixelated; z-index:7; transition:transform .22s ease;
    background:rgba(12,12,24,0.9); border-top:2px solid #3cf;
  }
  .dialog.show{ transform:translateX(-50%) scaleX(1); }
  .dialog-name.juan{ font-family:'Press Start 2P',system-ui; font-size:10px; color:#8df; margin-bottom:4px; text-shadow:0 1px 0 #000; }
  .dialog-name.other{ font-family:'Press Start 2P',system-ui; font-size:10px; color:#f98; margin-bottom:4px; text-shadow:0 1px 0 #000; }
  .dialog-text{ font-family:'VT323',monospace; font-size:18px; letter-spacing:1px; line-height:1.15; color:#E6F6FF; min-height:2.2em; }
  .dialog-hint{ margin-left:auto; color:#B8D7FF; font:600 12px/1 system-ui; opacity:0; transition:opacity .18s ease; }
  .dialog.ready .dialog-hint{ opacity:.9; }
  .fx-ray{ position:absolute; width:6px; height:3px; background:#00ff66; box-shadow:0 0 10px #00ff66, 0 0 18px #00ff66; transform-origin:left center; z-index:8; display:none; }

  
</style>
</head>
<body>

<audio id="bgTown"     src="assets/sounds/ambientepueblo.mp3" loop preload="auto" playsinline></audio>
<audio id="bgBluehour" src="assets/sounds/bluehour.mp3"      loop preload="auto" playsinline></audio>
<audio id="bgCombat"   src="assets/sounds/combate.mp3"        loop preload="auto" playsinline></audio>


<div class="gameboy">
  <div class="screen-container">
    <div class="screen">
      <div id="blackfade"></div>
      <div id="toast" class="toast"></div>
      <div id="rayFx" class="fx-ray"></div>

<div id="dialog" class="dialog">
  <div id="attackMenu" style="
    position:absolute; left:12px; bottom:100%; margin-bottom:6px;
    background:rgba(0,0,0,0.7); color:#fff; padding:8px 10px; border:1px solid #fff; border-radius:6px;
    font-family:'Press Start 2P', monospace; font-size:10px; line-height:1.6; display:none; z-index:1;">
    <div id="atkOpt0">Bola</div>
    <div id="atkOpt1">Puñetazo</div>
  </div>

  <div id="dialogName" class="dialog-name"></div>
  <div id="dialogText" class="dialog-text"></div>
  <div id="dialogHint" class="dialog-hint">→</div>
</div>


      <canvas id="game"></canvas>
    </div>
  </div>


  <div class="controls">
    <div class="dpad">
      <div></div><button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button><div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button><div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button><div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button><div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción"></button>
  </div>
</div>

<script>
/* ========== CONFIG RÁPIDA ========== */
const ROOM = { w:512, h:350 };
const ZOOM = 2.1;
const START = { mode:'percent', x:7, y:81 };
const FEET_RADIUS_X = 7, FEET_RADIUS_Y = 4, FEET_OFFSET_Y = 8;
const DEBUG_OBS = false;
const DEBUG_INTER = false;
const DEBUG_AMBIENT = false;
const DEBUG_CINE = false; 
const DEPTH_BAND = 12;
let interactBlocked = true;     
let initialDialogLock = false;  
let onDialogClosed = null;

/* ====== BACKBUFFER para blur en modo cine ====== */
let BACKBUF = document.createElement('canvas');
let BACKCTX = BACKBUF.getContext('2d');

/* ====== ESTADO CINEMÁTICA ====== */
const CUT = {
  active: false,       
  id: null,          
  phase: null,         
  hijackAction: null, 
  onEnd: null        
};


const FOG = {
  active:false, parts:[],
  filling:false, tFill:0, fillDur:3000,      // 3s para “llenar”
  targetDensity: 200,                         // un pelín más denso
  baseAlpha: 0.03,                            // más opacidad por partícula
  seed: 1337,
  color: '255,255,255',
  layer: 'betweenBackAndActors',
  oneSideBias: 0.9,

  swirl: 16,          // antes 32 → menos giro
  attract: 7,        // antes 18 → avanza más despacio al centro
  jitterAmp: 3,       // antes 6  → menos “tembleque”
  jitterFreq: 0.9,    // antes 1.3

  bandTop:    0.08,   // 8% desde arriba
  bandBottom: 0.50,_densityScale: 1,  // hasta mitad de pantalla aprox
  _aimAhead: false,     // si true, emite por delante de la cámara
  aheadBias: 0.24,      // cuánto adelantamos el “centro” (0 = centro, 0.24 ≈ 24% hacia arriba)
  space: 'screen',
  anchorWorld: null,
  areaW: 360,
  areaH: 140
};

const townMusic   = document.getElementById('bgTown');
const combatMusic = document.getElementById('bgCombat');
townMusic.volume = 0.5;
combatMusic.volume = 0.5;

townMusic.addEventListener('ended',  () => { townMusic.currentTime = 0; townMusic.play().catch(()=>{}); });
combatMusic.addEventListener('ended',() => { combatMusic.currentTime = 0; combatMusic.play().catch(()=>{}); });

/* ====== AUDIO GATE GLOBAL ====== */
const AudioGate = (() => {
  let unlocked = false, primed = false, primingPromise = null;
  const ids = ['bgTown','bgBluehour','bgCombat'];
  const getAll = ()=> ids.map(id=>document.getElementById(id)).filter(Boolean);

  function unlock(){
    if (unlocked) return;
    unlocked = true;
    primeAll();
  }

  window.__lockToTown = true;
  
function primeAll(){
  if (primed || primingPromise) return primingPromise || Promise.resolve();
  const audios = getAll();
  primingPromise = Promise.all(audios.map(a=>{
    if (!a) return;
    const prevMuted=a.muted, prevLoop=a.loop;
    a.muted=true; a.loop=false;
    a.volume = 0;
    const p=a.play();
    const stop=()=>{ try{ a.pause(); a.currentTime=0; }catch(_){} a.muted=prevMuted; a.loop=prevLoop; a.volume = 0; };
    return p && p.then ? p.then(stop).catch(stop) : stop();
  })).then(()=>{ primed=true; });
  return primingPromise;
}

  async function ready(){ if(!unlocked) unlock(); await primeAll(); }
  return {unlock,ready};
})();



// ******************************* SMOKE SUPER

  const SMOKE = {
  active: false,
  parts: [],
  anchor: null,            // {x,y} en mundo
  areaW: 90,              // ancho del “ovillo” de humo
  areaH: 35,               // alto del “ovillo”
  targetDensity: 80,       // densidad base
  color: '40,40,40',      // gris muy oscuro tirando a negro
  baseAlpha: 0.08,        // más denso (ajusta 0.07–0.1 según te guste)
  swirl: 10,               // remolino suave
  attract: 5,              // atracción al centro
  jitterAmp: 2.0,
  jitterFreq: 1.0,
  seed: 4242
};


/* ====== CAMERA TWEEN ====== */
const CAM_TWEEN = { on:false, t:0, dur:1000, sx:0, sy:0, ex:0, ey:0 };

/* ====== PORTRAITS (secuenciados) ====== */
const PORTRAITS = {
  active:false,
  blurPx:100,
  blurK:0,
  blurInMs:1000,
  blurOutMs:1000,
  slideMs:450,
  script:[],
  idx:0,
  left:{}, right:{},
  stage:'idle',
  forceBlurFallback: false
};

const PORTRAIT_SCALES = {
  Gandalf: 2.3,
  GandalfW: 3,
  Juan:    1.7,
  Voldemort: 2,
  "DonRamon y Perchita": 1.2,
  SSJ:     1.7
};

const PORTRAIT_TOP_AIR = 15;   // aire fijo por arriba (px relativos a screenRect)
const PORTRAIT_BOTTOM_PAD = -40; // “colchón” desde abajo
const PORTRAIT_EDGE_INSET = -0.12;
  
const DEFAULT_SHADOW = {
  alpha: 0.28,     // opacidad de la elipse
  offsetY: -2,     // desplazamiento vertical desde los pies
  scaleX: 1/2.8,   // ancho relativo
  scaleY: 1/8      // alto relativo
};
// ====== BARRAS DE VIDA PARA CINE ======
const HPBARS = {
  active:false, alpha:0, fadeInMs:400, fadeOutMs:400,
  leftName:'SSJ',
  rightName:'Juan',
  juan:100, ssj:100, juanT:100, ssjT:100, speed:120, // % por segundo
  show(juanPct=100, ssjPct=100){ this.active=true; this.alpha=0; this._showing=true; this._hiding=false; this.juan=this.juanT=juanPct; this.ssj=this.ssjT=ssjPct; },
  setTargets(juanPct, ssjPct){ if(juanPct!=null) this.juanT=juanPct; if(ssjPct!=null) this.ssjT=ssjPct; },
  hide(){ if(!this.active) return; this._hiding=true; this._showing=false; },
  update(dt){
    if(!this.active) return;
    const step = this.speed*dt;
    const lerp = (v,t)=> v + Math.sign(t-v)*Math.min(Math.abs(t-v), step);
    this.juan = lerp(this.juan, this.juanT);
    this.ssj  = lerp(this.ssj,  this.ssjT);
    if (this._showing){ this.alpha = Math.min(1, this.alpha + (dt*1000)/this.fadeInMs); if(this.alpha>=1) this._showing=false; }
    if (this._hiding){ this.alpha = Math.max(0, this.alpha - (dt*1000)/this.fadeOutMs); if(this.alpha<=0){ this._hiding=false; this.active=false; } }
  }
};
  
  function _ease(t){
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
}

function drawHPBars(){
  if(!HPBARS.active || HPBARS.alpha<=0) return;
  const a = Math.max(0, Math.min(1, HPBARS.alpha));

  const padSide   = Math.round(screenRect.dw * 0.02);  // margen lateral
  const gapCenter = Math.round(screenRect.dw * 0.04);  // hueco central
  const barW      = Math.round(screenRect.dw * 0.46);  // ancho de cada barra
  const barH      = 9;                                // alto barra
  const nameGap   = 5;                                // espacio entre nombre y barra
  const yTop      = Math.round(screenRect.dy + 16);    // todo pegado arriba

  const leftX  = Math.round(screenRect.dx + padSide);
  const rightX = Math.round(screenRect.dx + screenRect.dw - padSide - barW);

  const bgStyle   = 'rgba(255,255,255,0.18)';
  const frameStyle= 'rgba(255,255,255,0.35)';

  const nameFont  = '10px "Press Start 2P", system-ui, sans-serif';
  const nameColor = '#E6F6FF';

  const wSSJ  = Math.round(barW * (HPBARS.ssj/100));
  const wJuan = Math.round(barW * (HPBARS.juan/100));

  const leftName  = HPBARS.leftName  || 'SSJ';
  const rightName = HPBARS.rightName || 'Juan';

  ctx.save();
  ctx.globalAlpha = a;

  ctx.font = nameFont;
  ctx.fillStyle = nameColor;
  ctx.textBaseline = 'bottom';

  ctx.fillText(leftName,  leftX,  yTop - 2);
  ctx.fillText(rightName, rightX + barW - ctx.measureText(rightName).width, yTop - 2);

  ctx.fillStyle = bgStyle;
  ctx.fillRect(leftX, yTop + nameGap, barW, barH);
  ctx.fillStyle = '#e03232'; // rojo SSJ
  ctx.fillRect(leftX, yTop + nameGap, wSSJ, barH);
  ctx.strokeStyle = frameStyle;
  ctx.strokeRect(leftX + 0.5, yTop + nameGap + 0.5, barW - 1, barH - 1);

  ctx.fillStyle = bgStyle;
  ctx.fillRect(rightX, yTop + nameGap, barW, barH);
  ctx.fillStyle = '#3c88ff'; // azul Juan
  ctx.fillRect(rightX, yTop + nameGap, wJuan, barH);
  ctx.strokeStyle = frameStyle;
  ctx.strokeRect(rightX + 0.5, yTop + nameGap + 0.5, barW - 1, barH - 1);

  ctx.restore();
}


/* ========== ASSETS ========== */
const BG_SRC = "assets/locations/outside.png";
const JUAN = { size:{w:36,h:40}, scale:0.9,
  idle:{down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"]},
  walk:{down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
        up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
        left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
        right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"]}
};

  // justo debajo de: const player={x:0,y:0,dir:'down',speed:150,...};
const BREATH = {
  amp: 0.0,       // píxeles de subida/bajada
  scaleAmp: 0.01, // 2% de zoom al respirar (muy sutil)
  speed: 4      // Hz ~ velocidad del ciclo
};
let _nowSec = 0;  // tiempo en segundos (lo llenamos en loop)

const GAME_FLAGS = {
  talked_gunner: false,
  talked_patata1: false,
  juansin_other_halo: false,
  need_potion:false,   // ← nuevo: SSJ bloqueado hasta tomarla
  has_potion:true,
  talked_faramir: false,
  talked_denethor:false
};

  

/* ========== LINTERNA (opcional) ========== */
const LIGHT = {
  enabled: false,
  mode: 'cone',
  radius: 70,
  feather: 0.45,
  coneLen: 150,
  coneWidth: Math.PI/5,
  flicker: 0.03,
  brightness: 0.4,
  tint: '255,230,180'
};

async function preloadCinematicImages(){
  IMG_GANDALF_SMALL = await loadImage('assets/npcs/gandalf.png');
  IMG_GANDALF       = await loadImage('assets/portraits/gandalf_portrait.png');
  IMG_JUAN_BIG      = await loadImage('assets/portraits/juansin_portrait.png');
  IMG_JUAN_SSJ      = await loadImage('assets/portraits/juansin_ssj_portrait.png');
  IMG_JUAN_FIGHT    = await loadImage('assets/portraits/juansin_pelea_portrait.png');
  IMG_FUMAOS    = await loadImage('assets/portraits/fumaos_portrait.png');
  IMG_GANDALF_WHITE = await loadImage('assets/npcs/gandalfblanco.png');
  IMG_GANDALF_WHITE_P = await loadImage('assets/portraits/gandalfblanco_portrait.png');
  IMG_VOLD_FRONT = await loadImage('assets/npcs/voldemort.png').catch(()=>null);
  IMG_VOLD_PERFIL = await loadImage('assets/npcs/voldemort_perfil.png').catch(()=>null);
  IMG_VOLD_P     = await loadImage('assets/portraits/voldemort_portrait.png').catch(()=>null);
  IMG_DENETHOR_CAIDO     = await loadImage('assets/npcs/denethorcaido.png').catch(()=>null);
}

  // ------------------------ ZONAS CINE
  const CINE_ZONES = [
  { id:'cine1', rect:{type:'percent', x:10, y:50, w:10, h:5}, _done:false },
  { id:'cine2', rect:{type:'percent', x:73, y:0, w:10, h:50}, _done:false },
  { id:'cine3', rect:{type:'percent', x:84, y:79, w:1, h:50}, _done:false }

];
  function buildCineZones(){
  return CINE_ZONES.map(z=>{
    const r=z.rect;
    if (r.type==='percent'){
      return { ...z,
        x: Math.round(world.w*(r.x/100)), y: Math.round(world.h*(r.y/100)),
        w: Math.round(world.w*(r.w/100)), h: Math.round(world.h*(r.h/100))
      };
    }
    return {...z, x:r.x,y:r.y,w:r.w,h:r.h};
  });
}
let CINE_BUILT = [];

  

/* ========== ZONAS AMBIENTE (alphas por paleta, sin saltos) ========== */
const AMBIENT = {
  k: 0,            // intensidad global (sube en la intro)
  introMs: 1200,   // fade-in inicial de k
  fadeMs: 2000,    // duración del crossfade entre paletas
  alphas:  { peach: 1, bluehour: 0, hell: 0 },
  targets: { peach: 1, bluehour: 0, hell: 0 }
};

const AMBIENT_ZONES = [
  {
    name:'Bluehour zone', palette:'bluehour',
    music: 'bluehour',
    musicFadeMs: 3000,
    dialogOnEnter:[
      { speaker:'Juan', text:'...' },
      { speaker:'Juan', text:'Tengo un mal presentimiento...' },
      { speaker:'Juan', text:'Hay un olor extraño.' },
      { speaker:'Juan', text:'Huele...' },
      { speaker:'Juan', text:'Huele a Champions.' }
    ],
    dialogDelayMs: 500, lockMs: 1000,
    rect:{type:'percent', x:24, y:0, w:100, h:35}
  },
  {
    name:'Infierno super', palette:'hell',
    music: 'bluehour',
    musicFadeMs: 3000,
    rect:{type:'percent', x:60, y:35, w:50, h:100}
  }
];


let ambientLock = false;
let ambientLockOwner = null;
let AMBIENT_BUILT = [];
let _ambientCurrentZone = null;
let introActive = true;
let initialDialogShown = false;
let NPC_IMAGES = {}, NPCS = [];


  /* ========== NPCs ========== */
// Catálogo de tipos de NPC (sprite, escala, collider, etc.)
const NPC_CATALOG = {
  abuela: { src: 'assets/npcs/abuela.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  abuela1: { src: 'assets/npcs/abuela1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  gato1: { src: 'assets/npcs/gato1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  voldemort_perfil: { src: 'assets/npcs/voldemort_perfil.png', scale: 0.5, collider: { x:-20, y:0, w:30, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetX:2, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 },halo: { color: '80,255,140', radius: 34, alpha: 0.55 }},
  soldado1: { src: 'assets/npcs/soldado1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,muzzleOffset: { x: -20, y: -12 },shadow:{ alpha:0.28, offsetY:0, offsetX:2, scaleX:1/3, scaleY:1/7.5 },fireFxMs: 140},
  soldado2: { src: 'assets/npcs/soldado2.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  patata1: { src: 'assets/npcs/patatas1.png', flipX:true, scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  patata2: { src: 'assets/npcs/patatas2.png', flipX:true, scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  faramir: { src: 'assets/npcs/faramir.png', flipX:true, scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  denethor: { src: 'assets/npcs/denethor.png', flipX:true,scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 }},
  juansin_idle: { src: 'assets/juan_character/idle_down_shoes.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 }, depthBand: 8, depthAnchorY: 1, shadow:{ alpha:0.28, offsetY:0, scaleX:1/2.1, scaleY:1/7.5 } },

};

const NPC_PLACED = {
  abuela: [{type:'percent', x: 24, y: 91, interact: { x:-20, y: 10, w:39, h:25 }, 
     dialog: [{ speaker:'Juan', text:'Hola, abuela.' }, { speaker:'Abuela',text:'Ay mijo...' }]
    }],
  abuela1: [{type:'percent', x: 43.4, y: 19.5, interact: { x:-13, y: 10, w:29, h:18 }, 
     dialog: [{ speaker:'Abuela Oscura', text:'Hola, Juan.' }, { speaker:'Juan',text:'¿Qué fue?' },{ speaker:'Abuela Oscura', text:'El gato se ha vuelto a escapar.' }, { speaker:'Juan',text:'Ños... ¿Otra vez?'}, { speaker:'Juan',text:'Me pareció verlo cerca del río...'}]
    }],
  gato1: [{type:'percent', x: 21, y: 61, interact: { x:-13, y: 10, w:29, h:18 }, 
     dialog: [{ speaker:'Gato', text:'¿Comidita?' }],sound: "assets/sounds/miau.mp3"
    }],
  voldemort_perfil: [{id:'voldemort_perfil',type:'percent', x: 82.2, y: 16.5}],
  soldado1: [{id:'gunner1', type:'percent', x: 94, y: 66, interact: { x:-13, y: 10, w:29, h:18 },onFire:true, 
     dialog: [{ speaker:'Armiche', text:'Ahí te va un pequeño perdigón.'}],sound: "assets/sounds/shot.mp3"
    }],
  soldado2: [{id:'guard1', type:'percent', x: 86, y: 66, interact: { x:-13, y: 10, w:29, h:18 },requiresFlag:'talked_gunner',  
     dialogBlocked:[ {speaker:'Boliche', text:'¡Como en el Call of Duty, señores!'}], dialog: [{ speaker:'Boliche', text:'¡Ah! ¡Mi lentilla!' }]
    }],
  patata1: [{id:'patata1', type:'percent', x: 66.6, y: 20, interact: { x:-13, y: 10, w:29, h:18 }, patatas:true, dialog: [{ speaker:'Canario medio', text:'¿Me podría dar unas papitas con mojo, por favor?'}],
    }],
  patata2: [{id:'patata2', type:'percent', x: 63.6, y: 20, interact: { x:-13, y: 10, w:29, h:18 },
     dialogBlocked:[ {speaker:'Godo', text:'¿Papa? ¿Mojo? ¿Miniño? ¿Muchacho?'}], dialog: [{ speaker:'Godo', text:'¿Me podría dar...' },{ speaker:'Godo', text:'unas pata ti tash?' }]
    }],
  faramir: [{id:'faramir', type:'percent', x: 15.5, y: 8, interact: { x:-13, y: 10, w:29, h:18 }, faramir:true, dialogBlocked:[ {speaker:'Faramir', text:'Vete por la autopista, pa que la veas. Está hecha polvo.'}], requiresFlag:'talked_denethor',  faramir1:true, dialog: [{ speaker:'Faramir', text:'¡Date una vuelta!'},{ speaker:'Faramir', text:'Pa que la veas... cómo está la Avenida Anaga...'}],dialog2: [{ speaker:'Faramir', text:'Muchacho... levántate ahí, muchacho...'}]
    }],
  denethor: [{id:'denethor', type:'percent', x: 12.5, y: 8, interact: { x:-13, y: 10, w:29, h:18 }, denethor:true, dialogBlocked:[ {speaker:'Denethor', text:'¡Tas diciendo hombre!'}], requiresFlag:'talked_faramir',  faramir1:true, dialog: [{ speaker:'Denethor', text:'¡ME DA IGUAL LA AVENIDA ANAGA!'},{ speaker:'Denethor', text:'Yo quiero que me pongas la luz.'},{ speaker:'Denethor', text:'Ayquemecaigocoño...'}],
    }],
  juansin_idle: [{id:'juansin_other', type:'percent', x: 77, y: 76, interact: { x:-13, y: 10, w:29, h:18 }
  }],
};

const CINE4_AROUND = [
   { type:'abuela', dx:+20, dy:  -4, flipX:false, id:'abuela_c4' },
   { type:'soldado1',  dx:-75, dy:+25, flipX:true,  id:'soldado_c4' },
   { type:'patata1',  dx:+40, dy:+30 },
   { type:'patata2',  dx:-70, dy:0 },
  { type:'faramir',  dx:-30, dy:+14,flipX:false},
  { type:'denethor',  dx:-53, dy:+50,flipX:true },
  { type:'abuela1',  dx:+30, dy:-22,flipX:true },
  { type:'gato1',  dx:+34, dy:-13,flipX:false },
];

const CINE4_OUTRO_SCRIPT = [
  { speaker:'Juan', text:'Pues ya estaría.' },
 { speaker:'Juan', text:'Venga, al súper.' },
   { speaker:'Juan', text:'(respira) Ya pasó.' },
];


/* ========== CATALOGO / PLACEMENT ========== */
const CATALOG = {
  arbolclaro:   { src:'assets/objects/arbolclaro.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbolmedio:   { src:'assets/objects/arbolmedio.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arboloscuro:  { src:'assets/objects/arboloscuro.png',  scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbustoclaro: { src:'assets/objects/arbustoclaro.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustomedio: { src:'assets/objects/arbustomedio.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustooscuro:{ src:'assets/objects/arbustooscuro.png',scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustooscuroescondite:{ src:'assets/objects/arbustooscuro.png', scale:1, collider:null },
  piedra:       { src:'assets/objects/piedra.png',       scale:1, collider:{x:-28,y:-4,w:55,h:27} },
  piedraFlip:   { src:'assets/objects/piedra.png',       scale:1, collider:{x:-28,y:-4,w:55,h:27}, flipX:true },
  piedraBig:    { src:'assets/objects/piedra.png',       scale:1.2, collider:{x:-28,y:-4,w:55,h:27} },
  valla_clara:  { src:'assets/objects/valla_clara.png',  scale:1, collider:null },
  valla_media:  { src:'assets/objects/valla_media.png',  scale:1, collider:{x:-50,y:3,w:50,h:1} },
  valla_oscura: { src:'assets/objects/valla_oscura.png', scale:1, collider:{x:-210,y:-4.5,w:500,h:1}},
  casajuan:     { src:'assets/objects/casajuan.png',     scale:1, collider:{x:-46.5,y:-5,w:91, h:21}, depthBand:1, depthAnchorY:1, interact:{x:-20,y:5,w:38,h:18}},
  casaclara:    { src:'assets/objects/casaclara.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_amarilla:{ src:'assets/objects/casaclara_amarilla.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_azul:{ src:'assets/objects/casaclara_azul.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casamedia:    { src:'assets/objects/casamedia.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casamedia_roja:{ src:'assets/objects/casamedia_roja.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casamedia_rosa:{ src:'assets/objects/casamedia_rosa.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casaoscura:    { src:'assets/objects/casaoscura.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaoscura_roja:{ src:'assets/objects/casaoscura_roja.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaoscura_rosa:{ src:'assets/objects/casaoscura_rosa.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  puente:       { src:'assets/objects/puente.png', scale:1, collider:{x:-33.5,y:0,w:67.8, h:11} },
  puente2:      { src:'assets/objects/puente2.png', scale:1, collider:null},
  river1:       { src:'assets/objects/rio1.png',   scale:1, collider:null, forceBack: true},
  river2:       { src:'assets/objects/rio2.png',   scale:1, collider:null, forceBack: true},
  super:        { src:'assets/objects/super.png',  scale:1, collider:{x:-63,y:-5,w:120, h:23}, depthBand:1, depthAnchorY:1},
  potion: { src: 'assets/objects/pocima.png', scale: 0.08},
};

const PLACED = {
  arbolclaro:  [{type:'percent',x:4,y:85},{type:'percent',x:17,y:87.5},{type:'percent',x:2,y:64},{type:'percent',x:28.2,y:64},{type:'percent',x:17.5,y:52},{type:'percent',x:22.5,y:31.5},{type:'percent',x:3,y:8}],
  arbolmedio:  [{type:'percent',x:25.8,y:30},{type:'percent',x:25.3,y:12},{type:'percent',x:37,y:19},{type:'percent',x:47,y:19},{type:'percent',x:57,y:20},{type:'percent',x:70,y:14},{type:'percent',x:33,y:10},
                {type:'percent',x:40,y:30},{type:'percent',x:50,y:30},{type:'percent',x:60,y:30},{type:'percent',x:70,y:30},{type:'percent',x:76.5,y:22.5},{type:'percent',x:86.5,y:22.5},{type:'percent',x:78,y:10},
                {type:'percent',x:83,y:10.5},{type:'percent',x:85,y:32},{type:'percent',x:79,y:35},{type:'percent',x:96,y:9},{type:'percent',x:94,y:20},{type:'percent',x:96.5,y:30}],
  arboloscuro:  [{type:'percent',x:83,y:55},{type:'percent',x:78.5,y:58},{type:'percent',x:63,y:61},{type:'percent',x:85,y:79},{type:'percent',x:78,y:100.5}],
  casajuan:    [{type:'percent',x:7.2,y:82,say:'Tengo una misión.'}],
  casaclara_amarilla:[{type:'percent',x:24.5,y:90}],
  casaclara_azul:    [{type:'percent',x:5.5,y:45,interact:[{x:20,y:5,w:16,h:18,say:'No pasarás. Céntrate en la misión.'}]}],
  casaclara:         [{type:'percent',x:7,y:20,interact:[{x:-12,y:5,w:20,h:18,say:'Cerrada. Como tú corazón al conocer a viscosin13...'}]}],
  casamedia_roja:    [{type:'percent',x:42,y:17}],
  casamedia_rosa:    [{type:'percent',x:62,y:17}],
  casamedia:         [{type:'percent',x:52,y:17}],
  casaoscura_roja:   [{type:'percent',x:95.5,y:62}],
  casaoscura_rosa:   [{type:'percent',x:65,y:92}],
  casaoscura:        [{type:'percent',x:95.5,y:85}],
  arbustoclaro: [{type:'percent',x:3.2,y:97},{type:'percent',x:18.5,y:89},{type:'percent',x:25,y:66},{type:'percent',x:17,y:63},{type:'percent',x:9,y:62.5},{type:'percent',x:27.8,y:52},{type:'percent',x:5.3,y:54},
                 {type:'percent',x:23,y:40},{type:'percent',x:22,y:35.5},{type:'percent',x:23.5,y:10}],
  arbustomedio: [{type:'percent',x:27.5,y:33.5},{type:'percent',x:30,y:12},{type:'percent',x:46,y:20},{type:'percent',x:57,y:31},{type:'percent',x:37,y:31},{type:'percent',x:68,y:16},{type:'percent',x:84.5,y:13},
                 {type:'percent',x:72,y:11},{type:'percent',x:74,y:13.5},{type:'percent',x:80,y:12},{type:'percent',x:86,y:9},{type:'percent',x:90,y:12},{type:'percent',x:97,y:11},{type:'percent',x:76,y:25},
                 {type:'percent',x:96,y:25},{type:'percent',x:82,y:33},{type:'percent',x:94,y:32}],
  arbustooscuro: [{type:'percent',x:97,y:49},{type:'percent',x:86,y:57},{type:'percent',x:65,y:63},{type:'percent',x:83,y:79},{type:'percent',x:97,y:96}],
  arbustooscuroescondite: [{id:'bush_hideout', type:'percent', x: 86, y: 81, interact: { x:-10, y: -15, w:8, h:6 }}],
  valla_clara:  [{type:'percent',x:15.25,y:99.75}],
  valla_media:  [{type:'percent',x:53.61,y:31.9}],
  valla_oscura: [{type:'percent',x:80.17,y:99.15}],
  piedra:       [{type:'percent',x:84.66,y:44}],
  piedraFlip:   [{type:'percent',x:80.35,y:41}],
  piedraBig:    [{type:'percent',x:96.1,y:43}],
  puente:       [{type:'percent',x:23.97,y:20.95}],
  puente2:      [{type:'percent',x:23.97,y:13.23}],
  river1:       [{type:'percent', x:5.73,  y:62.37}],
  river2:       [{type:'percent', x:22.91, y:62.37}],
  super:        [{type:'percent', x:72.9, y:74}]
};

/* Obstáculos extra */
const OBSTACLE_DEFS = [
  {type:'percent', x:29.4, y:30.6, w:31.85, h:80,   name:'zona bloqueada 1'},
  {type:'percent', x:60,   y:30.6, w:17.9,  h:24.5, name:'zona bloqueada 2'},
  {type:'percent', x:-4,   y:52,   w:15.5,  h:9.7,  name:'zona bloqueada rio 1'},
  {type:'percent', x:15.3, y:51,   w:22,    h:8.5,  name:'zona bloqueada rio 2'},
  {type:'percent', x:20.6, y:11.5, w:6.5,   h:1.5,  name:'zona bloqueada puente 5'},
  {type:'percent', x:21.8, y:36.5, w:12,    h:1,    name:'zona bloqueada valla pequeña clara'},
  {type:'percent', x:24,   y:20.4, w:0.5,   h:15.7, name:'zona bloqueada valla pequeña clara 2'},
  {type:'percent', x:24,   y:0,    w:0.5,   h:10,   name:'zona bloqueada valla pequeña clara 3'},
  {type:'percent', x:0,    y:1,    w:1,     h:110,  name:'zona bloqueada valla izquiera larga'},
  {type:'percent', x:77.5, y:45.5, w:4,     h:9.5,  name:'zona bloqueada pequeña final bosque'},
  {type:'percent', x:87.3, y:34.8, w:0.8,   h:10.2, name:'zona bloqueada puente oscuro 1'},
  {type:'percent', x:92.1, y:34.8, w:0.8,   h:10.2, name:'zona bloqueada puente oscuro 2'},
  {type:'percent', x:81,   y:45.5, w:0.7,   h:32,   name:'zona bloqueada valla oscura central'}
];

/* ========== STATE BÁSICO ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

  window.addEventListener('touchstart', ()=>AudioGate.unlock(), {once:true, passive:true});

let bgImg=null, sprites=null, world={w:0,h:0};
let PROP_IMAGES={}, PROPS=[], OBSTACLES=[];
let cam={x:0,y:0,w:ROOM.w/ZOOM|0,h:ROOM.h/ZOOM|0};
let screenRect={dx:0,dy:0,dw:0,dh:0}, mapScaleX=1, mapScaleY=1;

const player={x:0,y:0,dir:'down',speed:150,moving:false,frame:0,frameTime:0};

/* ========== INPUT (SOLO D-PAD EN PANTALLA) ========== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){
  const start=e=>{ e.preventDefault(); AudioGate.unlock(); on(); };
  const end=e=>{ e.preventDefault(); off(); };
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
}


bindHold(document.getElementById('btn-up'), 
  ()=>{ 
    if (CUT.active && CUT.id==='cine2' && CUT.c2?.menu?.on){ 
      _cine2_menuUp(); 
    } else { 
      keys.up=true; 
    }
  }, 
  ()=>{ 
    if (!(CUT.active && CUT.id==='cine2' && CUT.c2?.menu?.on)){ 
      keys.up=false; 
    }
  }
);

bindHold(document.getElementById('btn-down'), 
  ()=>{ 
    if (CUT.active && CUT.c2?.menu?.on){ 
      _cine2_menuDown(); 
    } else { 
      keys.down=true; 
    }
  }, 
  ()=>{ 
    if (!(CUT.active && CUT.c2?.menu?.on)){ 
      keys.down=false; 
    }
  }
);

bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);
  
function bindPressVisual(el){
  const on=()=>el.classList.add('pressed'), off=()=>el.classList.remove('pressed');
  el.addEventListener('touchstart',e=>{e.preventDefault();on()},{passive:false});
  el.addEventListener('touchend',off,{passive:false}); el.addEventListener('touchcancel',off,{passive:false});
}
bindPressVisual(document.getElementById('btn-act'));

/* ====== TOAST ====== */
function showToast(msg, ms=1800){
  const t = document.getElementById('toast');
  t.textContent = msg; t.classList.add('show');
  clearTimeout(showToast._to);
  showToast._to = setTimeout(()=>t.classList.remove('show'), ms);
}

  
/* ====== NPCS ====== */

  
  async function preloadNPCs(){
  const entries = Object.entries(NPC_CATALOG);
  const res = await Promise.all(entries.map(([k,v]) => loadImage(v.src).then(img => [k,img])));
  res.forEach(([k,img]) => { NPC_IMAGES[k] = img; });
}

function buildNPCs(){
  NPCS = [];
  for (const [type, list] of Object.entries(NPC_PLACED)){
    const spec = NPC_CATALOG[type];
    const img  = NPC_IMAGES[type];
    if(!spec || !list?.length) continue;

    for (const p of list){
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x:p.x, y:p.y };
      const s   = spec.scale || 1;
      const npc = {
        id: p.id || `${type}_${Math.random().toString(36).slice(2,7)}`,
        type, img,
        x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth  : 32,
        ih: img ? img.naturalHeight : 32,
        scale: s,
        depthBand: spec.depthBand ?? DEPTH_BAND,
        depthAnchorY: spec.depthAnchorY ?? 0,
        flipX: (typeof p.flipX === 'boolean') ? p.flipX : !!spec.flipX,
        dialog: Array.isArray(p.dialog) ? p.dialog : null,
        dialog2: Array.isArray(p.dialog2) ? p.dialog2 : null,
        sound: p.sound ? new Audio(p.sound) : null,
        dialogBlocked: Array.isArray(p.dialogBlocked) ? p.dialogBlocked : null,
        requiresFlag: p.requiresFlag || null,
        onFire: !!p.onFire,
        patata: !!p.patata,
        faramir: !!p.faramir,
        faramir1: !!p.faramir1,
        denethor: !!p.denethor,
        muzzleOffset: spec.muzzleOffset || {x:0,y:0},
        fireFxMs: spec.fireFxMs || 120,
        _fxActive: false,
        _fxUntil: 0,
        shadow: { ...DEFAULT_SHADOW, ...(spec.shadow||{}), ...(p.shadow||{}) }
      };
      // heredar halo del catálogo y permitir override desde placement
if ((NPC_CATALOG[type] && NPC_CATALOG[type].halo) || p.halo){
  npc.halo = { ...(NPC_CATALOG[type].halo || {}), ...(p.halo || {}) };
}


      // collider opcional (bloquea como obstáculo)
      if (spec.collider){
        const c = spec.collider;
        const col = { x: npc.x + c.x*s, y: npc.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
        npc.collider = col;
        OBSTACLES.push({ ...col, name:`npc:${type}` });
      }

      // zona de interacción para abrir diálogo
      if (p.interact){
  const i = p.interact;
  npc.interacts = [{
    x: npc.x + i.x*s,
    y: npc.y + (i.y*s) - (i.h*s),
    w: i.w*s,
    h: i.h*s,
    npcRefId: npc.id,     // << clave para que el handler encuentre al NPC
    dialog: npc.dialog,
    sound: npc.sound
  }];
}
if (npc.id === 'juansin_other' && GAME_FLAGS.juansin_other_halo) {
  npc.halo = { color:'255,255,160', radius:30, alpha:0.6, pulse:0.05, offsetY:0.62 };
}
      NPCS.push(npc);
    }
  }
}


/* ====== DIÁLOGO ====== */
const dialogEl     = document.getElementById('dialog');
const dialogNameEl = document.getElementById('dialogName');
const dialogTextEl = document.getElementById('dialogText');
const dialogHintEl = document.getElementById('dialogHint');

let dialogOpen=false, isTyping=false, typingTimer=null, typingSpeed=22, dialogIndex=0;
let dialogScript = [];

  function playBeep(){
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(800, ctx.currentTime);
    gain.gain.setValueAtTime(0.05, ctx.currentTime);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.05);
  } catch(e){}
}


function openDialog(lines, startTyping=true){
  dialogScript = lines || [];
  dialogIndex = 0;
  dialogEl.classList.add('show');
  dialogEl.classList.remove('ready');
  dialogOpen = true;
  renderCurrentLine(startTyping);
}
function closeDialog(){
  dialogEl.classList.remove('show','ready');
  dialogOpen=false;

  if (initialDialogLock){
    initialDialogLock = false;
    interactBlocked = false;
  }

  if (ambientLock && ambientLockOwner){
    ambientLock = false;
    ambientLockOwner = null;
  }

  if (typeof onDialogClosed === 'function'){
    const fn = onDialogClosed;
    onDialogClosed = null;   // limpiar para que sea one–shot
    fn();
  }
}


  function closeCurrentDialogNow(){
  if (!dialogOpen) return;
  if (isTyping) advanceDialog();  // termina de escribir
  if (dialogOpen) advanceDialog(); // y cierra
}

function renderCurrentLine(startTyping=false){
  const line = dialogScript[dialogIndex] || {speaker:'', text:''};
  dialogNameEl.textContent = line.speaker || '';
  if (line.speaker === 'Juan'){
    dialogNameEl.className = 'dialog-name juan';
  } else {
    dialogNameEl.className = 'dialog-name other';
  }
  dialogTextEl.textContent = '';
  dialogHintEl.style.opacity = 0;
  if(startTyping) startTypingEffect(line.text);
  else { dialogTextEl.textContent = line.text; dialogEl.classList.add('ready'); }
}
function startTypingEffect(text){
  clearInterval(typingTimer);
  isTyping = true; let i=0;
  typingTimer = setInterval(()=>{
    if(i < text.length){
      const ch = text[i++]; dialogTextEl.textContent += ch;
      if (i % 2 === 0) playBeep();

    } else {
      clearInterval(typingTimer);
      isTyping=false; dialogEl.classList.add('ready'); dialogHintEl.style.opacity=1;
    }
  }, typingSpeed);
}
function playTownMusic(){
  Music.play("town", { volume: 0.5, fadeMs: 400 });
}

function playCombatMusic(){
  Music.play("combat", { volume: 0.5, fadeMs: 400 });
}

function stopTownMusic(){
  Music.stop({ fadeMs: 400 });
}

/* ========= MINI AUDIO MANAGER ========= */
/* ========= MINI AUDIO MANAGER ========= */
const SFX = (() => {
  const _cache = new Map();
  const _lastByName = new Map();

  function _get(path) {
    if (!_cache.has(path)) _cache.set(path, new Audio(path));
    const base = _cache.get(path);
    const a = base.cloneNode(true);
    a.preload = 'auto';
    a.playsInline = true;
    return a;
  }

  async function play(
    name,
    { volume = 1, start = 0, duration = null, folder = 'assets/sounds' } = {}
  ) {
    const a = _get(`${folder}/${name}.mp3`);
    a.volume = volume;

    const startWhenReady = () => {
      if (start > 0) a.currentTime = Math.max(0, start);
      a.play().catch(()=>{});
      if (duration && duration > 0) {
        setTimeout(() => { try { a.pause(); a.currentTime = 0; } catch(e){} }, duration * 1000);
      }
    };

    if (a.readyState >= 2) startWhenReady();
    else a.addEventListener('loadedmetadata', startWhenReady, { once:true });

    _lastByName.set(name, a); // guarda la última instancia por nombre
    return a;
  }

  function playFile(path, opts = {}) {
    const name   = path.replace(/^.*[\\/]/, '').replace(/\.\w+$/, '');
    const folder = path.replace(/\/[^/]+$/, '');
    return play(name, { ...opts, folder });
  }

  // Parar por nombre (sin variable)
  function stop(name) {
    const a = _lastByName.get(name);
    if (!a) return;
    a.pause();
    a.currentTime = 0;
  }

  // Fade out por nombre y parar
  function fadeOut(name, ms = 400) {
    const a = _lastByName.get(name);
    if (!a) return;
    const startVol = a.volume;
    const t0 = performance.now();
    (function step(now){
      const k = Math.min(1, (now - t0) / ms);
      a.volume = Math.max(0, startVol * (1 - k));
      if (k < 1) requestAnimationFrame(step);
      else { a.pause(); a.currentTime = 0; a.volume = startVol; }
    })(performance.now());
  }

  return { play, playFile, stop, fadeOut };
})();


const Music = (() => {
  const elements = {
    town:   document.getElementById('bgTown'),
    bluehour: document.getElementById('bgBluehour'),
    combat: document.getElementById('bgCombat')
  };
  let current = null, currentName = null, _fadeReq = null;

  Object.values(elements).forEach(el => el && (el.loop = true));

  function _fade(fromEl, toEl, ms = 0, targetVol = 0.5) {
    if (_fadeReq) cancelAnimationFrame(_fadeReq);
    const t0 = performance.now();
    const fromStart = fromEl ? fromEl.volume : 0;
    const toStart   = toEl   ? toEl.volume   : 0;
    toEl && (toEl.play().catch(()=>{}));

    const step = (now) => {
      const k = ms ? Math.min(1, (now - t0) / ms) : 1;
      if (fromEl) fromEl.volume = Math.max(0, fromStart * (1 - k));
      if (toEl)   toEl.volume   = toStart + (targetVol - toStart) * k;
      if (k < 1) { _fadeReq = requestAnimationFrame(step); }
      else {
        if (fromEl) { fromEl.pause(); fromEl.currentTime = 0; }
        _fadeReq = null;
      }
    };
    _fadeReq = requestAnimationFrame(step);
  }

  async function play(name, { volume = 0.5, fadeMs = 0 } = {}) {
    await AudioGate.ready();
     if (window.__lockToTown && name !== 'town') {
    name = 'town';
  }
    const next = elements[name];
    if (!next) return;

    // MISMA PISTA → solo tween de volumen (nada de mute/pausa)
    if (current === next) {
      if (fadeMs > 0) {
        _fade(null, next, fadeMs, volume); // del vol actual → target
      } else {
        next.volume = volume;
      }
      currentName = name;
      return;
    }

    // PISTA DISTINTA → crossfade normal
    const prev = current || null;
    if (!fadeMs) {
      prev && (prev.pause(), prev.currentTime = 0);
      next.volume = volume;
      next.play().catch(()=>{});
    } else {
      // ojo: NO pongas next.volume=0 si ya está sonando esa misma pista
      // (aquí no lo está, porque current !== next)
      if (next.volume === 0) { /* ok */ } else { next.volume = 0; }
      _fade(prev, next, fadeMs, volume);
    }
    current = next;
    currentName = name;
  }

  function stop({ fadeMs = 0 } = {}) {
    if (!current) return;
    if (!fadeMs) { current.pause(); current.currentTime = 0; }
    else _fade(current, null, fadeMs, 0);
    current = null; currentName = null;
  }

  return { play, stop, get current(){ return current; } };
})();

  
function advanceDialog(){
  if(!dialogOpen) return;
  const full = dialogScript[dialogIndex]?.text ?? '';
  if(isTyping){
    clearInterval(typingTimer);
    isTyping=false;
    dialogTextEl.textContent = full;
    dialogEl.classList.add('ready'); dialogHintEl.style.opacity=1;
    return;
  }
  dialogIndex++;
  if(dialogIndex < dialogScript.length){
    dialogEl.classList.remove('ready'); dialogHintEl.style.opacity=0;
    renderCurrentLine(true);
  } else {
    closeDialog();
  }
}
document.getElementById('btn-act').addEventListener('touchstart', e=>{
  e.preventDefault();

  if (!window._audioUnlocked) {
    window._audioUnlocked = true;
    if (!window._audioUnlocked) {
  window._audioUnlocked = true;
  Music.play('town', { volume: 0.5, fadeMs: 0 });
}

  }

  if (CUT.active && typeof CUT.hijackAction === 'function'){
    CUT.hijackAction();
    return;
  }

if (dialogOpen){
  const wasLast      = (dialogIndex >= dialogScript.length - 1);
  const wasIntro     = (initialDialogLock === true); 
  const willFinishNow= (!isTyping) && wasLast;      

  advanceDialog(); 

  if (willFinishNow && wasIntro) {
    window.__lockToTown = false;
    Music.play('town', { volume: 0.5, fadeMs: 400 });
  }
  return;
}

  if (interactBlocked) return;

  const npcHit = getNPCInteractHit();
  if (npcHit){
    const npc = NPCS.find(n => n.id === npcHit.npcRefId) || null;
    if (!npc) return;

    if (typeof GAME_FLAGS.denethor_finalized === 'undefined') {
      GAME_FLAGS.denethor_finalized = false;
    }

    // Casos especiales JUANSIN
    if (npc.id === 'juansin_other' && GAME_FLAGS.need_potion && !GAME_FLAGS.has_potion){
      showToast('No tienes fuerza suficiente.', 1600);
      return;
    }
    if (npc.id === 'juansin_other' && GAME_FLAGS.has_potion){
      startCinematic4();
      return;
    }
    if (npc.id === 'juansin_other' && !GAME_FLAGS.juansin_other_halo){
      npc.halo = { color:'255,255,160', radius:30, alpha:0.6, pulse:0.05, offsetY:0.62 };
      GAME_FLAGS.juansin_other_halo = true;
      npc._fxActive = true;
      npc._fxUntil  = performance.now() + 1000;
    }

    // ================== SECUENCIA FARAMIR / DENETHOR ==================
    if (npc.id === 'faramir') {
      if (!GAME_FLAGS.talked_denethor) {
        if (npc.dialogBlocked && npc.dialogBlocked.length){
          openDialog(npc.dialogBlocked, true);
        } else {
          showToast('No parece querer hablar ahora.', 1400);
        }
        return;
      }
      if (!GAME_FLAGS.denethor_finalized) {
        if (npc.dialog && npc.dialog.length){ openDialog(npc.dialog, true); }
        GAME_FLAGS.talked_faramir = true;
        return;
      }
      if (npc.dialog2 && npc.dialog2.length){ openDialog(npc.dialog2, true); }
      else { showToast('Muchacho... levántate ahí, muchacho...', 1400); }
      return;
    }

    if (npc.id === 'denethor') {
      if (!GAME_FLAGS.talked_faramir) {
        if (npc.dialogBlocked && npc.dialogBlocked.length){
          openDialog(npc.dialogBlocked, true);
          GAME_FLAGS.talked_denethor = true;
        } else {
          showToast('No parece querer hablar ahora.', 1400);
        }
        return;
      }
      if (!GAME_FLAGS.denethor_finalized) {
        if (npc.dialog && npc.dialog.length){
          openDialog(npc.dialog, true);
          const i=setInterval(()=>{ if(!dialogOpen){ clearInterval(i); _npc_swapDenethorCaido(); } },100);
        }
        GAME_FLAGS.talked_denethor    = true;
        GAME_FLAGS.denethor_finalized = true;
        return;
      }
      return;
    }

    if (npc.requiresFlag && !GAME_FLAGS[npc.requiresFlag]){
      if (npc.dialogBlocked && npc.dialogBlocked.length){ openDialog(npc.dialogBlocked, true); }
      else { showToast('No parece querer hablar ahora.', 1400); }
      return;
    }

    if (npc.dialog && npc.dialog.length){ openDialog(npc.dialog, true); }

    if (npc.onFire){
      setTimeout(() => {  triggerNPCShot(npc); }, 1500);
      GAME_FLAGS.talked_gunner = true;
    }
    if (npc.id === 'patata1') {
      if (npc.dialog) openDialog(npc.dialog, true);
      GAME_FLAGS.talked_patata1 = true;
      return;
    }
    if (npc.id === 'patata2') {
      if (!GAME_FLAGS.talked_patata1 && npc.dialogBlocked) {
        openDialog(npc.dialogBlocked, true);
        return;
      }
      if (npc.dialog) openDialog(npc.dialog, true);
      return;
    }
  }

  // Props con "say" => toast
  const propHit = getInteractHit();
  if (propHit && propHit.say){
    showToast(propHit.say, 1800);
    return;
  }
}, {passive:false});



/* ========== UTILS ========== */

let JUAN_HALO = { active:false, permanent:false, until:0, color:'80,160,255' };

function startJuanBlueHalo(ms=1000, { permanent=false } = {}){
  JUAN_HALO.active = true;
  JUAN_HALO.permanent = permanent;
  JUAN_HALO.until = permanent ? Infinity : (performance.now() + (ms|0));
}

  function spawnPotionWithHalo(){
  const spot = percentToWorld({ x: 46.3, y: 4.3 }); 

  const img = PROP_IMAGES['potion'];
  if (!img){
    console.warn('pocima img no cargada aún; reintento en 200ms');
    return setTimeout(spawnPotionWithHalo, 200);
  }
  const prop = {
    id: 'potion_' + Math.random().toString(36).slice(2,7),
    type: 'potion',
    img, x: spot.x, y: spot.y,
    iw: img.naturalWidth, ih: img.naturalHeight,
    scale: 0.12,
    // marca especial para draw + pickup
    _isPotion: true,
    _halo: { color:'80,160,255', radius:26, alpha:0.70, pulse:0.08, offsetY:0.65 }
  };
  PROPS.push(prop);
}

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const loadImage=src=>new Promise(r=>{ const i=new Image(); i.onload=()=>r(i); i.onerror=()=>{console.warn('No carga',src); r(null)}; i.src=src; });
async function preloadSprites(map){
  const out={idle:{},walk:{},size:map.size,scale:map.scale};
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
const percentToWorld=(p)=>({x:Math.round(world.w*(p.x/100)), y:Math.round(world.h*(p.y/100))});
const lerpT=(t,dt,ms)=> (ms<=0?1: Math.min(1, t + (dt*1000)/ms));
function triggerNPCShot(npc){
  npc._fxActive = true;
  npc._fxUntil  = performance.now() + npc.fireFxMs;

  // sonido si existe (mapa y sample)
  if (typeof NPC_SOUNDS !== 'undefined' && NPC_SOUNDS && NPC_SOUNDS[npc.type]) {
    const snd = NPC_SOUNDS[npc.type];
    try { snd.currentTime = 0; snd.play(); } catch(e){}
  }
}


function isNPCFxActive(npc){
  if (!npc._fxActive) return false;
  if (performance.now() > npc._fxUntil){
    npc._fxActive = false;
    return false;
  }
  return true;
}

// --------------------- FUNCIONES PORTRAITS

function _makeSide(img, side, name, slotOverride){
  // Imagen fallback por si no ha cargado
  if (!img) {
    img = { naturalWidth: 64, naturalHeight: 64 };
  }
  const maxW = Math.floor(screenRect.dw * 0.52);
  const charScale = (PORTRAIT_SCALES && PORTRAIT_SCALES[name]) ? PORTRAIT_SCALES[name] : 1;
  const useLetterbox = (PORTRAITS.layout === 'letterbox');
  const padTop = 6, padBottom = 8;

  let availH, yBottom;

  if (useLetterbox){
    // —— letterbox DENTRO del área de juego (NO en las bandas negras exteriores) ——
    const slot = slotOverride || (side === 'left' ? 'top' : 'bottom');

    // Altura de cada franja interna (ajusta a gusto: 0.40–0.48)
    const slotH = Math.round(screenRect.dh * 0.44);

    if (slot === 'top'){
      // Parte superior INTERIOR
      availH  = Math.max(0, slotH - padTop - padBottom);
      yBottom = screenRect.dy + slotH - padBottom; // borde inferior del slot superior
    } else {
      // Parte inferior INTERIOR
      availH  = Math.max(0, slotH - padTop - padBottom);
      yBottom = screenRect.dy + screenRect.dh - padBottom; // borde inferior del área de juego
    }
  } else {
    // —— diseño clásico (retrato sobre el “suelo” dentro del área de juego) ——
    const PORTRAIT_TOP_AIR = 15;     // aire por arriba
    const PORTRAIT_BOTTOM_PAD = -40; // colchón inferior (puede ser negativo)
    const yBaseBottom = screenRect.dy + screenRect.dh - PORTRAIT_BOTTOM_PAD;
    const availInGame = screenRect.dh - (PORTRAIT_TOP_AIR + PORTRAIT_BOTTOM_PAD);
    availH  = Math.max(0, availInGame);
    yBottom = yBaseBottom;
  }

  // Escala por ancho + clamp por altura disponible
  let s = Math.min(1, (maxW / img.naturalWidth)) * charScale;
  let w = Math.round(img.naturalWidth  * s);
  let h = Math.round(img.naturalHeight * s);
  if (availH > 0 && h > availH){
    s *= (availH / h);
    w = Math.round(img.naturalWidth  * s);
    h = Math.round(img.naturalHeight * s);
  }

  // Propiedades comunes del nodo
  const common = {
    img, name, side,
    w, h,
    yBottom,               // límite inferior donde “apoya” el retrato
    t:0, from:0, to:0, anim:false, onDone:null,
    alpha:0, aFrom:0, aTo:1
  };

  // Inset horizontal relativo al área de juego (queda elegante)
  const inset = Math.round(screenRect.dw * (PORTRAIT_EDGE_INSET ?? -0.12));

  if (side === 'left'){
    return {
      ...common,
      x:    screenRect.dx - w - 80,           // off-screen inicial
      inX:  screenRect.dx + inset,            // posición final dentro del juego
      outX: screenRect.dx - w - 80            // posición de salida (izquierda)
    };
  } else {
    return {
      ...common,
      x:    screenRect.dx + screenRect.dw + 80,                     // off-screen inicial
      inX:  screenRect.dx + screenRect.dw - inset - w,              // posición final dentro del juego
      outX: screenRect.dx + screenRect.dw + 80                      // salida (derecha)
    };
  }
}


function _startSlide(node, toX, cb){
  node.anim = true;
  node.t = 0;
  node.from = node.x;
  node.to = toX;
  node.onDone = (typeof cb === 'function') ? cb : null;

 if (toX === node.inX){
    node.aFrom = 0; node.aTo = 1;
    node.sFrom = 1.03; node.sTo = 1.00;   // ← entra 3% grande y asienta
  } else if (toX === node.outX){
    node.aFrom = 1; node.aTo = 0;
    node.sFrom = 1.00; node.sTo = 0.98;   // ← sale encogiendo 2%
  } else {
    node.aFrom = node.alpha ?? 1; node.aTo = node.alpha ?? 1;
    node.sFrom = node.sFrom ?? 1.00; node.sTo = node.sTo ?? 1.00;
  }
}


function _nodeForSpeaker(name){
  if (name === 'Gandalf' || name === 'SSJ' || name === 'Voldemort' || name === 'DonRamon y Perchita') return PORTRAITS.left;
  return PORTRAITS.right;
}

function portraitsOpen(script){
  PORTRAITS.active = true;
  PORTRAITS.script = script.slice();
  PORTRAITS.idx = 0;
  PORTRAITS.blurK = 0;
  PORTRAITS.stage = 'entering';

  PORTRAITS.left  = _makeSide(IMG_GANDALF,  'left',  'Gandalf');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG, 'right', 'Juan');

  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  const line0 = PORTRAITS.script[PORTRAITS.idx];
  const node0 = _nodeForSpeaker(line0.speaker);
  _startSlide(node0, node0.inX, ()=>{
    PORTRAITS.stage = 'speaking';
    openDialog([line0], true);
  });

CUT.hijackAction = () => {
  if (!PORTRAITS.active) return;
  if (!dialogOpen) return;

  if (isTyping){ advanceDialog(); return; }

  const next = PORTRAITS.script[PORTRAITS.idx+1];
  const cur  = dialogScript[dialogIndex]; // la línea actual mostrada

  if (next && cur && next.speaker === cur.speaker){
    PORTRAITS.idx++;
    dialogEl.classList.remove('ready'); dialogHintEl.style.opacity = 0;
    dialogScript = [ next ]; dialogIndex = 0;
    renderCurrentLine(true);
    return;
  }

  // 3) cambio de speaker -> flujo normal (cierra y anima)
  closeDialog();
  _nextPortraitLine();
};

}


  function portraitsOpen2(script){
  PORTRAITS.active = true;
  PORTRAITS.script = script.slice();
  PORTRAITS.idx = 0;
  PORTRAITS.blurK = 0;
  PORTRAITS.stage = 'entering';

  PORTRAITS.left  = _makeSide(IMG_FUMAOS,  'left',  'DonRamon y Perchita');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG, 'right', 'Juan');

  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  PORTRAITS.left.yBottom  -= 30;
    
  PORTRAITS.left.inX += 60;
  PORTRAITS.left.x   += 60;

  const line0 = PORTRAITS.script[PORTRAITS.idx];
  const node0 = _nodeForSpeaker(line0.speaker);
  _startSlide(node0, node0.inX, ()=>{
    PORTRAITS.stage = 'speaking';
    openDialog([line0], true);
  });

CUT.hijackAction = () => {
  if (!PORTRAITS.active) return;
  if (!dialogOpen) return;

  // 1) si está escribiendo, completar
  if (isTyping){ advanceDialog(); return; }

  // 2) ¿hay siguiente línea?
  const next = PORTRAITS.script[PORTRAITS.idx+1];
  const cur  = dialogScript[dialogIndex]; // la línea actual mostrada

  if (next && cur && next.speaker === cur.speaker){
    // MISMO SPEAKER -> NO cerrar ni animar retratos, solo cambiar texto
    PORTRAITS.idx++;
    dialogEl.classList.remove('ready'); dialogHintEl.style.opacity = 0;
    dialogScript = [ next ]; dialogIndex = 0;
    renderCurrentLine(true);
    return;
  }

  // 3) cambio de speaker -> flujo normal (cierra y anima)
  closeDialog();
  _nextPortraitLine();
};

}

function _nextPortraitLine(){
  PORTRAITS.idx++;
  if (PORTRAITS.idx >= PORTRAITS.script.length){
    _endPortraits();
    return;
  }

  const prev = PORTRAITS.script[PORTRAITS.idx-1];
  const next = PORTRAITS.script[PORTRAITS.idx];

  const prevNode = _nodeForSpeaker(prev.speaker);
  const nextNode = _nodeForSpeaker(next.speaker);

  if (prev.speaker === next.speaker){
    PORTRAITS.stage = 'speaking';
    openDialog([next], true);
    return;
  }

  // Cambio de speaker -> animación normal
  PORTRAITS.stage = 'exiting';
  _startSlide(prevNode, prevNode.outX, ()=>{
    PORTRAITS.stage = 'entering';
    _startSlide(nextNode, nextNode.inX, ()=>{
      PORTRAITS.stage = 'speaking';
      openDialog([next], true);
    });
  });
}

function _endPortraits(){
  PORTRAITS.stage = 'ending';
  const t0 = performance.now();
  const dur = PORTRAITS.blurOutMs;
  function tick(){
    const k = Math.min(1, (performance.now()-t0)/dur);
    PORTRAITS.blurK = 1 - k;
    if (k<1) requestAnimationFrame(tick);
    else {
      PORTRAITS.active = false;
      CUT.hijackAction = null;
      if (typeof CUT.onEnd === 'function') CUT.onEnd();
    }
  }
  requestAnimationFrame(tick);
}

function portraitsUpdate(dt){
  if (!PORTRAITS.active) return;

  // blur in como ya tenías
  if (PORTRAITS.stage !== 'ending' && PORTRAITS.blurK < 1){
    PORTRAITS.blurK = Math.min(1, PORTRAITS.blurK + (dt*1000)/PORTRAITS.blurInMs);
  }

  const upd = (node)=>{
    if (!node?.anim) return;
    node.t = Math.min(1, node.t + (dt*1000)/PORTRAITS.slideMs);
const k = _ease(node.t);
const kA = Math.min(1, _ease(node.t * 1.12)); // alpha ~12% más rápida
node.x = node.from + (node.to - node.from) * k;
node.alpha = node.aFrom + (node.aTo - node.aFrom) * kA;
    node.scaleTemp = (node.sFrom ?? 1) + ((node.sTo ?? 1) - (node.sFrom ?? 1)) * k;


    if (node.t>=1){
      node.anim = false;
      node.x = node.to;
      node.alpha = node.aTo;
      if (node.onDone){ const cb = node.onDone; node.onDone=null; cb(); }
    }
  };

  upd(PORTRAITS.left);
  upd(PORTRAITS.right);
}
  
// ——— BLUR SUPPORT + FALLBACK ———
function supportsCanvasFilter(){
  try{
    // Test real: dibuja un borde nítido, aplica blur y comprueba si el centro deja de ser “duro”
    const c = document.createElement('canvas');
    c.width = c.height = 40;
    const x = c.getContext('2d');

    // Fondo negro
    x.fillStyle = '#000'; x.fillRect(0,0,40,40);
    // Borde blanco de 2px
    x.fillStyle = '#fff';
    x.fillRect(0,0,40,2); x.fillRect(0,38,40,2);
    x.fillRect(0,0,2,40); x.fillRect(38,0,2,40);

    // Lee el centro ANTES
    const before = x.getImageData(20,20,1,1).data[0]; // canal R

    // Aplica blur y redibuja sobre sí mismo
    x.filter = 'blur(8px)';
    x.drawImage(c,0,0);

    // Lee el centro DESPUÉS
    const after = x.getImageData(20,20,1,1).data[0];

    // Si el blur funciona, el centro *debería* subir de 0 (negro) por sangrado de borde
    return after > before + 5; 
  }catch(e){
    return false;
  }
}

// buffer para blur barato
const _BLURBUF = document.createElement('canvas');
const _BLURCTX = _BLURBUF.getContext('2d');

// “barato”: baja resolución y la vuelves a subir para simular blur
function drawBlurFallback(srcCanvas, dstCtx, clipRect){
  const w = srcCanvas.width, h = srcCanvas.height;

  // tamaño de reducción: cuanto menor, más blur
  const scale = 0.15; // 15% → blur potente
  const tw = Math.max(2, (w*scale)|0);
  const th = Math.max(2, (h*scale)|0);

  _BLURBUF.width = tw; _BLURBUF.height = th;

  // 1) baja
  _BLURCTX.imageSmoothingEnabled = true;
  _BLURCTX.clearRect(0,0,tw,th);
  _BLURCTX.drawImage(srcCanvas, 0,0, w,h, 0,0, tw,th);

  // 2) sube (ya “lavado”)
  dstCtx.save();
  dstCtx.beginPath();
  dstCtx.rect(clipRect.dx, clipRect.dy, clipRect.dw, clipRect.dh);
  dstCtx.clip();
  dstCtx.globalCompositeOperation = 'source-over';
  dstCtx.globalAlpha = 1; // cubre totalmente lo nítido
  dstCtx.drawImage(_BLURBUF, 0,0, tw,th, 0,0, w,h);
  dstCtx.restore();
}

  
function portraitsDrawOverlay(){
  if (!PORTRAITS.active) return;

  // Asegura tamaño del backbuffer
  if (BACKBUF.width !== canvas.width || BACKBUF.height !== canvas.height){
    BACKBUF.width = canvas.width; BACKBUF.height = canvas.height;
  }

  // Copia del frame actual para aplicar blur
  BACKCTX.clearRect(0, 0, BACKBUF.width, BACKBUF.height);
  BACKCTX.drawImage(canvas, 0, 0);

  const blurPx = Math.round((PORTRAITS.blurPx || 100) * (PORTRAITS.blurK || 0));

  // —— BLUR SOLO DENTRO DEL ÁREA DE JUEGO ——
  if (supportsCanvasFilter() && !PORTRAITS.forceBlurFallback){
    ctx.save();
    ctx.beginPath();
    ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
    ctx.clip();
    ctx.filter = `blur(${blurPx}px)`;
    ctx.drawImage(BACKBUF, 0, 0);
    ctx.filter = 'none';
    ctx.restore();
  } else {
    // Fallback robusto (downsample/upsample)
    drawBlurFallback(BACKBUF, ctx, screenRect);
  }
// === Oscurecido solo en SOLO ÉPICO ===
if (PORTRAITS.soloEpic){
  const k = Math.min(1, (PORTRAITS.blurK || 0));   // mismo progreso que el blur
  const DARK_MAX = 0.55;                            // sube/baja a tu gusto

  // capa base
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = `rgba(0,0,0, ${DARK_MAX * k * 0.85})`;
  ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  // viñeta suave
  const cx = screenRect.dx + screenRect.dw/2;
  const cy = screenRect.dy + screenRect.dh/2;
  const R  = Math.hypot(screenRect.dw, screenRect.dh) * 0.6;
  const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R);
  g.addColorStop(0.00, `rgba(0,0,0, ${DARK_MAX * k * 0.10})`);
  g.addColorStop(0.70, `rgba(0,0,0, ${DARK_MAX * k * 0.35})`);
  g.addColorStop(1.00, `rgba(0,0,0, ${DARK_MAX * k * 0.55})`);
  ctx.fillStyle = g;
  ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.restore();
}

  // —— CLIP DE SEGURIDAD: nunca dibujar retratos fuera del área de juego ——
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  const drawSide = (N)=>{
    if (!N?.img) return;
    const s = N.scaleTemp ?? 1;
    const w = Math.round(N.w * s);
    const h = Math.round(N.h * s);
    const x = Math.round(N.x);
    const y = Math.round(N.yBottom - h);

    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, N.alpha ?? 1));
    if (N.flipX){
      ctx.translate(x + w/2, y);
      ctx.scale(-1, 1);
      ctx.drawImage(N.img, 0, 0, N.img.naturalWidth, N.img.naturalHeight, -w/2, 0, w, h);
    } else {
      ctx.drawImage(N.img, 0, 0, N.img.naturalWidth, N.img.naturalHeight, x, y, w, h);
    }
    ctx.restore();
  };

  drawSide(PORTRAITS.left);
  drawSide(PORTRAITS.right);
// Glow épico para overlay solo Gandalf
if (PORTRAITS.active && PORTRAITS.soloEpic && PORTRAITS.left){
  const N = PORTRAITS.left;
  const s = N.scaleTemp || 1;
  const x = Math.round(N.x + (N.w * s)/2);
  const y = Math.round(N.yBottom - (N.h * s) * 0.6);
  const R = Math.round(screenRect.dw * 0.35);
  const c = PORTRAITS.soloEpicGlow || {r:220,g:240,b:255,strength:0.9};

  const g = ctx.createRadialGradient(x,y,0,x,y,R);
  g.addColorStop(0,   `rgba(${c.r},${c.g},${c.b}, ${0.35 * (PORTRAITS.blurK||1)})`);
  g.addColorStop(0.7, `rgba(${c.r},${c.g},${c.b}, ${0.12 * (PORTRAITS.blurK||1)})`);
  g.addColorStop(1,   `rgba(${c.r},${c.g},${c.b}, 0)`);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

  ctx.restore(); // salir del clip
}




// ************************** FUNCIONES SMOKE

  function smokeRand(){
  SMOKE.seed = (SMOKE.seed * 1664525 + 1013904223) | 0;
  return ((SMOKE.seed >>> 0) / 4294967296);
}
function smokeStart(anchor){
  SMOKE.anchor = anchor ? {x:anchor.x, y:anchor.y} : null;
  SMOKE.parts.length = 0;
  SMOKE.active = !!SMOKE.anchor;
}
function spawnSmokeParticle(side = (Math.random()<0.5?'L':'R')){
  if (!SMOKE.anchor) return;
  const fromLeft = side === 'L';
  const halfW = SMOKE.areaW * 0.5;
  const halfH = SMOKE.areaH * 0.5;

  const x = fromLeft ? (SMOKE.anchor.x - halfW - 30) : (SMOKE.anchor.x + halfW + 30);
  const y = (SMOKE.anchor.y - halfH) + smokeRand() * (SMOKE.areaH);

  // centro de fuerzas = la propia ancla (ligeramente alto)
  const cx = SMOKE.anchor.x;
  const cy = SMOKE.anchor.y - halfH * 0.2;

  const r = 14 + smokeRand()*18;
  const life = 5.5 + smokeRand()*2.0;
  const alpha0 = SMOKE.baseAlpha * (0.9 + 0.25*smokeRand());

  const dir = fromLeft ? 1 : -1;
  const vx0 = ((cx - x) * 0.1 + 4*dir) / life;
  const vy0 = ((cy - y) * 0.08 + (smokeRand()-0.5)*4) / life;

  SMOKE.parts.push({
    x, y, r, life, age:0, alpha0, vx:vx0, vy:vy0,
    side: dir, phase: smokeRand()*Math.PI*2
  });
}
function smokeUpdate(dt){
  if (!SMOKE.active || !SMOKE.anchor) return;

  // emitir
  const want = SMOKE.targetDensity * dt;
  const toSpawn = Math.floor(want);
  for (let i=0;i<toSpawn;i++) spawnSmokeParticle(i%2===0?'L':'R');

  const cx = SMOKE.anchor.x;
  const cy = SMOKE.anchor.y - SMOKE.areaH*0.2;
  const yMin = SMOKE.anchor.y - SMOKE.areaH*0.5;
  const yMax = SMOKE.anchor.y + SMOKE.areaH*0.5;

  for (let i=SMOKE.parts.length-1; i>=0; i--){
    const p = SMOKE.parts[i];
    p.age += dt;
    if (p.age >= p.life){ SMOKE.parts.splice(i,1); continue; }

    const dx = cx - p.x, dy = cy - p.y;
    const len = Math.hypot(dx,dy) || 1;
    const ux = dx/len,  uy = dy/len;
    const tx = -uy,     ty = ux;

    // fuerzas
    const ax = ux*SMOKE.attract + tx*SMOKE.swirl*p.side;
    const ay = uy*SMOKE.attract + ty*SMOKE.swirl*p.side;

    // jitter
    const j = Math.sin(p.phase + p.age*SMOKE.jitterFreq*2*Math.PI) * SMOKE.jitterAmp;
    const jx = -uy * j * 0.18;
    const jy =  ux * j * 0.18;

    p.vx = p.vx*0.965 + (ax*0.035);
    p.vy = p.vy*0.965 + (ay*0.035);

    p.x += (p.vx + jx) * dt * 10;
    p.y += (p.vy + jy) * dt * 10;

    // mantener banda vertical
    if (p.y > yMax) p.vy -= 10 * dt;
    if (p.y < yMin) p.vy +=  8 * dt;
  }
}
function smokeDraw(){
  if (!SMOKE.active || !SMOKE.parts.length) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  ctx.globalCompositeOperation = 'screen';
  for (const p of SMOKE.parts){
    const k = p.age / p.life;
    const fade = (k<0.25) ? (k/0.25) : (k>0.85 ? (1-(k-0.85)/0.15) : 1);
    const alpha = p.alpha0 * fade;
    if (alpha <= 0.002) continue;

    // mundo -> pantalla
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
    const pr = p.r * Math.max(mapScaleX, mapScaleY);

    const g = ctx.createRadialGradient(px, py, 0, px, py, pr);
    g.addColorStop(0.00, `rgba(${SMOKE.color}, ${alpha})`);
    g.addColorStop(0.65, `rgba(${SMOKE.color}, ${alpha*0.6})`);
    g.addColorStop(1.00,  `rgba(${SMOKE.color}, 0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}
// ********************** FUNCIONES ARBUSTO

  // === Evento: esconderse en arbusto → aparece Gandalf Blanco desde arriba ===
const BUSH_SCENE = {
  active:false, triggered:false,
  gandalf:null, t:0, dur:3000,
  yStart:0, yEnd:0
};

function startBushHideSequence(){
  if (BUSH_SCENE.triggered) return;
  BUSH_SCENE.triggered = true;

  // Bloquear movimiento al esconderse
  ambientLock = true;

  // Tras 1s, entra Gandalf Blanco deslizándose
  setTimeout(()=>{ spawnGandalfWhiteAtPlayer(); }, 1000);
}

// ——— reemplazo completo ———
function openSoloGandalfEpic(script){
  // setup
  PORTRAITS.active = true;
  PORTRAITS.script = script.slice();
  PORTRAITS.idx = 0;
  PORTRAITS.blurK = 0;
  PORTRAITS.stage = 'speaking';
  PORTRAITS.soloEpic = true;
  PORTRAITS.soloEpicGlow = { r: 220, g: 240, b: 255, strength: 0.9 };

  const imgGW = (typeof IMG_GANDALF_WHITE_P !== 'undefined' && IMG_GANDALF_WHITE_P) ? IMG_GANDALF_WHITE_P : (IMG_GANDALF || IMG_GANDALF_WHITE);

  // crear nodo centrado sin slide-in
  const N = _makeSide(imgGW, 'left', 'Gandalf');
  const centerX = () => Math.round(screenRect.dx + (screenRect.dw - N.w)/2);
  N.x = centerX();
  N.inX = N.x; N.outX = N.x; // sin movimiento horizontal
  N.alpha = 0; N.aFrom = 0; N.aTo = 1;   // fade in
  N.sFrom = 0.98; N.sTo = 1.00;          // ligero asentamiento inicial
  PORTRAITS.left = N;
  PORTRAITS.right = { alpha:0 };

  // animación rápida de entrada (solo alpha/scale)
  (function fadeTick(t0 = performance.now(), dur = 220){
    const k = Math.min(1, (performance.now()-t0)/dur);
    const ease = _ease(k);
    N.alpha = N.aFrom + (N.aTo - N.aFrom) * ease;
    N.scaleTemp = N.sFrom + (N.sTo - N.sFrom) * ease;
    if (k < 1) requestAnimationFrame(()=>fadeTick(t0,dur));
  })();

  // abrir la única línea del solo
  const line0 = PORTRAITS.script[0];
  openDialog([line0], true);

  // zoom épico progresivo mientras habla (hasta tope)
  const maxScaleBoost = 1.20; // ~+10%
  const growMs = 4000;
  (function epicZoom(t0 = performance.now()){
    if (!PORTRAITS.active || !PORTRAITS.soloEpic) return;
    const k = Math.min(1, (performance.now()-t0)/growMs);
    const s = 1.00 + (maxScaleBoost - 1.00) * _ease(k);
    N.scaleTemp = Math.min(s, maxScaleBoost);
    if (k < 1) requestAnimationFrame(()=>epicZoom(t0));
  })();

  // control del botón Acción
  CUT.active = true; CUT.id = 'bush_epic';
  CUT.hijackAction = ()=>{
    if (dialogOpen){
      if (isTyping){ // primero autocompletar
        advanceDialog();
        return;
      }
      // si ya estaba completa, cerrar y continuar
      closeDialog();
      CUT.hijackAction = null;
      _endPortraits();
      CUT.onEnd = ()=> startGandalfWhitePortraitChain(); // tu cadena de retratos subsiguiente
    }
  };
}


function spawnGandalfWhiteAtPlayer(){
  // ===== knobs =====
  const DROP_PX     = 40;    // distancia de bajada (px mundo)
  const DURATION_MS = 4000;   // duración del slide
  const AFTER_MS    = 1000;  // espera al llegar antes de mover a Juan
  const WALK_MS     = 650;   // tiempo del autowalk de Juan hasta la X de Gandalf
  // =================

  const x     = player.x + 45;
  const yEnd  = player.y - 25;
  const yStart= yEnd - DROP_PX;

  const npc = {
    id:'gandalf_white',
    type:'gandalf_white',
    img: IMG_GANDALF_WHITE,
    x, y: yStart,
    iw: IMG_GANDALF_WHITE ? IMG_GANDALF_WHITE.naturalWidth  : 32,
    ih: IMG_GANDALF_WHITE ? IMG_GANDALF_WHITE.naturalHeight : 32,
    scale: 0.6,
    depthBand: DEPTH_BAND,
    depthAnchorY: 1,
    shadow:{ alpha:0.20, offsetY:-2, scaleX:1/3, scaleY:1/9 }
  };
  NPCS.push(npc);

  BUSH_SCENE.active = true;
  BUSH_SCENE.gandalf = npc;
  BUSH_SCENE.t = 0;
  BUSH_SCENE.dur = DURATION_MS;
  BUSH_SCENE.yStart = yStart;
  BUSH_SCENE.yEnd = yEnd;

  // Nube de niebla
  fogUseWorld({ x, y: yStart });
  fogStart();
  FOG.color = '255,255,255';
  FOG.baseAlpha = 0.06;
  FOG.targetDensity = 180;
  FOG.areaW = 120;
  FOG.areaH = 70;
  fogBeginFill({ dur:600, density:0.9, areaW:FOG.areaW, areaH:FOG.areaH });

 BUSH_SCENE._onLanded = () => {
  setTimeout(() => {
    cineAutoWalkTo(npc.x, player.y, WALK_MS, () => {
        CUT.phase = 'idle';
  player.dir = 'up';
  player.moving = false;
  player.vx = 0; player.vy = 0;
  player.frame = 0;
  player.frameTime = 0;

      openDialog([{ speaker:'Gandalf', text:'Maricona... Quiero decir...' }], true);

      CUT.active = true; CUT.id = 'bush_seq';
      CUT.hijackAction = () => {
        if (!dialogOpen){ return; }
        // MISMO TAP: cerrar “maricona…” y abrir las dos de Juan
        closeDialog();
// tras cerrar "maricona..." abrimos las dos de Juan:
openDialog([
  { speaker:'Juan', text:'??!!' },
  { speaker:'Juan', text:'¿Se puede saber dónde estabas? Llegas tarde.' }
], true);

// handler correcto: 1º completa typing, 2º avanza a la 2ª línea, 3º lanza el solo
CUT.hijackAction = () => {
  if (!dialogOpen) return;

  // 1) si está escribiendo, completar
  if (isTyping){ advanceDialog(); return; }

  // 2) si aún no estamos en la última línea, avanzar a la siguiente ("¿Se puede saber...?")
  if (dialogIndex < dialogScript.length - 1){
    advanceDialog();
    return;
  }

  // 3) ya estamos en la última línea -> cerrar y abrir el solo épico
  closeDialog();
  CUT.hijackAction = null;
  openSoloGandalfEpic([
    { speaker:'Gandalf', text:'Un mago nunca llega tarde, Johnny Barrett, ni pronto. Llega justamente cuando se lo propone.' }
  ]);
};

      };
    }, { followCam:true });
  }, AFTER_MS);
};

}


function updateBushScene(dt){
  if (!BUSH_SCENE.active || !BUSH_SCENE.gandalf) return;

  BUSH_SCENE.t = Math.min(1, BUSH_SCENE.t + (dt*1000)/BUSH_SCENE.dur);
  const k = _ease(BUSH_SCENE.t);
  BUSH_SCENE.gandalf.y = BUSH_SCENE.yStart + (BUSH_SCENE.yEnd - BUSH_SCENE.yStart)*k;

  if (FOG.space === 'world' && FOG.anchorWorld){
    FOG.anchorWorld = { x: BUSH_SCENE.gandalf.x, y: BUSH_SCENE.gandalf.y };
  }

  if (BUSH_SCENE.t >= 1){
    FOG.filling = false;
    BUSH_SCENE.active = false;
if (typeof BUSH_SCENE._onLanded === 'function'){
  const fn = BUSH_SCENE._onLanded; BUSH_SCENE._onLanded = null;
  fn();
}
  }
}


  /* ====== BUSH PULSE (arbusto que late hasta que Juan interactúa) ====== */
const BUSH_PULSE = {
  active: false,
  targetId: 'bush_hideout',
  t: 0,                 // tiempo acumulado
  speed: Math.PI * 2,   // 1 “latido” por segundo (2π rad/seg)
  base: 1.0,            // escala base (1.0 = sin cambio)
  amp: 0.04,            // amplitud del zoom (±6%)
  scale: 1.0            // escala resultante (se actualiza en update)
};

function startBushPulse(id = 'bush_hideout'){
  BUSH_PULSE.active = true;
  BUSH_PULSE.targetId = id;
  BUSH_PULSE.t = 0;
  BUSH_PULSE.scale = 1.0;
}

function stopBushPulse(){
  BUSH_PULSE.active = false;
  BUSH_PULSE.scale = 1.0;
}

// Devuelve el prop con el id del arbusto (si existe)
function getBushProp(){
  return PROPS.find(p => p.id === BUSH_PULSE.targetId) || null;
}

// ¿Juan está dentro de alguna zona de interacción del prop?
function isPlayerInsidePropInteract(prop){
  if (!prop || !prop.interacts) return false;
  for (const zone of prop.interacts){
    if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
      return true;
    }
  }
  return false;
}

function updateBushPulse(dt){
  if (!BUSH_PULSE.active) return;

  // anima escala (latido)
  BUSH_PULSE.t += dt * BUSH_PULSE.speed;           // 2π por segundo
  BUSH_PULSE.scale = BUSH_PULSE.base + Math.sin(BUSH_PULSE.t) * BUSH_PULSE.amp;

  // si Juan entra en la zona de interacción del arbusto -> parar y lanzar escena
  const prop = getBushProp();
  if (isPlayerInsidePropInteract(prop)){
    if (!BUSH_SCENE.triggered) startBushHideSequence();
    stopBushPulse();
    return;
  }
}


  
  // -------------------- FUNCIONES NIEBLA
function fogUseWorld(anchor){
  FOG.space = 'world';
  FOG.anchorWorld = anchor || { x: player.x, y: player.y - 40 };
}

function fogUseScreen(){
  FOG.space = 'screen';
  FOG.anchorWorld = null;
}

  function fogAimAhead(on=true){ FOG._aimAhead = !!on; }
function fogResetAim(){ FOG._aimAhead = false; }
  
  function fogRand(){
  FOG.seed = (FOG.seed * 1664525 + 1013904223) | 0;
  return ((FOG.seed >>> 0) / 4294967296);
}
function smoothstep(a,b,x){ x = Math.max(0, Math.min(1,(x-a)/(b-a))); return x*x*(3-2*x); }

function fogStart(){
  FOG.active = true;
  FOG.parts.length = 0;
}

function fogStop(){
  FOG.active=false;
  FOG.parts.length=0;
  FOG.filling=false; FOG.tFill=0;
}

function fogBeginFill(opts = FOG.fillDur){
  if (typeof opts === 'number'){
    FOG.fillDur = opts;
  } else if (opts && typeof opts === 'object'){
    FOG.fillDur = opts.dur ?? FOG.fillDur;
    if (opts.anchor){
      // anchor {x,y} en pantalla
      FOG.anchor = { x: opts.anchor.x, y: opts.anchor.y };
    } else {
      FOG.anchor = {
        x: screenRect.dx + screenRect.dw * 0.5,
        y: screenRect.dy + screenRect.dh * 0.25
      };
    }
    if (opts.areaW) FOG.areaW = opts.areaW;
    if (opts.areaH) FOG.areaH = opts.areaH;
    if (opts.density != null){
      FOG._densityScale = opts.density;
    }
  }

  FOG.filling = true;
  FOG.tFill   = 0;
  if (!FOG.active) fogStart();
}

function spawnFogParticle(side){
  const fromLeft = side === 'L';
  const dir = fromLeft ? 1 : -1;

  let yMin, yMax, x, cx, cy;

  if (FOG.space === 'world' && FOG.anchorWorld){
    // --- WORLD SPACE: emitir alrededor del anchorWorld y no de la cámara ---
    const halfW = (FOG.areaW || 360) * 0.5;
    const halfH = (FOG.areaH || 140) * 0.5;

    yMin = FOG.anchorWorld.y - halfH;
    yMax = FOG.anchorWorld.y + halfH;

    // emite a izquierda/derecha del área (en mundo)
    x = fromLeft ? (FOG.anchorWorld.x - halfW - 40) : (FOG.anchorWorld.x + halfW + 40);

    cx = FOG.anchorWorld.x;
    cy = FOG.anchorWorld.y - (FOG.aheadBias||0) * halfH; // empuja un poco hacia arriba

  } else {
    // --- SCREEN SPACE (como antes) ---
    const tTop    = FOG._aimAhead ? 0.00 : FOG.bandTop;
    const tBottom = FOG._aimAhead ? 0.38 : FOG.bandBottom;
    yMin = screenRect.dy + screenRect.dh * tTop;
    yMax = screenRect.dy + screenRect.dh * tBottom;

    x = fromLeft ? screenRect.dx - 60 : screenRect.dx + screenRect.dw + 60;

    cx = screenRect.dx + screenRect.dw*0.5;
    const baseCy = 0.42;
    cy = screenRect.dy + screenRect.dh * (FOG._aimAhead ? (baseCy - FOG.aheadBias) : baseCy);
  }

  const y = yMin + (yMax - yMin) * fogRand();

  const r = 16 + fogRand()*24;
  const life = 4.8 + fogRand()*1.6;
  const alpha0 = FOG.baseAlpha * (0.9 + 0.25*fogRand());

  // velocidades suaves hacia el centro
  const vx0 = ((cx - x) * 0.10 + 6*dir) / life;
  const vy0 = ((cy - y) * 0.08 + (fogRand()-0.5)*6) / life;

  // Guarda SIEMPRE las coords en MUNDO; si estás en screen-space, las convertimos en draw()
  FOG.parts.push({
    x: (FOG.space==='world') ? x : (cam.x + (x - screenRect.dx)/mapScaleX),
    y: (FOG.space==='world') ? y : (cam.y + (y - screenRect.dy)/mapScaleY),
    r, life, age:0, alpha0, vx:vx0, vy:vy0, phase: fogRand()*Math.PI*2, side: dir
  });
}


function fogUpdate(dt){
  if (!FOG.active) return;

  let spawnScale = 1;
  if (FOG.filling){
    FOG.tFill = Math.min(FOG.fillDur, FOG.tFill + dt*1000);
    const t = FOG.tFill / FOG.fillDur;
    spawnScale = smoothstep(0.0, 1.0, t);
    if (t>=1) FOG.filling = false;
  }
  const spawnRate = FOG.targetDensity * (FOG._densityScale || 1) * spawnScale;

  // emitir alternando lados
  const want = spawnRate * dt;
  const toSpawn = Math.floor(want);
  for (let i=0; i<toSpawn; i++) spawnFogParticle(i%2===0?'L':'R');

  // centro de fuerzas en MUNDO
  let cx, cy, yMin, yMax;
  if (FOG.space==='world' && FOG.anchorWorld){
    cx = FOG.anchorWorld.x;
    const halfH = (FOG.areaH || 140)*0.5;
    cy = FOG.anchorWorld.y - (FOG.aheadBias||0)*halfH;
    yMin = FOG.anchorWorld.y - halfH;
    yMax = FOG.anchorWorld.y + halfH;
  } else {
    cx = cam.x + cam.w*0.5;
    const baseCy = 0.42;
    cy = cam.y + cam.h * (FOG._aimAhead ? (baseCy - FOG.aheadBias) : baseCy);
    yMin = cam.y + cam.h * (FOG._aimAhead ? 0.00 : FOG.bandTop);
    yMax = cam.y + cam.h * (FOG._aimAhead ? 0.38 : FOG.bandBottom);
  }

  for (let i=FOG.parts.length-1;i>=0;i--){
    const p = FOG.parts[i];
    p.age += dt;
    if (p.age >= p.life){ FOG.parts.splice(i,1); continue; }

    // fuerzas
    const dx = cx - p.x, dy = cy - p.y;
    const len = Math.hypot(dx,dy) || 0.0001;
    const ux = dx/len,    uy = dy/len;
    const tx = -uy,       ty = ux;

    const ax = ux*FOG.attract + tx*FOG.swirl*p.side;
    const ay = uy*FOG.attract + ty*FOG.swirl*p.side;

    const j = Math.sin(p.phase + p.age*FOG.jitterFreq*2*Math.PI) * FOG.jitterAmp;
    const jx = -uy * j * 0.18;
    const jy =  ux * j * 0.18;

    p.vx = p.vx*0.965 + (ax*0.035);
    p.vy = p.vy*0.965 + (ay*0.035);

    p.x += (p.vx + jx) * dt * 10;
    p.y += (p.vy + jy) * dt * 10;

    // mantener banda
    if (p.y > yMax) p.vy -= 12 * dt;
    if (p.y < yMin) p.vy +=  8 * dt;
  }
}

function fogDraw(){
  if (!FOG.active || !FOG.parts.length) return;

  // centro de fuerzas en mundo (sólo para el bias de gradiente)
  const cx = (FOG.space==='world' && FOG.anchorWorld) ? FOG.anchorWorld.x : (cam.x + cam.w*0.5);
  const cy = (FOG.space==='world' && FOG.anchorWorld)
              ? (FOG.anchorWorld.y - (FOG.aheadBias||0)*( (FOG.areaH||140)*0.5 ))
              : (cam.y + cam.h*0.42);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  for (const p of FOG.parts){
    const k = p.age / p.life;
    const fade = (k<0.2) ? smoothstep(0,0.2,k) :
                 (k>0.8) ? (1 - smoothstep(0.8,1,k)) : 1;

    const alpha = p.alpha0 * fade;
    if (alpha <= 0.002) continue;

    // proyección mundo -> pantalla
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
    const pr = p.r * Math.max(mapScaleX, mapScaleY);

    // foco desplazado (engorda hacia fuera)
    const vx = p.x - cx, vy = p.y - cy;
    const len = Math.hypot(vx,vy) || 1;
    const nx = vx / len, ny = vy / len;
    const bias = FOG.oneSideBias || 0;
    const fx = px - nx * pr * bias;
    const fy = py - ny * pr * bias;

    const g = ctx.createRadialGradient(fx, fy, 0, px, py, pr);
    g.addColorStop(0.00, `rgba(${FOG.color}, ${alpha})`);
    g.addColorStop(0.65, `rgba(${FOG.color}, ${alpha*0.7})`);
    g.addColorStop(1.00, `rgba(${FOG.color}, 0)`);

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();
}




/* ========== LAYOUT / CÁMARA ========== */
function resize(){
  const sc=document.querySelector('.screen');
  canvas.width=sc.clientWidth; canvas.height=sc.clientHeight;
  const k=Math.min(canvas.width/ROOM.w, canvas.height/ROOM.h);
  screenRect.dw=ROOM.w*k; screenRect.dh=ROOM.h*k;
  screenRect.dx=(canvas.width-screenRect.dw)/2;
  screenRect.dy=(canvas.height-screenRect.dh)/2;
  cam.w=Math.max(64,Math.round(ROOM.w/ZOOM));
  cam.h=Math.max(64,Math.round(ROOM.h/ZOOM));
  mapScaleX=screenRect.dw/cam.w; mapScaleY=screenRect.dh/cam.h;
  cam.x=clamp(cam.x,0,world.w-cam.w); cam.y=clamp(cam.y,0,world.h-cam.h);
  BACKBUF.width = canvas.width; BACKBUF.height = canvas.height;
}
addEventListener('resize',resize);
function centerCameraOnPlayer(){
  cam.x=clamp(player.x-cam.w/2,0,world.w-cam.w);
  cam.y=clamp(player.y-cam.h/2,0,world.h-cam.h);
}

  function cameraPanTo(x, y, ms=1200){
  CAM_TWEEN.on = true; CAM_TWEEN.t = 0; CAM_TWEEN.dur = ms;
  CAM_TWEEN.sx = cam.x; CAM_TWEEN.sy = cam.y;
  CAM_TWEEN.ex = clamp(x, 0, world.w - cam.w);
  CAM_TWEEN.ey = clamp(y, 0, world.h - cam.h);
}


/* ========== COLISIÓN ========== */
function ellipseRectOverlap(cx, cy, rx, ry, rect){
  const qx = clamp(cx, rect.x, rect.x + rect.w);
  const qy = clamp(cy, rect.y, rect.y + rect.h);
  const dx = (cx - qx) / rx;
  const dy = (cy - qy) / ry;
  return (dx*dx + dy*dy) <= 1;
}
function anyOverlap(cx, cy){
  for(const ob of OBSTACLES) if(ellipseRectOverlap(cx, cy + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) return true;
  return false;
}

/* ========== PROPS / OBSTÁCULOS ========== */
function getInteractHit(){
  for (const pr of PROPS){
    if(!pr.interacts) continue;
    for (const zone of pr.interacts){
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
        return zone; // devolvemos la zona encontrada
      }
    }
  }
  return null;
}

  function getNPCInteractHit(){
  for (const npc of NPCS){
    if (!npc.interacts) continue;
    for (const zone of npc.interacts){
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
        return zone; // trae .dialog si existe
      }
    }
  }
  return null;
}


async function preloadCatalog(){
  const entries=Object.entries(CATALOG);
  const res=await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  res.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}
function buildPropsAndObstacles(){
  PROPS=[]; OBSTACLES=[];
  for(const [type,list] of Object.entries(PLACED)){
    const spec=CATALOG[type]; const img=PROP_IMAGES[type];
    if(!spec || !list?.length) continue;
    for (const p of list) {
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x: p.x, y: p.y };
      const prop = {
        id: p.id || `${type}_${Math.random().toString(36).slice(2,7)}`, // <<<<< NUEVO
        type, img, x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth : 32, ih: img ? img.naturalHeight : 32,
        scale: spec.scale || 1
      };

      if (spec.collider){
        const c = spec.collider, s = prop.scale;
        const col = { x: prop.x + c.x*s, y: prop.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
        prop.collider = col; OBSTACLES.push({ ...col, name: type });
      }

      const s = prop.scale;
      const srcInteract = p.interact ?? spec.interact ?? null;
      if (srcInteract){
        const inters = Array.isArray(srcInteract) ? srcInteract : [srcInteract];
        prop.interacts = inters.map(i => ({
          x: prop.x + i.x*s,
          y: prop.y + (i.y*s) - (i.h*s),
          w: i.w*s,
          h: i.h*s,
          say: (typeof i.say === 'string' ? i.say : (typeof p.say === 'string' ? p.say : null))
        }));
      }

      if (typeof p.say === 'string') prop.say = p.say;

      PROPS.push(prop);
    }
  }
  for(const o of OBSTACLE_DEFS){
    const r=(o.type==='percent') ? { ...percentToWorld(o), w:Math.round(world.w*(o.w/100)), h:Math.round(world.h*(o.h/100)) } : o;
    OBSTACLES.push({x:r.x,y:r.y,w:r.w,h:r.h,name:o.name||'extra'});
  }
}



/* ========== AMBIENTE: zonas + overlay ========== */
function buildAmbientZones(){
  const out=[];
  for (const z of AMBIENT_ZONES){
    if (z.rect?.type==='percent'){
      out.push({
        ...z,
        x: Math.round(world.w*(z.rect.x/100)),
        y: Math.round(world.h*(z.rect.y/100)),
        w: Math.round(world.w*(z.rect.w/100)),
        h: Math.round(world.h*(z.rect.h/100)),
      });
    } else out.push({...z, x:z.rect.x, y:z.rect.y, w:z.rect.w, h:z.rect.h});
  }
  return out;
}
function feetWorld(){ return { x: player.x, y: player.y + FEET_OFFSET_Y }; }
function pointInRect(px,py,r){return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;}

/* === LINTERNA: helpers + draw === */

  function freezeIdle(dir = 'up'){
  // dirección final
  player.dir = dir;

  // parar cualquier movimiento y animación
  player.moving = false;
  player.vx = 0; player.vy = 0;
  player.frame = 0; 
  player.frameTime = 0;

  // soltar teclas por si quedó algo pillado
  if (typeof KEYS !== 'undefined'){
    KEYS.up = KEYS.down = KEYS.left = KEYS.right = false;
  }

  // bandera dura para el bucle de animación
  CUT = CUT || {};
  CUT.forceIdle = true;

  // micro-debounce por si el loop pisa un frame más
  setTimeout(()=>{ player.frame = 0; player.moving = false; }, 0);
}

function unfreezeIdle(){
  if (CUT) CUT.forceIdle = false;
}


  function startGandalfWhitePortraitChain(){
  const script = [
    { speaker:'Juan',    text:'Estoy demasiado débil.' },
    { speaker:'Gandalf', text:'Tranquilo, tengo la solución.' },
    { speaker:'Gandalf', text:'He escondido una pócima en el bosque.' },
    { speaker:'Gandalf', text:'Tiene la pinta de una flor.' },
    { speaker:'Gandalf', text:'Ve y búscala. Tómatela y enfréntate a esa bestia.' },
    { speaker:'Gandalf', text:'Serás tres mil veces más poderoso.' }
  ];

  PORTRAITS.forceBlurFallback = !supportsCanvasFilter();
  const gPortrait = IMG_GANDALF_WHITE_P; // fallback
  PORTRAITS.active = true;
  PORTRAITS.script = script.slice();
  PORTRAITS.idx = 0;
  PORTRAITS.blurK = 0;
  PORTRAITS.stage = 'entering';
  PORTRAITS.soloEpic = false;

  // Lados
  PORTRAITS.left  = _makeSide(gPortrait,    'left',  'GandalfW');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG, 'right', 'Juan');
  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  const first = PORTRAITS.script[0];
  const node0 = _nodeForSpeaker(first.speaker);
  _startSlide(node0, node0.inX, ()=>{
    PORTRAITS.stage = 'speaking';
    openDialog([first], true);

    CUT.active = true; CUT.id = 'bush_chain';
CUT.hijackAction = ()=>{
  if (!dialogOpen) return;
  if (isTyping){ advanceDialog(); return; }

  const next = PORTRAITS.script[PORTRAITS.idx+1];
  const cur  = dialogScript[dialogIndex];

  if (next && cur && next.speaker === cur.speaker){
    PORTRAITS.idx++;
    dialogEl.classList.remove('ready'); dialogHintEl.style.opacity = 0;
    dialogScript = [ next ]; dialogIndex = 0;
    renderCurrentLine(true);
    return;
  }

  closeDialog();
  _nextPortraitLine();
};

  });

// Al terminar TODAS las líneas, fade out + desaparición
CUT.onEnd = ()=>{
  fadeOutFogAndGandalf(()=>{ 
    ambientLock = false;
    CUT.active = false; CUT.id=null; CUT.hijackAction=null; CUT.onEnd=null;

    // === NUEVO: activar objetivo y spawnear pócima ===
    GAME_FLAGS.need_potion = true;
    GAME_FLAGS.has_potion  = false;
    spawnPotionWithHalo();           // crea la pócima en el mapa
  });
};

}

function fadeOutFogAndGandalf(done){
  const npc = NPCS.find(n=>n.id==='gandalf_white');
  const t0 = performance.now(), dur = 800;

  function tick(){
    const k = Math.min(1, (performance.now()-t0)/dur);
    FOG.tFill = (1 - k) * FOG.tFill; 
    if (npc) npc._fadeAlpha = 1 - k; 

    if (k < 1){
      requestAnimationFrame(tick);
    } else {
      fogStop();
      if (npc){
        const i = NPCS.indexOf(npc);
        if (i>=0) NPCS.splice(i,1);
      }
      if (typeof done==='function') done();
    }
  }
  requestAnimationFrame(tick);
}

function dirToAngle(dir){
  switch(dir){
    case 'up': return -Math.PI/2;
    case 'down': return  Math.PI/2;
    case 'left': return  Math.PI;
    case 'right': return  0;
    default: return 0;
  }
}

function drawFlashlightEnhance(){
  if (!LIGHT.enabled) return;

  // tamaño y posición del jugador en pantalla
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);

  const t = performance.now() * 0.003;
  const flick = 1 + (Math.sin(t*2.3)+Math.sin(t*1.7))*0.5*LIGHT.flicker;

  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = LIGHT.brightness;

  // halo circular
  if (LIGHT.mode === 'circle' || LIGHT.mode === 'both'){
    const baseR = LIGHT.radius * Math.max(mapScaleX, mapScaleY);
    const R = baseR * flick;
    const inner = R * (1 - LIGHT.feather);
    const g = ctx.createRadialGradient(jx, jy, inner, jx, jy, R);
    g.addColorStop(0.00, `rgba(${LIGHT.tint}, 0.95)`);
    g.addColorStop(0.50, `rgba(${LIGHT.tint}, 0.35)`);
    g.addColorStop(1.00,  'rgba(255,255,255, 0.00)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(jx, jy, R, 0, Math.PI*2); ctx.fill();
  }

  // haz cónico
  if (LIGHT.mode === 'cone' || LIGHT.mode === 'both'){
    const ang = dirToAngle(player.dir);
    const len = LIGHT.coneLen * Math.max(mapScaleX, mapScaleY);
    const half = LIGHT.coneWidth * 0.5;

    ctx.save();
    ctx.translate(jx, jy);
    ctx.rotate(ang);

    const lg = ctx.createLinearGradient(0, 0, len, 0);
    lg.addColorStop(0.00, `rgba(${LIGHT.tint}, 0.70)`);
    lg.addColorStop(0.25, `rgba(${LIGHT.tint}, 0.38)`);
    lg.addColorStop(1.00,  'rgba(255,255,255, 0.00)');
    ctx.fillStyle = lg;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(len,  Math.tan(half)*len);
    ctx.lineTo(len, -Math.tan(half)*len);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  ctx.restore();
}

/* Gradientes por paleta */
function makePaletteGradient(palette){
  const g = ctx.createLinearGradient(screenRect.dx, screenRect.dy, screenRect.dx, screenRect.dy + screenRect.dh);
  if (palette === 'bluehour'){
    g.addColorStop(0.00, '#0A516B');
    g.addColorStop(0.50, '#164D8C');
    g.addColorStop(1.00, '#0C3F62');
    return { gradient:g, mode:'multiply', alpha:0.85 };
  }
  if (palette === 'hell'){
    // Evitamos rojo puro con multiply (apagaba todo). Usamos screen y tonos cálidos.
    g.addColorStop(0.00, '#EB9460');
    g.addColorStop(0.55, '#DF5800');
    g.addColorStop(1.00, '#DF5800');
    return { gradient:g, mode:'multiply', alpha:0.45 };
  }
  // peach (base)
  g.addColorStop(0.00, '#FB557C');
  g.addColorStop(0.55, '#FB557C');
  g.addColorStop(1.00, '#DF5800');
  return { gradient:g, mode:'multiply', alpha:0.65 };
}

function drawPalette(palette, alphaScale){
  if (alphaScale <= 0) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  const { gradient, mode, alpha } = makePaletteGradient(palette);
  ctx.globalCompositeOperation = mode;
  ctx.globalAlpha = Math.min(1, alpha * alphaScale);
  ctx.fillStyle = gradient;
  ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  ctx.restore();
}

  // ========== CINEMÁTICA 1 ==========
function startCinematic1(){
  CUT.active = true; CUT.id='cine1'; CUT.phase='lock';
  ambientLock = true; player.moving=false;

  setTimeout(() => {
    openDialog([{speaker:'Juan', text:'...'},{speaker:'Juan', text:'Algo pasa...'}], true);
  }, 1000);
  


  CUT.hijackAction = ()=>{
    closeCurrentDialogNow();
    CUT.hijackAction = null;
     setTimeout(()=>{
    if (CUT.active && CUT.id==='cine1'){ 
      phaseFogFill();
    }
  }, 1000);
};
  }
function phaseQuestionThenWalk(){
  CUT.phase = 'question';
  openDialog([{ speaker:'Juan', text:'...?' }], true);

  CUT.hijackAction = ()=>{
    if (dialogOpen) closeDialog();
    CUT.hijackAction = null;
    phaseJuanAutoWalk();
  };
}

  
function phaseFogFill(){
  CUT.phase='fogFill';

  const g = NPCS.find(n => n.id === 'gandalf_temp');
  const anchorWorld = g
    ? { x: g.x, y: g.y - 45 }
    : { x: player.x, y: cam.y + cam.h*0.25 };

  fogUseWorld(anchorWorld); 

  if (Music.current) {
  Music.current.volume = 0.1;
}
  
  SFX.play("niebla", { volume: 0.35 });
  fogBeginFill({
    dur: 3000,
    areaW: 360,
    areaH: 140,
    density: 1.0
  });

  const check = ()=>{
  if (FOG.filling){
    requestAnimationFrame(check);
  } else {
    CUT.phase = 'prePanDelay';
    setTimeout(()=>{
      if (CUT.active && CUT.id==='cine1'){ 
        phaseCameraPan();
      }
    }, 3700);
  }
};
requestAnimationFrame(check);
}



function phaseCameraPan(){
  CUT.phase='pan';
  const targetY = clamp(cam.y - 70, 0, world.h - cam.h);
  

  cameraPanTo(cam.x, targetY, 1200);
  spawnTempGandalfAhead(targetY);

  const waitPan = setInterval(()=>{
    if (!CAM_TWEEN.on){
      clearInterval(waitPan);

      CUT.phase = 'preWalkDialog';
      phaseQuestionThenWalk();
    }
  }, 16);
}


function spawnTempGandalfAhead(targetCamY){
  const gx = player.x;
  const gy = targetCamY + cam.h/2 - 35; 
  const iw = IMG_GANDALF_SMALL ? IMG_GANDALF_SMALL.naturalWidth  : 32;
  const ih = IMG_GANDALF_SMALL ? IMG_GANDALF_SMALL.naturalHeight : 32;

  const npc = {
    id:'gandalf_temp', type:'gandalf_temp', img: IMG_GANDALF_SMALL,
    x: gx, y: gy, iw, ih,
    scale: 0.5,           
    depthBand: DEPTH_BAND, depthAnchorY: 1,
    _debug: true             
  };

  NPCS.push(npc);
}

  function phaseJuanAutoWalk(){
  CUT.phase='autowalk';
  const targetY = cam.y + cam.h/2;
  const startY  = player.y;
  const dy = targetY - startY;
  CUT.autoDir = (dy >= 0) ? 'down' : 'up';
  const dur = Math.max(400, Math.min(1200, Math.abs(dy)*16));
  const t0  = performance.now();

  (function step(){
    if (!CUT.active || CUT.id!=='cine1') return;
    const t = Math.min(1, (performance.now()-t0)/dur);
    player.y = startY + dy*t;
    if (t<1) requestAnimationFrame(step);
    else phaseWorldDialogue();
  })();
}
  
  function phaseWorldDialogue(){
  CUT.phase='worldTalk';
  const script = [
    {speaker:'???',  text:'Hola, muchacho...'},
    {speaker:'Juan', text:'¡Yias! Pero si tu eres...'},
    {speaker:'???', text:'En efecto.'}
  ];

  openDialog(script, true);
  onDialogClosed = ()=>{
    CUT.hijackAction = null;
    phasePortraits();
  };

  CUT.hijackAction = ()=>{
    if (dialogOpen){
      advanceDialog();
    }
  };
}

  function phasePortraits(){
  CUT.phase='cineOverlay';
  const cineScript = [
    { speaker:'Gandalf', text:'Soy Gandalf el Gris, enviado para oponerme a la Sombra.' },
    { speaker:'Juan',    text:'¡La pinga!' },
    { speaker:'Gandalf',    text:'Chico, traigo malas noticias. La sombra crece.' },
    { speaker:'Gandalf',    text:'Los malvados han cruzado desde el norte y han traído corrupción a la ciudad.' },
    { speaker:'Gandalf',    text:'El pueblo ya no es seguro.' },
    { speaker:'Gandalf',    text:'Su base se oculta en el supermercado.' },
    { speaker:'Gandalf',    text:'Necesito tu ayuda para detenerlos.' },
    { speaker:'Juan',    text:'¿La mía? ¿Por qué yo?' },
    { speaker:'Gandalf',    text:'Lo siento, demasiadas preguntas. Los primeros ya están aquí.' },
    { speaker:'Gandalf',    text:'Te estaré observando de cerca. Tal vez hoy la suerte nos mire… o tal vez no.' }
  ];
  portraitsOpen(cineScript);
    CUT.onEnd = () => {
  SFX.fadeOut("niebla", 1000);  
  continueCine1_WithFumaos_Portraits();
};
}

function portraitsAppendAndContinue(extra){
  if (!PORTRAITS.active || !Array.isArray(extra) || !extra.length) return;
  PORTRAITS.script.push(...extra);
  if (!dialogOpen){
    const next = PORTRAITS.script[PORTRAITS.idx+1];
    if (next){
      PORTRAITS.idx++;
      openDialog([next], true);
    }
    return;
  }
  CUT.hijackAction && CUT.hijackAction();
}

  
function continueCine1_WithFumaos_Portraits(doneCb){
  if (!CUT.active || CUT.id!=='cine1') { if (typeof doneCb==='function') doneCb(); return; }

  const fumaosScript = [
    { speaker:'DonRamon y Perchita', text:'Hermano... ¿no ves mogollón de pitufitos volando por todas partes?' },
    { speaker:'DonRamon y Perchita', text:'Shh...' },
    { speaker:'Juan',  text:'¿Están bien?' },
    { speaker:'DonRamon y Perchita', text:'¿Pero quién es este payaso?' },
    { speaker:'DonRamon y Perchita', text:'¿Tú qué eres? ¿El sheriff del barrio?' },
    { speaker:'Juan', text:'Fuertes gilipollas...' },
    { speaker:'DonRamon y Perchita', text:'¿A quién llamas tú gilipollas?' },
  ];

  fadeOutFogThenEnd();
  portraitsOpen2(fumaosScript);


  CUT.onEnd = ()=>{

    _cine1_startFakeFightUI();

      const koScript_1 = [
        { speaker:'DonRamon y Perchita', text:'Acércate que te vamos a dar una que vas a viajar en el tiempo.' },
        { speaker:'', text:'No te da tiempo a realizar ningún ataque.' }
      ];
      portraitsAppendAndContinue(koScript_1);


      CUT.onEnd = ()=>{

        HPBARS.setTargets(100, 0);  

          const koScript_2 = [
            { speaker:'', text:'Van tan volados que se han autoderrotado.' }
          ];
          portraitsAppendAndContinue(koScript_1);

          // 5) Cierre UI, fin de cine, callback
          CUT.onEnd = ()=>{
            _cine1_stopFakeFightUI();
            endCine();
            if (typeof doneCb === 'function') doneCb();
          };

      };
  };
}

function _cine1_startFakeFightUI(){
  HPBARS.leftName  = 'Drogadictos';
  HPBARS.rightName = 'Juan';
  HPBARS.alpha = 0;
  HPBARS.show(100, 100);

  const t0 = performance.now();
  const dur = 400;
  function step(t){
    const k = Math.min(1, (t - t0) / dur);
    HPBARS.alpha = k;
    if (k < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}



function _cine1_stopFakeFightUI(){
  if (typeof _cine2_stopFightUI === 'function'){
    try { _cine2_stopFightUI(); return; } catch(e){}
  }
  if (typeof stopFightUI === 'function'){
    try { stopFightUI(); return; } catch(e){}
  }
  if (window.HUD){
    HUD.showHPBars = false;
    delete HUD.tempEnemies;
  }
}


function fadeOutFogThenEnd(){
  CUT.phase='fadeFog';
  let t0 = performance.now(), dur=3000;
  function tick(){
    if (!CUT.active || CUT.id!=='cine1') return;
    const k = Math.min(1, (performance.now()-t0)/dur);

    FOG.tFill = (1 - k) * FOG.tFill;

    for (const p of FOG.parts) {}
    if (k<1) requestAnimationFrame(tick);
    else {
      fogStop();
      const i = NPCS.findIndex(n=>n.id==='gandalf_temp');
      if (i>=0) NPCS.splice(i,1);
      
    }
  }
  requestAnimationFrame(tick);
}
function endCine(){
  HPBARS.hide();
  CUT.active=false; CUT.id=null; CUT.phase=null; CUT.hijackAction=null; CUT.onEnd=null;
  ambientLock=false;
}

function endCine3(){
  CUT.active=false; CUT.id=null; CUT.phase=null; CUT.hijackAction=null; CUT.onEnd=null;
  ambientLock=false;
}

  // **************************** CINEMATICA 2
function startCinematic2(){
  CUT.active = true; CUT.id='cine2'; CUT.phase='lock';
  ambientLock = true; player.moving=false;

  setTimeout(() => {
    openDialog([{speaker:'???', text:'¿Quién osa interrumpir mi eterno silencio?'}], true);
    CUT.hijackAction = step2;
  }, 1000);
  
function step2() {
  if (!dialogOpen) return;             
  if (isTyping) { advanceDialog(); return; }

  closeDialog();
  CUT.hijackAction = null;

  const v  = _cine2_getVold();
  const tx = v ? (v.x - 25) : player.x;
  const ty = v ?  v.y  - 14    : player.y;

  cine2AutoWalkTo(tx, ty, 700, () => {
    if (v) player.dir = (player.x < v.x) ? 'right' : 'left';
    step3();
  });
}

   function step3() {
      openDialog([{ speaker: 'Juan', text: '¿Y tú quién eres?' }], true);
      CUT.hijackAction = () => {
        if (isTyping) return advanceDialog();
        closeDialog();

        openDialog([{ speaker: '???', text: 'Adivina.' }], true);
        CUT.hijackAction = () => {
          if (isTyping) return advanceDialog();
          closeDialog();

          openDialog([{ speaker: 'Juan', text: 'No tengo tiempo.' }], true);
          CUT.hijackAction = () => {
            if (isTyping) return advanceDialog();
            closeDialog();
            CUT.hijackAction = null;
            setTimeout(step4, 1000);
          };
        };
      };
    }
  
  function step4() {
      _cine2_swapVoldProfileToFront();
      SFX.play("risa",{start: 0.5, duration: 2});
      openDialog([{ speaker: 'Voldemort', text: '¡SOY LORD VOLDEMORT!' }], true);
      CUT.hijackAction = () => {
        if (isTyping) return advanceDialog();
        closeDialog();

        openDialog([{ speaker: 'Juan', text: 'Buena, va.' }], true);
      CUT.hijackAction = () => {
        if (isTyping) return advanceDialog();
        closeDialog();
        step5();
      };
      };
    }

      function step5() {
        _cine2_openPortraits();
        
}
  
}


  function _cine2_startFightUI(){

    PORTRAITS.right.img = IMG_JUAN_FIGHT;
    HPBARS.leftName  = 'Voldemort';
    HPBARS.rightName  = 'Juan';
    HPBARS.alpha  = 0; 
    HPBARS.show(100, 100);

    const t0 = performance.now();
    const dur = 400;
    function step(t){
      const k = Math.min(1, (t - t0) / dur);
      HPBARS.alpha = k;
      if (k < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

openDialog([{ speaker: '', text: '¿Cómo quieres atacar?' }], true);

CUT.hijackAction = () => {
  if (isTyping) return advanceDialog();

  _cine2_openMenu();

  CUT.hijackAction = () => {
    const choice = _cine2_menuConfirm();
    if (choice < 0) return;
    closeDialog();
    _cine2_closeMenu();

    const R = PORTRAITS.right;
    const L = PORTRAITS.left;
    const mid  = R.inX - Math.round(screenRect.dw * 0.04);
    const back = R.inX;

    R.sFrom = 1.00; R.sTo = 1.06;
    SFX.play("ataque");
    _startSlide(R, mid, () => {
      R.sFrom = 1.06; R.sTo = 1.00;
      _startSlide(R, back, () => {
_startSlide(R, R.outX, () => {
        
      L.x = L.outX; 
    _startSlide(L, L.inX, () => {
      const orig = L.inX;
      const kick = orig + Math.round(screenRect.dw * 0.02);
    
      L.sFrom = 1.00; L.sTo = 0.96;
      _startSlide(L, kick, () => {
        HPBARS.setTargets(100, 50);
        L.sFrom = 0.96; L.sTo = 1.00;
_startSlide(L, orig, () => {
  openDialog([{ speaker:'Voldemort', text:'Me las pagarás.' }], true);
CUT.hijackAction = () => {
        if (isTyping) return advanceDialog();
        closeDialog();
venganzaVoldemort();
};
    });

      });
    });
        });
      }); 
    });
  };
};
}


  function _cine2_closePortraitsAndOverlay(done){

  const L = PORTRAITS.left, R = PORTRAITS.right;
  let pending = 0;
  const next = ()=>{ if (--pending<=0){ PORTRAITS.active=false; if (typeof done==='function') done(); } };

  if (L){ pending++; _startSlide(L, L.outX, next); }
  if (R){ pending++; _startSlide(R, R.outX, next); }

  if (pending===0) { if (typeof done==='function') done(); }
  HPBARS.hide(); 
  try{
    const ov = document.getElementById('portrait-overlay') || document.querySelector('.portrait-overlay');
    if (ov){ ov.style.opacity = '0'; setTimeout(()=>{ ov.style.display='none'; }, 220); }
    if (PORTRAITS.overlayAlpha !== undefined) PORTRAITS.overlayAlpha = 0;
  }catch(e){}
}

  function venganzaVoldemort(){
    let handled = false;
    const v = NPCS.find(n => n?.id === 'voldemort_perfil');
    v.img = IMG_VOLD_PERFIL; 
    _cine2_closePortraitsAndOverlay(() => {
      const vold = _cine2_getVold();
      setTimeout(() => {
          if (handled) return;
          playVoldemortRayFx(vold);
          openDialog([{ speaker:'Voldemort', text:'¡Avada Kedavra!' }], true);
      }, 1000);
          
    CUT.hijackAction = () => {
      if (handled) return;
      if (isTyping) return advanceDialog();
      handled = true;

      closeDialog();
      CUT.hijackAction = null;
      _cine2_continueFight(); 
    };
    });   
  }
  
 function _cine2_continueFight(){

  PORTRAITS.active = true;
  PORTRAITS.stage  = 'entering';
  PORTRAITS.idx    = 0;
  PORTRAITS.blurK  = 0;
  PORTRAITS.script = Array.isArray(PORTRAITS.script) ? PORTRAITS.script : [];

  PORTRAITS.left  = _makeSide(IMG_VOLD_P,  'left',  'Voldemort');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG,'right', 'Juan');

  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  // Pequeño offset que tú añadías
  PORTRAITS.left.inX += 60;
  PORTRAITS.left.x   += 60;

  // --- Barras de vida ---
  HPBARS.leftName  = 'Voldemort';
  HPBARS.rightName = 'Juan';
  HPBARS.alpha = 0;
  HPBARS.show(100, 50);

  {
    const t0 = performance.now();
    const dur = 400;
    function step(t){
      const k = Math.min(1, (t - t0) / dur);
      HPBARS.alpha = k;
      if (k < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  const R = PORTRAITS.right; // Juan
  R.x = R.outX;

  _startSlide(R, R.inX, () => {
    const orig = R.inX;
    const kick = orig + Math.round(screenRect.dw * 0.02);

    R.sFrom = 1.00; R.sTo = 0.96;
    _startSlide(R, kick, () => {
      HPBARS.setTargets(10, 50); // ← Ajusta orden si tu implementación es al revés
      R.sFrom = 0.96; R.sTo = 1.00;

        _startSlide(R, orig, () => {
        openDialog([{ speaker:'', text:'Ha sido un golpe duro. Remata esto.' }], true);

        CUT.hijackAction = () => {
          if (isTyping){ advanceDialog(); return; }
          closeDialog();
          openDialog([{ speaker:'', text:'¿Cómo quieres atacar?' }], true);
          let _c4_started = false;
          
  CUT.hijackAction = () => {
    if (isTyping){ advanceDialog(); return; }
    
          _cine2_openMenu();

          CUT.hijackAction = () => {
            if (_c4_started) return;
            const choice = _cine2_menuConfirm();
            if (choice < 0) return; // no elegido aún
            _c4_started = true;
            
            closeDialog();
            _cine2_closeMenu();

            const L = PORTRAITS.left; // Voldemort
            const mid  = R.inX - Math.round(screenRect.dw * 0.04);
            const back = R.inX;

            // Anim de "carga" de Juan antes de atacar
            R.sFrom = 1.00; R.sTo = 1.06;
            _startSlide(R, mid, () => {
              R.sFrom = 1.06; R.sTo = 1.00;
              _startSlide(R, back, () => {

                _startSlide(R, R.outX, () => {
                  L.x = L.outX;
                  _startSlide(L, L.inX, () => {
                    const origL = L.inX;
                    const kickL = origL + Math.round(screenRect.dw * 0.02);

                    L.sFrom = 1.00; L.sTo = 0.96;
                    _startSlide(L, kickL, () => {
                      HPBARS.setTargets(10, 0); // ← Voldemort pierde 50; ajusta si tu orden difiere
                      L.sFrom = 0.96; L.sTo = 1.00;

                      _startSlide(L, origL, () => {
                        // -- REEMPLAZA desde aquí --
openDialog([{ speaker:'Voldemort', text:'No puede ser.' }], true);
_cine3_removeVoldFromMap();
CUT.hijackAction = () => {
  if (isTyping){ advanceDialog(); return; }
  closeDialog();

const L = PORTRAITS.left;
const startY = (L.y ?? 0);
const endY   = startY + Math.round(screenRect.dh * 0.8); // resbala ~80% de alto
const t0 = performance.now();
const dur = 550;

function fallStep(t){
  const k = Math.min(1, (t - t0) / dur);
  L.y = startY + (endY - startY) * k;
  if (k < 1){
    requestAnimationFrame(fallStep);
  }else{
    endCine2(); // ← cuando termina la caída, cerramos cine2
  }
}
requestAnimationFrame(fallStep);
};
                      });
                    });
                  });
                });
              });
            });
          };
  };
        };
      });
    });
  });
}


function endCine2(){ 
  CUT.active=false; 
  CUT.id=null; 
  CUT.phase=null; 
  CUT.hijackAction=null; 
  CUT.onEnd=null; 
  ambientLock=false; 
      _cine2_closePortraitsAndOverlay(() => {
openDialog([{ speaker:'Juan', text:'Pues ya estaría.' }], true); 
  CUT.hijackAction = () => { 
    if (isTyping){ advanceDialog(); 
                  return; } 
    closeDialog(); 
    CUT.hijackAction = null;
  }; 
    });   
}

  

// ========== FX rayo verde desde Voldemort hacia la izquierda ==========
function playVoldemortRayFx(fromNpc){
  const ray = document.getElementById('rayFx'); if(!ray) return;

  const px = screenRect.dx + (fromNpc.x - cam.x) * mapScaleX + 4;
  const py = screenRect.dy + (fromNpc.y - cam.y) * mapScaleY - 14; // altura aprox manos
  const len = 44;
  ray.style.left = (px|0) + 'px';
  ray.style.top  = (py|0) + 'px';
  ray.style.transform = `translateX(0) rotate(0deg) scaleX(0)`;
  ray.style.width = len + 'px';
  ray.style.display = 'block';

  ray.animate([{ transform:`translateX(0) scaleX(0)` }, { transform:`translateX(-${len}px) scaleX(1)` }], { duration: 320, easing:'ease-out' });
  setTimeout(()=>{ ray.style.display='none'; }, 360);
}



  function _cine2_openMenu(){
  const el = document.getElementById('attackMenu');
  if (!el) return;
  el.style.display = 'block';
  CUT.c2 = CUT.c2 || {};
  CUT.c2.menu = { idx: 0, on: true };
  _cine2_menuRender();
}

function _cine2_closeMenu(){
  const el = document.getElementById('attackMenu');
  if (el) el.style.display = 'none';
  if (CUT.c2 && CUT.c2.menu){ CUT.c2.menu.on = false; }
}

function _cine2_menuUp(){ if (CUT.c2?.menu?.on){ CUT.c2.menu.idx = (CUT.c2.menu.idx + 1) % 2; _cine2_menuRender(); } }
function _cine2_menuDown(){ if (CUT.c2?.menu?.on){ CUT.c2.menu.idx = (CUT.c2.menu.idx + 1) % 2; _cine2_menuRender(); } }
function _cine2_menuConfirm(){ return CUT.c2?.menu?.on ? CUT.c2.menu.idx : -1; }

function _cine2_menuRender(){
  const idx = CUT.c2.menu.idx|0;
  const o0 = document.getElementById('atkOpt0'), o1 = document.getElementById('atkOpt1');
  const mark = (el, sel)=> { if(!el) return; el.textContent = (sel?'► ':'  ') + el.textContent.replace(/^. /,''); };
  if (o0 && o1){
    o0.textContent = '  Bola de energía';
    o1.textContent = '  Puñetazo';
    mark(o0, idx===0); mark(o1, idx===1);
  }
}

  
  function fightSetBars({leftName, rightName, leftHP=100, rightHP=100, leftColor, rightColor}={}){
  if(leftName  != null) HPBARS.leftName  = leftName;
  if(rightName != null) HPBARS.rightName = rightName;
  if(leftColor != null) HPBARS.leftColor = leftColor;
  if(rightColor!= null) HPBARS.rightColor= rightColor;
  HPBARS.ssj  = leftHP;
  HPBARS.juan = rightHP;
}
  
function _cine2_openPortraits(){ 
const script = [ 
{ speaker:'Voldemort', text:'No entiendes la magnitud de tu error al cruzarte conmigo.' }, 
{ speaker:'Juan', text:'Hermano, no me cuentes rollos. Yo voy al super.' }, 
{ speaker:'Voldemort', text:'No sin antes recibir tu sentencia de muerte.' }, 
{ speaker:'Juan', text:'Omaigos...' } ]; 

PORTRAITS.active = true; 
PORTRAITS.script = script.slice(); 
PORTRAITS.idx = 0; PORTRAITS.blurK = 0; 
PORTRAITS.stage = 'entering'; 
PORTRAITS.left = _makeSide(IMG_VOLD_P, 'left', 'Voldemort'); 
PORTRAITS.right = _makeSide(IMG_JUAN_BIG, 'right', 'Juan'); 
PORTRAITS.left.x = PORTRAITS.left.outX;
PORTRAITS.right.x = PORTRAITS.right.outX; 
PORTRAITS.left.inX += 60;
PORTRAITS.left.x   += 60;

const line0 = PORTRAITS.script[PORTRAITS.idx]; 
const node0 = _nodeForSpeaker(line0.speaker); 

_startSlide(node0, node0.inX, ()=>{ PORTRAITS.stage = 'speaking'; 

openDialog([line0], true); }); 

CUT.hijackAction = () => { if (!PORTRAITS.active) return; 

if (!dialogOpen) return; 
if (isTyping){ advanceDialog(); return; } 

const next = PORTRAITS.script[PORTRAITS.idx+1]; 
const cur = dialogScript[dialogIndex]; 

if (next && cur && next.speaker === cur.speaker){ 

PORTRAITS.idx++; dialogEl.classList.remove('ready'); 

dialogHintEl.style.opacity = 0; dialogScript = [ next ]; 
dialogIndex = 0; renderCurrentLine(true); return; } 

                          
  if (next){
    closeDialog();
    _nextPortraitLine();
  }else{
    // Fin del guion: pasar a la lucha
    if (dialogOpen) closeDialog();

    CUT.hijackAction = null;      // ya no secuestramos el botón
    _cine2_startFightUI();
  }
                         
}; 


}
  
function _cine2_swapVoldProfileToFront(){
  const npc = NPCS.find(n => n?.id === 'voldemort_perfil');
  if (npc && IMG_VOLD_FRONT){
    npc.img = IMG_VOLD_FRONT;                  // usar el nuevo Image
    npc.iw  = IMG_VOLD_FRONT.naturalWidth;     // ancho real
    npc.ih  = IMG_VOLD_FRONT.naturalHeight;    // alto real
  }
}

  function _npc_swapDenethorCaido(){
  const npc = NPCS.find(n => n?.id === 'denethor');
  if (npc && IMG_DENETHOR_CAIDO){
    npc.img = IMG_DENETHOR_CAIDO;                  // usar el nuevo Image
    npc.iw  = IMG_DENETHOR_CAIDO.naturalWidth;     // ancho real
    npc.ih  = IMG_DENETHOR_CAIDO.naturalHeight;    // alto real
  }
}


function _cine2_getVold(){
  let v = NPCS.find(n => n?.id === 'voldemort_perfil');
  return v || null;
}

  

function cine2AutoWalkTo(targetX, targetY, ms, onDone, { followCam = true, stepPeriodMs = 120 } = {}){
  CUT.phase = 'autowalk';
  const sx = player.x, sy = player.y;
  const t0 = performance.now();
  const dur = Math.max(200, ms|0);

  if (!Number.isFinite(player.frameTime)) player.frameTime = 0;
  if (!Number.isFinite(player.frame)) player.frame = 0;

  const face = ()=>{
    const dx = targetX - player.x, dy = targetY - player.y;
    player.dir = Math.abs(dx) > Math.abs(dy) ? (dx < 0 ? 'left' : 'right') : (dy < 0 ? 'up' : 'down');
  };

  (function step(){
    const k = Math.min(1, (performance.now() - t0) / dur);
    player.x = sx + (targetX - sx) * k;
    player.y = sy + (targetY - sy) * k;
    face();

    // anim mientras camina
    player.moving = true;
    player.frameTime += 1/60;
    if (player.frameTime >= (stepPeriodMs/1000)){
      player.frame = (player.frame + 1) % 2;
      player.frameTime = 0;
    }

    if (followCam) centerCameraOnPlayer?.();

    if (k < 1){
      requestAnimationFrame(step);
    } else {
      // <<< PARAR AQUÍ >>> 
      CUT.phase = 'postwalk';       // <- deja de ser 'autowalk'
      player.moving = false;
      player.frame = 0;
      player.frameTime = 0;

      onDone && onDone();
    }
  })();
}

  

// **************************** CINEMATICA 3

// === Helpers globales para la cine 3 ===
async function applyOtherJuanSSJ({boostHalo=true} = {}){
  const other = NPCS.find(n => n.id === 'juansin_other');
  if(!other) return null;
  const img = await loadImage('assets/npcs/juan_ssj.png');
  if (img){
    other.img = img;
    other.iw  = img.naturalWidth  || other.iw;
    other.ih  = img.naturalHeight || other.ih;
  }
  if (boostHalo){
    other.halo = { color:'255,255,160', radius:38, alpha:0.8, pulse:0.08, offsetY:0.62 };
    other._fxActive = true;
    other._fxUntil  = performance.now() + 600;
  }
  GAME_FLAGS.juansin_other_halo = true;
  return other;
}

    
function cineAutoWalkTo(targetX, targetY, ms, onDone, { followCam = false, stepPeriodMs = 120 } = {}){
  CUT.phase = 'autowalk';
  const sx = player.x, sy = player.y;
  const t0 = performance.now();
  const dur = Math.max(200, ms|0);

  const face = ()=>{
    const dx = targetX - player.x, dy = targetY - player.y;
    player.dir = Math.abs(dx) > Math.abs(dy) ? (dx < 0 ? 'left' : 'right') : (dy < 0 ? 'up' : 'down');
  };

  (function step(){
    const k = Math.min(1, (performance.now() - t0) / dur);
    player.x = sx + (targetX - sx) * k;
    player.y = sy + (targetY - sy) * k;
    face();

    // — cadencia de pies desacoplada —
    player.moving = true;
    player.frameTime += 1/60;
    if (player.frameTime >= (stepPeriodMs/1000)){ player.frame = (player.frame + 1) % 2; player.frameTime = 0; }

    if (followCam) centerCameraOnPlayer();

    if (k < 1){
      requestAnimationFrame(step);
    } else {
      player.moving = false;
      player.frame = 0; player.frameTime = 0;
      if (typeof onDone === 'function') onDone();
    }
  })();
}


async function startCinematic3(){
  CUT.active = true; CUT.id='cine3'; CUT.phase='start';
  ambientLock = true; player.moving = false;

  setTimeout(() => {
    openDialog([
      { speaker:'Juan', text:'...?' },
      { speaker:'Juan', text:'¿Ese soy yo?' }
    ], true);

    CUT.hijackAction = () => {
      if (!dialogOpen) return;
      if (isTyping){ advanceDialog(); return; }

      if (dialogIndex < dialogScript.length - 1){
        advanceDialog();
        return;
      }

      // cerramos segunda línea → SSJ (con halo) → “Ah, pues no.”
      closeDialog();
      CUT.hijackAction = null;

      (async () => {
        const other = await applyOtherJuanSSJ({ boostHalo: true });

        setTimeout(() => {
          openDialog([{ speaker:'Juan', text:'Ah, pues no.' }], true);

          CUT.hijackAction = () => {
            if (!dialogOpen) return;
            closeDialog();
            CUT.hijackAction = null;

            // tramo 1: alinear X
            const targetX1 = other.x;
            const targetY1 = player.y;

            const v  = _cine3_getSSJ();
            const tx = v ? (v.x ) : player.x;
            const ty = v ?  v.y  + 35    : player.y;

  cine2AutoWalkTo(tx, ty, 700, () => {
    player.dir = 'up';
                    setTimeout(() => {
                  openDialog([{ speaker:'Juan Super Saiyan Legendario', text:'Grr' }], true);
                  CUT.hijackAction = () => {
                    if (dialogOpen){
                      closeDialog();
                      CUT.hijackAction = null;
                      cine3_beginPortraits();
                    }
                  };
                }, 200);
  });       
          };
        }, 1000);
      })();
    };
  }, 1000);
}

function _cine3_getSSJ(){
  let v = NPCS.find(n => n?.id === 'juansin_other');
  return v || null;
}

function cine3_beginPortraits(){
  // Activa layout/estado
  PORTRAITS.forceBlurFallback = !supportsCanvasFilter();
  PORTRAITS.active = true;
  PORTRAITS.blurK = 0;
  PORTRAITS.forceBlurFallback = false;
  PORTRAITS.stage = 'entering';

  // Construcción de retratos (letterbox interno)
  PORTRAITS.left  = _makeSide(IMG_JUAN_SSJ || IMG_JUAN_BIG, 'left',  'SSJ');
  PORTRAITS.right = _makeSide(IMG_JUAN_BIG,                  'right', 'Juan');
  PORTRAITS.left.flipX = true;

  // Parten fuera
  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

    HPBARS.leftName  = 'SSJ';
    HPBARS.rightName  = 'Juan';
    HPBARS.alpha  = 0; 
    HPBARS.show(10, 100);

    const t0 = performance.now();
    const dur = 400;
    function step(t){
      const k = Math.min(1, (t - t0) / dur);
      HPBARS.alpha = k;
      if (k < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

  // Entra primero SSJ por la izquierda
  _startSlide(PORTRAITS.left, PORTRAITS.left.inX, ()=>{
    // Espera 1s antes del ataque
    setTimeout(()=>{
      // (1) Dash de SSJ (ataque)
      cine3_attackSequence(()=>{
        // (2) SSJ sale y entra Juan
        _startSlide(PORTRAITS.left, PORTRAITS.left.outX, ()=>{
          // >>> MOSTRAR LA LÍNEA DE ATAQUE ANTES DE QUE ENTRE JUAN <<<
          openDialog([{ speaker:'', text:'Juan Super Saiyan Legendario te ataca con una bola de energía.' },{ speaker:'', text:'No puedes seguir luchando.'},{ speaker:'', text:'¡Rápido! ¡Escóndete en algún sitio!'}], true);

          // Mientras dura la coreografía, bloquear el botón Acción para que no cierren el texto
          CUT.hijackAction = ()=>{}; // no-op

          _startSlide(PORTRAITS.right, PORTRAITS.right.inX, ()=>{
            // Tras 1s, reproducir reacción de "recibir" en Juan y bajar su barra
            setTimeout(()=>{
              cine3_hitReaction(PORTRAITS.right);
              HPBARS.setTargets(1, 100);
              cine3_openNarrator();
            }, 1000);
          });
        });
      });
    }, 1000);
  });

  // Durante esta coreografía el botón Acción no hace nada hasta que llamemos a cine3_openNarrator()
  CUT.hijackAction = ()=>{};
}




function cine3_attackSequence(done){
  // Dash de SSJ hacia el centro y atrás
  const L = PORTRAITS.left;
  const mid = L.inX + Math.round(screenRect.dw*0.04);
  const back = L.inX;
  // dash in
  L.sFrom=1.00; L.sTo=1.06;
  _startSlide(L, mid, ()=>{
    // y vuelve al sitio
    L.sFrom=1.06; L.sTo=1.00;
    _startSlide(L, back, ()=>{ if (typeof done==='function') done(); });
  });
}

function cine3_hitReaction(node){
  // pequeño temblor/retroceso
  const orig = node.inX;
  const kick = orig + Math.round(screenRect.dw*0.02);
  node.sFrom=1.00; node.sTo=0.96;
  _startSlide(node, kick, ()=>{
    node.sFrom=0.96; node.sTo=1.00;
    _startSlide(node, orig, null);
  });
}

function cine3_openNarrator(){
CUT.hijackAction = ()=> {
  if (!dialogOpen) return;

  if (isTyping){ advanceDialog(); return; }

  if (dialogIndex < dialogScript.length - 1){
    advanceDialog();  // -> muestra "¡Rápido! Escóndete en algún sitio."
    return;
  }
  closeDialog();
  CUT.hijackAction = null;

  HPBARS.hide();

CUT.onEnd = ()=>{
  ambientLock = true;
  ambientLockOwner = 'hide_bush';
  // por si quedó alguna tecla “pegada”
  if (typeof KEYS !== 'undefined'){ KEYS.up=KEYS.down=KEYS.left=KEYS.right=false; }
  player.moving = false; player.vx = 0; player.vy = 0;

  startBushPulse('bush_hideout');
  endCine3();
};


  _endPortraits();
};


}


async function swapOtherJuanToSSJ(){
  // Busca el NPC con id fijo
  const other = NPCS.find(n => n.id === 'juansin_other');
  if(!other){
    console.warn('cine3: no se encontró el NPC juansin_other');
    endCine3();
    return;
  }

  // Carga el nuevo PNG y aplica (actualiza tamaño si cambia)
  const img = await loadImage('assets/npcs/juan_ssj.png');
  if (img){
    other.img = img;
    other.iw  = img.naturalWidth  || other.iw;
    other.ih  = img.naturalHeight || other.ih;
  }

  // (Opcional) pequeño destello para remarcar el cambio
  other._fxActive = true;
  other._fxUntil  = performance.now() + 300;

  // asegúrate de que el halo quede permanente tras el cambio de sprite
if (!GAME_FLAGS.juansin_other_halo){
  other.halo = { color:'255,255,160', radius:30, alpha:0.6, pulse:0.05, offsetY:0.62 };
  GAME_FLAGS.juansin_other_halo = true;
}

  // Termina la cine
  endCine3();
}

function _cine3_removeVoldFromMap(){
  // 1) quitar del array de NPCs
  const idx = NPCS.findIndex(n => n?.id === 'voldemort_perfil');
  let removedNpc = null;
  if (idx >= 0) removedNpc = NPCS.splice(idx, 1)[0];

  // 2) quitar colliders (si existen)
  if (typeof COLLIDERS !== 'undefined' && Array.isArray(COLLIDERS)){
    for (let i = COLLIDERS.length - 1; i >= 0; i--){
      const c = COLLIDERS[i];
      if (c?.id === 'voldemort_perfil' || c?.ref?.id === 'voldemort_perfil'){
        COLLIDERS.splice(i, 1);
      }
    }
  }

  // 3) quitar de OBSTACLES (aquí es donde realmente lo guardaste)
  if (typeof OBSTACLES !== 'undefined' && Array.isArray(OBSTACLES)){
    for (let i = OBSTACLES.length - 1; i >= 0; i--){
      const o = OBSTACLES[i];
      const isNpcObstacle = o?.name === 'npc:voldemort_perfil';
      const nearRemoved = removedNpc
        ? Math.abs((o.x||0) - (removedNpc.x||0)) < 2 && Math.abs((o.y||0) - (removedNpc.y||0)) < 20
        : false;
      if (isNpcObstacle || nearRemoved) {
        OBSTACLES.splice(i, 1);
      }
    }
  }

  // 4) quitar interact zones
  if (typeof INTERACTS !== 'undefined' && Array.isArray(INTERACTS)){
    for (let i = INTERACTS.length - 1; i >= 0; i--){
      const it = INTERACTS[i];
      if (it?.id === 'voldemort_perfil' || it?.ref?.id === 'voldemort_perfil'){
        INTERACTS.splice(i, 1);
      }
    }
  }
}



function endCine3(){
  // Cierre limpio de la cinematica 3 (sin arrancar el latido aquí)
  CUT.active = false;
  CUT.id = null;
  CUT.phase = null;
  CUT.hijackAction = null;
  CUT.onEnd = null;

  // Devuelve el control al jugador
  ambientLock = false;
}

function _cine4_removeSSJFromMap(){
  const idx = NPCS.findIndex(n => n?.id === 'juansin_other');
  let removedNpc = null;
  if (idx >= 0) removedNpc = NPCS.splice(idx, 1)[0];

  // 2) quitar colliders antiguos (si usas COLLIDERS en algún sitio)
  if (typeof COLLIDERS !== 'undefined' && Array.isArray(COLLIDERS)){
    for (let i = COLLIDERS.length - 1; i >= 0; i--){
      const c = COLLIDERS[i];
      if (c?.id === 'juansin_other' || c?.ref?.id === 'juansin_other'){
        COLLIDERS.splice(i, 1);
      }
    }
  }

  if (typeof OBSTACLES !== 'undefined' && Array.isArray(OBSTACLES)){
    for (let i = OBSTACLES.length - 1; i >= 0; i--){
      const o = OBSTACLES[i];
      // por name del tipo
      const isNpcObstacle = o?.name === 'npc:juansin_idle';
      // o por cercanía a la posición del NPC eliminado (si lo teníamos)
      const nearRemoved = removedNpc
        ? Math.abs((o.x||0) - (removedNpc.x||0)) < 2 && Math.abs((o.y||0) - (removedNpc.y||0)) < 20
        : false;

      if (isNpcObstacle || nearRemoved) {
        OBSTACLES.splice(i, 1);
      }
    }
  }

  // 4) quitar interact zones
  if (typeof INTERACTS !== 'undefined' && Array.isArray(INTERACTS)){
    for (let i = INTERACTS.length - 1; i >= 0; i--){
      const it = INTERACTS[i];
      if (it?.id === 'juansin_other' || it?.ref?.id === 'juansin_other'){
        INTERACTS.splice(i, 1);
      }
    }
  }
}


// ========================= CINEMÁTICA 4 =========================
function startCinematic4(){ 
  CUT.active = true; CUT.id='cine4'; CUT.phase='lock';
  ambientLock = true; player.moving=false; player.vx=player.vy=0;

  // 1) Diálogo inicial
  openDialog([{ speaker:'Juan Super Saiyan Legendario', text:'¿No has tenido suficiente?' }], true); 
  CUT.hijackAction = () => {
        if (isTyping) return advanceDialog();
        closeDialog();
    
        _cine4_step1();
      };
      }

  // ===== Helpers spawn NPCs desde catálogo =====
function spawnNPCFromCatalog(type, x, y, opts = {}){
  const spec = NPC_CATALOG[type];
  const img  = NPC_IMAGES[type];
  if (!spec || !img) return null;

  const s = spec.scale || 1;
  const npc = {
    id: opts.id || `${type}_${Math.random().toString(36).slice(2,7)}`,
    type, img,
    x, y,
    iw: img.naturalWidth || 32,
    ih: img.naturalHeight || 32,
    scale: s,
    depthBand: spec.depthBand ?? DEPTH_BAND,
    depthAnchorY: spec.depthAnchorY ?? 0,
    flipX: (typeof opts.flipX === 'boolean') ? opts.flipX : !!spec.flipX,
    shadow: { ...DEFAULT_SHADOW, ...(spec.shadow||{}) }
  };

  // collider opcional (si el tipo lo define)
  if (spec.collider){
    const c = spec.collider;
    const col = { x: npc.x + c.x*s, y: npc.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
    npc.collider = col;
    OBSTACLES.push({ ...col, name:`npc:${type}` });
  }

  // heredar halo si el tipo lo trae
  if (spec.halo){
    npc.halo = { ...(spec.halo) };
  }

  NPCS.push(npc);
  return npc;
}

function spawnAroundJuanFromList(list){
  if (!Array.isArray(list) || list.length===0) return;
  const baseX = player.x, baseY = player.y;
  for (const e of list){
    const dx = (e?.dx|0), dy = (e?.dy|0);
    spawnNPCFromCatalog(e.type, baseX + dx, baseY + dy, e);
  }
}


function _cine4_step1(){

  // --- Setup portraits/UI ---
  PORTRAITS.active = true;
  PORTRAITS.stage  = 'entering';
  PORTRAITS.idx    = 0;
  PORTRAITS.blurK  = 0;
  PORTRAITS.script = Array.isArray(PORTRAITS.script) ? PORTRAITS.script : [];

  PORTRAITS.left  = _makeSide(IMG_JUAN_SSJ,  'left',  'SSJ');
  PORTRAITS.right = _makeSide(IMG_JUAN_FIGHT,'right', 'Juan');
  PORTRAITS.left.flipX = true;

  PORTRAITS.left.x  = PORTRAITS.left.outX;
  PORTRAITS.right.x = PORTRAITS.right.outX;

  // --- Barras de vida ---
  HPBARS.leftName  = 'SSJ';
  HPBARS.rightName = 'Juan';
  HPBARS.alpha = 0;
  HPBARS.show(150, 100);

  { // fade-in de barras
    const t0 = performance.now(), dur = 400;
    const step = (t)=>{ const k = Math.min(1,(t-t0)/dur); HPBARS.alpha=k; if(k<1) requestAnimationFrame(step); };
    requestAnimationFrame(step);
  }

  const L = PORTRAITS.left;   // SSJ
  const R = PORTRAITS.right;  // Juan

  // 1) Entra SSJ
  _startSlide(L, L.inX, ()=>{
    // SSJ habla
    openDialog([{ speaker:'SSJ', text:'¡Te voy a hacer polvo!' }], true);
    CUT.hijackAction = ()=>{
      if (isTyping) return advanceDialog();
      closeDialog();

      // 2) Anim de ataque SSJ
      console.log('[cine4] SSJ attack sequence');
      cine3_attackSequence(()=>{

        // 3) SSJ sale
        _startSlide(L, L.outX, ()=>{

          // 4) Entra Juan (ANTES del mensaje del ataque)
          _startSlide(R, R.inX, ()=>{

            // Ahora mostramos el mensaje del ataque del SSJ
            openDialog([{ speaker:'', text:'Juan Super Saiyan Legendario te ataca con una bola de energía.' }], true);
            CUT.hijackAction = ()=>{
              if (isTyping) return advanceDialog();
              closeDialog();

              // Mensaje: no tuvo efecto
              openDialog([{ speaker:'', text:'No ha tenido efecto…' }], true);
              CUT.hijackAction = ()=>{
                if (isTyping) return advanceDialog();
                closeDialog();

                // 5) Pregunta por el ataque y abre menú
                openDialog([{ speaker:'', text:'¿Cómo quieres atacar?' }], true);
                CUT.hijackAction = ()=>{
                  if (isTyping){ advanceDialog(); return; }

                  // Reutilizamos el menú de cine2
                  _cine2_openMenu();

                  CUT.hijackAction = ()=>{

                    const choice = _cine2_menuConfirm();
                    if (choice < 0) return; // no elegido aún

                    closeDialog();
                    _cine2_closeMenu();

                    // 6) Anim de Juan atacando
                    const mid  = R.inX - Math.round(screenRect.dw * 0.04);
                    const back = R.inX;

                    R.sFrom = 1.00; R.sTo = 1.06;
                    _startSlide(R, mid, ()=>{
                      R.sFrom = 1.06; R.sTo = 1.00;
                      _startSlide(R, back, ()=>{
                        // Juan sale para “cargar” o rematar (igual que en cine2)
                        _startSlide(R, R.outX, ()=>{
                          // 7) SSJ entra para recibir el golpe
                          _startSlide(L, L.inX, ()=>{
                            const orig = L.inX;
                            const kick = orig + Math.round(screenRect.dw * 0.02);

                            L.sFrom = 1.00; L.sTo = 0.96;
                            _startSlide(L, kick, ()=>{
                              // Baja vida del SSJ (ajusta orden/valores según tu HPBARS)
                              if (typeof HPBARS.setTargets === 'function') HPBARS.setTargets(150, 0);

                              L.sFrom = 0.96; L.sTo = 1.00;
                              _startSlide(L, orig, ()=>{
                                // Fin de esta secuencia -> fin o siguiente paso
                                openDialog([{ speaker:'SSJ', text:'¡Argh!' }], true);
                                _cine4_removeSSJFromMap();
                                CUT.hijackAction = ()=>{
                                  if (isTyping) return advanceDialog();
                                  closeDialog();
                                  _cine4_end(); 
                                };
                              });
                            });
                          });
                        });
                      });
                    });
                  };
                };
              };
            };
          });
        });
      });
    };
  });
}

function goToEnd(){
  const cv = document.createElement('div');
  Object.assign(cv.style, {position:'fixed', inset:'0', background:'#000', opacity:'0', transition:'opacity .6s ease', zIndex:'9999', pointerEvents:'none'});
  document.body.appendChild(cv);
  requestAnimationFrame(()=>{ cv.style.opacity = '1'; });
  setTimeout(()=>{ window.location.href = 'end.html'; }, 650);
}



function _cine4_end(){ 
  player.dir = 'down';
  
  try{ smokeStart(null); }catch(e){}
  try{ spawnAroundJuanFromList(CINE4_AROUND); }catch(e){}

  _cine2_closePortraitsAndOverlay(() => {
    openDialog([
          { speaker:'Pueblo', text:'OLÉ' },
          { speaker:'Juan', text:'Yujuu' }
        ], true);

    CUT.hijackAction = () => { 
      if (isTyping) return advanceDialog();

      closeDialog();
      CUT.hijackAction = null;

      (async ()=>{
        const aheadX = player.x + (player.dir==='right'? 8 : player.dir==='left' ? -8 : 0);
        const aheadY = player.y + (player.dir==='down' ? 0 : -6);
        try{ await spawnTresorShinyAt(aheadX, aheadY); }catch(e){ console.warn('tresor spawn fail', e); }

        openDialog([
          { speaker:'Juan', text:'¿Eso… brilla?' },
          { speaker:'Juan', text:'¡Un tesorito!' }
        ], true);

        CUT.hijackAction = ()=>{
          if (isTyping) return advanceDialog();
          if (dialogIndex < dialogScript.length - 1){ advanceDialog(); return; }
          closeDialog();

          goToEnd();
        };
      })();
    }; 
  });
}



/* ========== MOVIMIENTO / MEGAUPDATE ========== */
function cornerSlide(targetX, targetY, vx, vy){
  const SLIDE = 3;
  if(Math.abs(vx) > Math.abs(vy)){
    for(const off of [-SLIDE, SLIDE]){
      const ty = clamp(player.y + off, 0, world.h);
      if(!anyOverlap(targetX, ty)){ player.y = ty; player.x = targetX; return true; }
    }
  } else {
    for(const off of [-SLIDE, SLIDE]){
      const tx = clamp(player.x + off, 0, world.w);
      if(!anyOverlap(tx, targetY)){ player.x = tx; player.y = targetY; return true; }
    }
  }
  return false;
}
  
function nudgeOut(){
  let moved = false;
  for(const ob of OBSTACLES){
    if(!ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) continue;
    const qx = clamp(player.x, ob.x, ob.x + ob.w);
    const qy = clamp(player.y + FEET_OFFSET_Y, ob.y, ob.y + ob.h);
    let dx = player.x - qx, dy = (player.y + FEET_OFFSET_Y) - qy;
    const ndx = dx / FEET_RADIUS_X, ndy = dy / FEET_RADIUS_Y;
    const len = Math.hypot(ndx, ndy) || 1e-6;
    const overlap = 1 - len + 0.001;
    if(overlap > 0){
      const pushX = (ndx/len) * overlap * FEET_RADIUS_X;
      const pushY = (ndy/len) * overlap * FEET_RADIUS_Y;
      player.x += pushX; player.y += pushY; moved = true;
    }
  }
  return moved;
}

function update(dt){
  const vx = (keys.left?-1:0) + (keys.right?1:0);
  const vy = (keys.up?-1:0) + (keys.down?1:0);

  if (!dialogOpen && ambientLock && !ambientLockOwner) ambientLock = false;

  if (introActive){
    AMBIENT.k = Math.min(1, AMBIENT.k + dt / (AMBIENT.introMs / 1000));
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
    if (canCenterCam) centerCameraOnPlayer();

    if (AMBIENT.k >= 1 && !initialDialogShown){
      initialDialogShown = true;
      setTimeout(()=>{
        initialDialogLock = true;   // ← marca que el lock pertenece al diálogo inicial
        interactBlocked = true;     // ← bloquea interacciones
        openDialog([{speaker:'Juan', text:'¡Chuuuus! Qué pelete.'}], true);
        introActive = false;
      }, 300);
    }
    return;
  }

  if (!CUT.active){
    const feet = feetWorld();
    const cz = CINE_BUILT.find(z=> !z._done && feet.x>=z.x && feet.x<=z.x+z.w && feet.y>=z.y && feet.y<=z.y+z.h);
    if (cz){
      cz._done = true;
      if (cz.id === 'cine1'){ startCinematic1(); return; }
      if (cz.id === 'cine2'){ startCinematic2(); return; }
      if (cz.id === 'cine3'){ startCinematic3(); return; }
      if (cz.id === 'cine3'){ startCinematic4(); return; }
    }
  }

  if (!CUT.active && dialogOpen){
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
    if (canCenterCam) centerCameraOnPlayer();
    return;
  }

  if (ambientLock){
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
    if (canCenterCam) centerCameraOnPlayer();
  }

  HPBARS.update(dt);
  portraitsUpdate(dt);

  if (CAM_TWEEN.on){
    CAM_TWEEN.t = Math.min(1, CAM_TWEEN.t + dt*1000 / CAM_TWEEN.dur);
    const ease = (x)=> x<0.5 ? 2*x*x : 1 - Math.pow(-2*x+2,2)/2;
    const k = ease(CAM_TWEEN.t);
    cam.x = CAM_TWEEN.sx + (CAM_TWEEN.ex - CAM_TWEEN.sx)*k;
    cam.y = CAM_TWEEN.sy + (CAM_TWEEN.ey - CAM_TWEEN.sy)*k;
    if (CAM_TWEEN.t>=1) CAM_TWEEN.on=false;
  }

  if (CUT.active){
    if (CUT.phase === 'autowalk'){
      // animar como si estuviera andando
      player.moving = true;
      if (CUT.autoDir) player.dir = CUT.autoDir;
      player.frameTime += dt;
      if (player.frameTime >= 0.12){
        player.frame = (player.frame + 1) % 2;
        player.frameTime = 0;
      }
    } else {
      // resto de fases: congelado
      player.moving = false;
      player.frame = 0;
    }
  } else {
    const wantsToMove = !!(vx || vy);
    player.moving = !ambientLock && wantsToMove;

    if (player.moving){
      player.dir = Math.abs(vx) > Math.abs(vy) ? (vx < 0 ? 'left' : 'right') : (vy < 0 ? 'up' : 'down');
      const len   = Math.hypot(vx, vy) || 1;
      const stepx = (vx/len) * player.speed * dt;
      const stepy = (vy/len) * player.speed * dt;

      const s = JUAN.scale, halfW = Math.round(JUAN.size.w*s)/2, halfH = Math.round(JUAN.size.h*s)/2;
      const nx = clamp(player.x + stepx, halfW, world.w - halfW);
      const ny = clamp(player.y + stepy, halfH, world.h - halfH);

      let blockedX = false, blockedY = false;
      for (const ob of OBSTACLES) if (ellipseRectOverlap(nx, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedX = true; break; }
      if (!blockedX) player.x = nx;
      for (const ob of OBSTACLES) if (ellipseRectOverlap(player.x, ny + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedY = true; break; }
      if (!blockedY) player.y = ny;

      if (blockedX && blockedY){
        if (!cornerSlide(nx, ny, stepx, stepy)) nudgeOut();
      }

      player.frameTime += dt;
      if (player.frameTime >= 0.12){ player.frame = (player.frame + 1) % 2; player.frameTime = 0; }
    } else {
      player.frame = 0;
    }
  }

  if (!ambientLock) nudgeOut();

  const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
  if (canCenterCam) centerCameraOnPlayer();

  fogUpdate(dt);

  // ---------------- Zonas de ambiente ----------------
  const feet = feetWorld();
  const newZone = AMBIENT_BUILT.find(z => pointInRect(feet.x, feet.y, z));
  const prevZone = _ambientCurrentZone;

  if (newZone !== prevZone){
    // limpiar timers/locks de la zona previa
    if (prevZone){
      if (ambientLockOwner === prevZone){
        ambientLock = false;
        ambientLockOwner = null;
      }
      clearTimeout(prevZone._lockTO);
      clearTimeout(prevZone._dialogTO);
    }

    // diálogos/locks de la nueva zona
    if (newZone){
      const willShowDialog =
        Array.isArray(newZone.dialogOnEnter) &&
        newZone.dialogOnEnter.length > 0 &&
        !newZone._dialogShown;

      const lockMs   = newZone.lockMs ?? 0;
      const talkWait = newZone.dialogDelayMs ?? 0;

      if (willShowDialog && lockMs > 0){
        ambientLock = true;
        ambientLockOwner = newZone;
        newZone._lockTO = setTimeout(() => {
          if (!newZone._dialogShown){
            newZone._dialogShown = true;
            newZone._dialogTO = setTimeout(() => openDialog(newZone.dialogOnEnter, true), talkWait);
          }
        }, lockMs);
      } else if (willShowDialog){
        newZone._dialogShown = true;
        newZone._dialogTO = setTimeout(() => openDialog(newZone.dialogOnEnter, true), talkWait);
      }
    }

    // paleta objetivo
    const targetPal = newZone ? newZone.palette : 'peach';
    AMBIENT.targets.peach    = (targetPal === 'peach')    ? 1 : 0;
    AMBIENT.targets.bluehour = (targetPal === 'bluehour') ? 1 : 0;
    AMBIENT.targets.hell     = (targetPal === 'hell')     ? 1 : 0;

    // música (crossfade con tu Music manager)
    const fadeMs =
      (newZone && typeof newZone.musicFadeMs === 'number' && newZone.musicFadeMs >= 0)
        ? newZone.musicFadeMs
        : (typeof AMBIENT.fadeMs === 'number' ? AMBIENT.fadeMs : 650);

    if (newZone && newZone.music) {
      // entrar en zona con música propia
      Music.play(newZone.music, { volume: 0.5, fadeMs });
    } else {
      // salir a “neutral/peach” -> música por defecto
      Music.play('town', { volume: 0.5, fadeMs });
    }

    _ambientCurrentZone = newZone;
  }

  // (importante) No dispares música fuera del bloque anterior para evitar repetir play() cada frame

  AMBIENT.k = Math.min(1, AMBIENT.k + dt / (AMBIENT.introMs / 1000));

  for (const key of Object.keys(AMBIENT.alphas)) {
    const a = AMBIENT.alphas[key];
    const t = AMBIENT.targets[key];
    AMBIENT.alphas[key] = (AMBIENT.fadeMs <= 0)
      ? t
      : a + (t - a) * Math.min(1, (dt * 1000) / AMBIENT.fadeMs);
  }

  smokeUpdate(dt);
  updateBushScene(dt);
  updateBushPulse(dt);

  if (GAME_FLAGS.need_potion && !GAME_FLAGS.has_potion){
    const feet = feetWorld();
    const pot = PROPS.find(p => p._isPotion);
    if (pot){
      const rx = 10, ry = 8; // radios “pie” para pickup
      const rect = { x: pot.x - rx, y: pot.y - ry, w: rx*2, h: ry*2 };
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, rect)){
        const idx = PROPS.indexOf(pot);
        if (idx >= 0) PROPS.splice(idx, 1);

        GAME_FLAGS.has_potion = true;
        GAME_FLAGS.need_potion = false;

        ambientLock = true;
        ambientLockOwner = 'potion_pick'; // opcional, por consistencia
        startJuanBlueHalo(0, { permanent:true });
        setTimeout(()=>{
          ambientLock = false; ambientLockOwner = null;
          openDialog([{ speaker:'Juan', text:'¡Ahora sí!' }], true);
        }, 1000);
      }
    }
  }
}


async function spawnTresorShinyAt(x, y){
  if (!spawnTresorShinyAt._img){
    spawnTresorShinyAt._img = await loadImage('assets/objects/tresor.png');
  }
  const img = spawnTresorShinyAt._img;
  if (!img) { console.warn('tresor.png no cargó'); return null; }

  const prop = {
    id: 'tresor_' + Math.random().toString(36).slice(2,7),
    type: 'tresor',
    img, x, y,
    iw: img.naturalWidth, ih: img.naturalHeight,
    scale: 0.12,
    _halo: { color:'255,255,160', radius:30, alpha:0.75, pulse:0.08, offsetY:0.62 } // 🔆 brillo
  };
  PROPS.push(prop);
  return prop;
}

  
/* ========== MEGADRAW ========== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // fondo
  let sx = Math.round(cam.x), sy = Math.round(cam.y);
  sx = clamp(sx, 0, world.w - cam.w);
  sy = clamp(sy, 0, world.h - cam.h);
  ctx.drawImage(bgImg, sx, sy, cam.w, cam.h, screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  // clip principal
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  // ----- cálculos del jugador -----
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);
  const jFoot = jy + jh/2;

// ----- z-list unificado (props + npcs + juan) -----
const zlist = [];

// props
for (const p of PROPS){
  const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
  const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
const pulse = (BUSH_PULSE.active && p.id === BUSH_PULSE.targetId) ? BUSH_PULSE.scale : 1.0;
const dw = Math.round(p.iw * p.scale * pulse * mapScaleX);
const dh = Math.round(p.ih * p.scale * pulse * mapScaleY);
const dx = Math.round(px - dw/2), dy = Math.round(py - dh);
  const spec = CATALOG[p.type] || {};
  const band = spec.depthBand ?? DEPTH_BAND;
  const anchor = (spec.depthAnchorY ?? 0) * mapScaleY;
  const pyCut = py + anchor;

  const sortY = spec.forceBack ? -9999 :
                (jFoot < pyCut - band) ? (py + 0.5) :
                (jFoot > pyCut + band) ? (py - 0.5) :
                py;

  zlist.push({
    y: sortY,
    draw(){
      if(!p.img){
        ctx.fillStyle='#777'; ctx.fillRect(dx,dy,dw,dh);
        ctx.strokeStyle='#222'; ctx.strokeRect(dx,dy,dw,dh);
        return;
      }
      if(spec.flipX){
        ctx.save(); ctx.scale(-1,1);
        ctx.drawImage(p.img, 0,0, p.iw,p.ih, -dx-dw, dy, dw, dh);
        ctx.restore();
      } else {
        if (p._isPotion){
  ctx.save();
  // posición del “pie” del sprite (ajusta offsetY si tu sprite tiene más aire arriba)
  const footX = Math.round(px + dw/2 - 7);
  const footY = Math.round(py + dh*0.92 - 13);

  // tamaño de la elipse (escala con el sprite)
  const rx = Math.max(6, dw*0.28);
  const ry = Math.max(3, dh*0.14);

  ctx.fillStyle = 'rgba(0,0,0,0.28)';  // opacidad de la sombra
  ctx.beginPath();
  ctx.ellipse(footX, footY, rx, ry, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}
if (p._halo){
  const halo = Object.assign({ radius:28, alpha:0.55, pulse:0.06, offsetY:0.6, color:'255,255,160' }, p._halo);
  const cx = Math.round(px);
  const cy = Math.round(py - dh * halo.offsetY);
  const R  = Math.max(10, halo.radius * Math.max(mapScaleX, mapScaleY));
  const t  = performance.now() * 0.0015;
  const Rp = R * (1 + Math.sin(t * 2.7) * halo.pulse);
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, Rp);
  g.addColorStop(0.00, `rgba(${halo.color}, ${halo.alpha})`);
  g.addColorStop(0.55, `rgba(${halo.color}, ${halo.alpha*0.35})`);
  g.addColorStop(1.00,  `rgba(${halo.color}, 0)`);
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx, cy, Rp, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

        ctx.drawImage(p.img, 0,0, p.iw,p.ih, dx,dy, dw,dh);
      }
    }
  });
}

// NPCs
for (const n of NPCS){
  const px = screenRect.dx + (n.x - cam.x) * mapScaleX;
  const py = screenRect.dy + (n.y - cam.y) * mapScaleY;
  const dw = Math.round(n.iw * n.scale * mapScaleX);
  const dh = Math.round(n.ih * n.scale * mapScaleY);
  const dx = Math.round(px - dw/2), dy = Math.round(py - dh);

  const band   = n.depthBand ?? DEPTH_BAND;
  const anchor = (n.depthAnchorY ?? 0) * mapScaleY;
  const pyCut  = py + anchor;

  const sortY = (jFoot < pyCut - band) ? (py + 0.5) :
                (jFoot > pyCut + band) ? (py - 0.5) :
                py;

  zlist.push({
    y: sortY,
    draw(){
      // sombra
      const sh = (n.shadow || DEFAULT_SHADOW);
const footX = Math.round(px);
const footY = Math.round(py);

// si tiene offsetX lo usamos, si no, 0
const offsetX = (typeof sh.offsetX !== 'undefined') ? sh.offsetX : 0;
const offsetY = (typeof sh.offsetY !== 'undefined') ? sh.offsetY : 0;

const shadowW = Math.max(6, Math.round(dw * sh.scaleX));
const shadowH = Math.max(3, Math.round(dh * sh.scaleY));

ctx.save();
ctx.globalAlpha = sh.alpha;
ctx.fillStyle = 'black';
ctx.beginPath();
ctx.ellipse(
  footX + offsetX,   // aquí aplicamos el offsetX opcional
  footY + offsetY,
  shadowW,
  shadowH,
  0,
  0,
  Math.PI * 2
);
ctx.fill();
ctx.restore();

if (n.halo) {
  const halo = {
    color: '255,255,160',
    radius: 34,
    alpha: 0.55,
    pulse: 0.04,      // 0 si no quieres “respirar”
    offsetY: 0.6,     // altura relativa
    ...n.halo
  };
  const cx = Math.round(px);
  const cy = Math.round(py - dh * halo.offsetY);
  const R  = Math.max(10, halo.radius * Math.max(mapScaleX, mapScaleY));
  const t  = performance.now() * 0.0015;
  const Rp = R * (1 + Math.sin(t * 2.7) * halo.pulse);

  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, Rp);
  g.addColorStop(0.00, `rgba(${halo.color}, ${halo.alpha})`);
  g.addColorStop(0.55, `rgba(${halo.color}, ${halo.alpha * 0.35})`);
  g.addColorStop(1.00, `rgba(${halo.color}, 0)`);

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(cx, cy, Rp, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

// === sprite (una sola vez, con flipX y fadeAlpha) ===
ctx.save();

// aplica fade si existe
if (typeof n._fadeAlpha === 'number') {
  ctx.globalAlpha *= Math.max(0, Math.min(1, n._fadeAlpha));
}

if (!n.img) {
  // placeholder si no hay imagen
  ctx.fillStyle = '#999';
  ctx.fillRect(dx, dy, dw, dh);
} else if (n.flipX) {
  // espejo horizontal (mismo patrón que en PROPS)
  ctx.scale(-1, 1);
  ctx.drawImage(n.img, 0, 0, n.iw, n.ih, -dx - dw, dy, dw, dh);
} else {
  ctx.drawImage(n.img, 0, 0, n.iw, n.ih, dx, dy, dw, dh);
}

ctx.restore();

      // FX disparo (igual que antes)
     if (isNPCFxActive(n)) {
  const mx = Math.round(px + (n.muzzleOffset.x * mapScaleX));
  const my = Math.round(py + (n.muzzleOffset.y * mapScaleY));

  // 🔥 radio base + pulso
  const baseR = 20 * Math.max(mapScaleX, mapScaleY);
  const t = performance.now() * 0.02; // velocidad del parpadeo
  const pulsito = 1 + 0.25 * Math.sin(t * 12); // 25% de variación
  const r = baseR * pulsito;

  const g = ctx.createRadialGradient(mx, my, 0, mx, my, r);
  g.addColorStop(0, 'rgba(255,240,200,.95)');
  g.addColorStop(0.5, 'rgba(255,200,80,.55)');
  g.addColorStop(1, 'rgba(255,255,255,0)');

  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(mx, my, r, 0, Math.PI * 2); ctx.fill();
  ctx.globalCompositeOperation = 'source-over';
}

    }
  });
}

// Juan
zlist.push({
  y: jFoot,
  draw(){
    const img = player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];
    const footX = Math.round(jx);
    const footY = Math.round(jy + jh/2);

    // sombra
    ctx.fillStyle = 'rgba(0,0,0,.3)';
    ctx.beginPath();
    ctx.ellipse(footX, footY - 4, jw/2.5, jh/6, 0, 0, Math.PI*2);
    ctx.fill();

      if (JUAN_HALO.active){
        if (!JUAN_HALO.permanent && performance.now() > JUAN_HALO.until){
    JUAN_HALO.active = false;
  }
  if (performance.now() > JUAN_HALO.until) JUAN_HALO.active = false;
  const baseR = Math.max(jw, jh) * 0.70;
  const t = performance.now() * 0.002;
  const r = baseR * (1 + 0.05 * Math.sin(t*7.2)); // leve pulso
  const cx = footX;
  const cy = footY - jh*0.55;

  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
  g.addColorStop(0.00, `rgba(${JUAN_HALO.color},0.55)`);
  g.addColorStop(0.60, `rgba(${JUAN_HALO.color},0.25)`);
  g.addColorStop(1.00, `rgba(${JUAN_HALO.color},0.00)`);
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

    // respiración
    const canBreathe = !player.moving && !dialogOpen && !ambientLock && !introActive;
    const phase  = canBreathe ? Math.sin(_nowSec * BREATH.speed) : 0;
    const sY     = 1 + phase * BREATH.scaleAmp;
    const sX     = 1 - phase * BREATH.scaleAmp*0.6;
    const compY  = (1 - sY) * jh;

    ctx.save();
    ctx.translate(footX, footY);
    ctx.translate(0, compY);
    ctx.scale(sX, sY);
    ctx.drawImage(img, 0, 0, sw, sh, Math.round(-jw/2), -jh, jw, jh);
    ctx.restore();
  }
});

zlist.sort((a,b)=>a.y - b.y).forEach(it=>it.draw());

  ctx.restore();                                  

  if (AMBIENT.k > 0.001){
    const order = ['peach','bluehour','hell'];
    for (const pal of order){
      const a = AMBIENT.alphas[pal] || 0;
      if (a > 0.001) drawPalette(pal, a * AMBIENT.k);
    }
  }
  drawFlashlightEnhance();

  // Debug (si lo usas)
  if (DEBUG_AMBIENT && AMBIENT_BUILT.length){ /* ... igual que antes ... */ }
  if (DEBUG_OBS){ /* ... igual que antes ... */ }
if (DEBUG_INTER){
  ctx.save();
  // delimita al área jugable
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  ctx.lineWidth = 1.5;
  ctx.setLineDash([5,3]);

  // --- Zonas de interacción de PROPS ---
  for (const p of PROPS){
    if (!p.interacts) continue;
    const s = p.scale || 1;
    for (const z of p.interacts){
      const sx = Math.round(screenRect.dx + (z.x - cam.x) * mapScaleX);
      const sy = Math.round(screenRect.dy + (z.y - cam.y) * mapScaleY);
      const sw = Math.round(z.w * mapScaleX);
      const sh = Math.round(z.h * mapScaleY);

      ctx.fillStyle   = 'rgba(0,200,255,0.12)';
      ctx.strokeStyle = '#00C8FF';
      ctx.fillRect(sx, sy, sw, sh);
      ctx.strokeRect(sx+0.5, sy+0.5, sw-1, sh-1);

      // etiqueta
      const label = `prop:${p.type}`;
      ctx.setLineDash([]);
      ctx.font = '600 12px system-ui, sans-serif';
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(sx+4, sy-18, tw+8, 16);
      ctx.fillStyle = '#00C8FF';
      ctx.fillText(label, sx+8, sy-6);
      ctx.setLineDash([5,3]);
    }
  }

  // --- Zonas de interacción de NPCS ---
  for (const n of NPCS){
    if (!n.interacts) continue;
    for (const z of n.interacts){
      const sx = Math.round(screenRect.dx + (z.x - cam.x) * mapScaleX);
      const sy = Math.round(screenRect.dy + (z.y - cam.y) * mapScaleY);
      const sw = Math.round(z.w * mapScaleX);
      const sh = Math.round(z.h * mapScaleY);

      ctx.fillStyle   = 'rgba(160,255,120,0.12)';
      ctx.strokeStyle = '#A0FF78';
      ctx.fillRect(sx, sy, sw, sh);
      ctx.strokeRect(sx+0.5, sy+0.5, sw-1, sh-1);

      // etiqueta
      const label = `npc:${n.id || n.type}`;
      ctx.setLineDash([]);
      ctx.font = '600 12px system-ui, sans-serif';
      const tw = ctx.measureText(label).width;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(sx+4, sy-18, tw+8, 16);
      ctx.fillStyle = '#A0FF78';
      ctx.fillText(label, sx+8, sy-6);
      ctx.setLineDash([5,3]);
    }
  }

  // --- Pies de Juan (elipse de colisión) ---
  {
    const cx = screenRect.dx + (player.x - cam.x) * mapScaleX;
    const cy = screenRect.dy + (player.y + FEET_OFFSET_Y - cam.y) * mapScaleY;
    const rx = FEET_RADIUS_X * mapScaleX;
    const ry = FEET_RADIUS_Y * mapScaleY;
    ctx.strokeStyle = '#FF66AA';
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
    ctx.stroke();
  }

  ctx.restore();
}

if (DEBUG_CINE && CINE_BUILT.length){
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  ctx.lineWidth = 2;
  ctx.setLineDash([6,4]);

  for (const z of CINE_BUILT){
    const sx = Math.round(screenRect.dx + (z.x - cam.x) * mapScaleX);
    const sy = Math.round(screenRect.dy + (z.y - cam.y) * mapScaleY);
    const sw = Math.round(z.w * mapScaleX);
    const sh = Math.round(z.h * mapScaleY);

    // relleno suave
    ctx.fillStyle = 'rgba(0,255,255,0.15)'; // cian semitransparente
    ctx.fillRect(sx, sy, sw, sh);

    // borde
    ctx.strokeStyle = '#00FFFF';
    ctx.strokeRect(sx, sy, sw, sh);

    // etiqueta
    ctx.setLineDash([]);
    ctx.font = '600 12px system-ui, sans-serif';
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(sx+4, sy+4, ctx.measureText(z.id).width + 8, 18);
    ctx.fillStyle = '#00FFFF';
    ctx.fillText(z.id, sx+8, sy+18);
    ctx.setLineDash([6,4]);
  }

  ctx.restore();
}

  

  // >>>> NIEBLA AL FINAL DEL TODO (encima de todo lo anterior) <<<<
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();
  fogDraw();
  smokeDraw();
  ctx.restore();

  // Retratos / modo cine
  portraitsDrawOverlay();
  drawHPBars();
}


/* ========== LOOP / MEGAINIT ========== */
function loop(t){ if(!loop.last) loop.last=t; const dt=Math.min(1/60,(t-loop.last)/1000); loop.last=t; _nowSec = t / 1000;  update(dt); draw(); requestAnimationFrame(loop); }

  
async function init(){
  const [bg,spr] = await Promise.all([loadImage(BG_SRC), preloadSprites(JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog();
  await preloadNPCs();
  await preloadCinematicImages();

  world.w=bgImg.naturalWidth; world.h=bgImg.naturalHeight;
  CINE_BUILT = buildCineZones();
  AMBIENT_BUILT = buildAmbientZones();
  resize();

  const s=JUAN.scale; const halfW=Math.round(JUAN.size.w*s)/2, halfH=Math.round(JUAN.size.h*s)/2;
  if(START.mode==='percent'){ player.x=world.w*(START.x/100); player.y=world.h*(START.y/100); } else { player.x=START.x; player.y=START.y; }
  player.x=clamp(player.x,halfW,world.w-halfW); player.y=clamp(player.y,halfH,world.h-halfH);
  player.dir='down'; player.moving=false; player.frame=0; player.frameTime=0;
  keys.up=keys.down=keys.left=keys.right=false;

  buildPropsAndObstacles();
    buildNPCs();   

  const superProp = PROPS.find(p => p.type === 'super');
  if (superProp){
    smokeStart({ x: superProp.x, y: superProp.y - 50 });
     //SMOKE.areaW = 150; SMOKE.areaH = 90; //SMOKE.targetDensity = 100;
  }

  centerCameraOnPlayer();

  AMBIENT.k = 0;
AMBIENT.alphas  = { peach:1, bluehour:0, hell:0 };
AMBIENT.targets = { peach:1, bluehour:0, hell:0 };
  requestAnimationFrame(loop);
setTimeout(()=> document.getElementById('blackfade').classList.add('hide'), 50);

}
init();
</script>
</body>
</html>
