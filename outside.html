<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin – props por capas + colisiones (easy)</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html, body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:black; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); gap:0; justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); transform-origin:center; }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-act::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/action_btn.PNG") center/contain no-repeat; image-rendering:pixelated; transform:scale(1.02); }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }

  .vignette::after{
    content:""; position:absolute; inset:0; pointer-events:none;
    background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%);
    z-index:5;
  }
</style>
</head>
<body>
<div class="gameboy">
  <div class="screen-container">
    <div class="screen vignette">
      <canvas id="game"></canvas>
    </div>
  </div>

  <!-- Solo D-Pad + acción inerte -->
  <div class="controls">
    <div class="dpad">
      <div></div>
      <button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button>
      <div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button>
      <div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button>
      <div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button>
      <div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción"></button>
  </div>
</div>

<script>
/* ===== ASSETS ===== */
const BACKGROUND="assets/locations/outside.png"; // fondo grande
const SPRITES_JUAN={ size:{w:36,h:40}, scale:0.9,
  idle:{ down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"] },
  walk:{ down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
         up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
         left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
         right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"] }
};

// === CONFIG INICIAL ===
const START   = { mode:'percent', x:5, y:90 }; // posición inicial
let   ZOOM    = 2.5;                            // zoom de la lupa
let   DEBUG_OBS   = true;                       // overlay de obstáculos
let   DEBUG_PROPS = true;                       // overlay de colliders de props

/* ===== CANVAS / LAYOUT ===== */
const roomOriginal={w:512,h:350}; // mantiene bandas negras
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;

let bgImg=null, sprites=null;
let world={w:1024,h:768};

// cámara (se recalcula con el zoom)
let cam={x:0,y:0,w:roomOriginal.w,h:roomOriginal.h};

let bgRect={dx:0,dy:0,dw:0,dh:0};
let mapScaleX=1, mapScaleY=1;

/* ===== PLAYER ===== */
const player={x:0,y:0,speed:230,dir:'down',moving:false,frame:0,frameTime:0};

/* ===== INPUT: solo D-Pad ===== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){
  const start=e=>{e.preventDefault();on();};
  const end=e=>{e.preventDefault();off();};
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
  btn.addEventListener('mousedown',start);
  window.addEventListener('mouseup',end);
}
bindHold(document.getElementById('btn-up'),   ()=>keys.up=true,   ()=>keys.up=false);
bindHold(document.getElementById('btn-down'), ()=>keys.down=true, ()=>keys.down=false);
bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);

document.getElementById('btn-act').addEventListener('click', e=>e.preventDefault());
document.getElementById('btn-act').addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});

/* ===== UTIL ===== */
const loadImage=src=>new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=src; });
async function preloadSprites(map){
  const out={ idle:{}, walk:{}, size:map.size, scale:map.scale };
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

/* ===== OBSTÁCULOS AD-HOC (siguen existiendo) ===== */
const OBSTACLE_DEFS = [
  // ejemplo en porcentaje (ajústalo a tu mapa real)
  {type:'percent', x:30, y:30, w:30, h:50, name:'zona bloqueada'},
];
let OBSTACLES = []; // obstáculos en píxeles

function rectP(px, py, pw, ph){
  return { x: Math.round(world.w*(px/100)),
           y: Math.round(world.h*(py/100)),
           w: Math.round(world.w*(pw/100)),
           h: Math.round(world.h*(ph/100)) };
}
function buildObstaclesFromDefs(){
  const extra = OBSTACLE_DEFS.map(o=>{
    const r = (o.type==='percent') ? rectP(o.x,o.y,o.w,o.h) : {x:o.x,y:o.y,w:o.w,h:o.h};
    return {...r, name:o.name||'ad-hoc'};
  });
  OBSTACLES.push(...extra);
}
function toggleDebug(){ DEBUG_OBS=!DEBUG_OBS; }
window.toggleDebug = toggleDebug;

/* ===== CATALOGO DE PROPS (sprites por tipo con collider base) =====
   - anchor bottom-center: (x,y) es el PIE del sprite
   - collider: rect relativo al pie (en px de la imagen dibujada SIN ESCALA).
     Lo escalamos con 'prop.scale' al construir y luego con mapScale al pintar.
*/
const CATALOG = {
  tree:   { src:'assets/objects/arbolclaro.png',    scale:1.0, collider:{ x:-14, y:-28, w:28, h:20 } },  // tronco
  bush:   { src:'assets/objects/arbustoclaro.png',    scale:1.0, collider:{ x:-16, y:-16, w:32, h:16 } },
  rock:   { src:'assets/objects/piedra.png',    scale:1.0, collider:{ x:-12, y:-10, w:24, h:10 } },
  fence:  { src:'assets/objects/valla_clara.png',   scale:1.0, collider:{ x:-16, y:-10, w:32, h:10 } },
  house:  { src:'assets/objects/casajuan.png',   scale:1.0, collider:{ x:-40, y:-24, w:80, h:24 } }, // base de pared
  bridge: { src:'assets/objects/puente.png',  scale:1.0, collider:null }, // quizá sin colisión o solo bordes luego
};

/* ===== LISTA DE PROPS COLOCADOS =====
   - Por tipo, con posiciones en % o px. (fácil de editar)
*/
const PLACED = {
  tree: [
    {type:'percent', x:18, y:62},
    {type:'percent', x:22, y:64},
    {type:'percent', x:30, y:58},
  ],
  house: [
    {type:'percent', x:70, y:55},
  ],
  bush: [
    {type:'percent', x:45, y:78},
    {type:'percent', x:48, y:79},
  ],
  fence: [
    {type:'percent', x:40, y:82},
    {type:'percent', x:42, y:82},
    {type:'percent', x:44, y:82},
    {type:'percent', x:46, y:82},
  ],
  rock: [
    {type:'percent', x:60, y:72},
  ],
  bridge: [
    {type:'percent', x:55, y:65},
  ],
};

let PROP_IMAGES = {}; // imágenes por tipo
let PROPS = [];       // props colocados en píxeles del mundo + collider en mundo

async function preloadCatalog(){
  const entries = Object.entries(CATALOG);
  const loaded = await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  loaded.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}

function placeToWorld(p){
  if(p.type==='percent'){
    return { x: Math.round(world.w*(p.x/100)), y: Math.round(world.h*(p.y/100)) };
  }
  return { x: p.x, y: p.y };
}

function buildProps(){
  PROPS = [];
  for(const [type, list] of Object.entries(PLACED)){
    const spec = CATALOG[type];
    if(!spec) continue;
    const img = PROP_IMAGES[type];
    const baseScale = spec.scale || 1;

    for(const p of list){
      const pos = placeToWorld(p);
      // tamaño natural del sprite (sin escala)
      const iw = img.naturalWidth, ih = img.naturalHeight;

      const prop = {
        type, img,
        x: pos.x, y: pos.y,       // (x,y) es el pie (anchor bottom-center)
        iw, ih, scale: baseScale, // escala interna del prop
      };

      // collider en coordenadas de mundo (si existe)
      if(spec.collider){
        const c = spec.collider; // relativo al pie en px de imagen SIN escala
        const sx = c.x * baseScale;
        const sy = c.y * baseScale;
        const sw = c.w * baseScale;
        const sh = c.h * baseScale;
        // convierte relativo al pie (bottom-center) -> mundo
        prop.collider = {
          x: prop.x + sx,
          y: prop.y + sy - sh, // porque y en collider se mide hacia arriba desde el pie
          w: sw,
          h: sh
        };
        // añade a obstáculos del mundo
        OBSTACLES.push({ ...prop.collider, name:`${type}` });
      }

      PROPS.push(prop);
    }
  }
}

/* ===== COLISIÓN player vs rect ===== */
let FEET_RADIUS = 10;
function circleRectOverlap(cx, cy, r, rect){
  const rx = clamp(cx, rect.x, rect.x+rect.w);
  const ry = clamp(cy, rect.y, rect.y+rect.h);
  const dx = cx - rx, dy = cy - ry;
  return (dx*dx + dy*dy) <= (r*r);
}

/* ===== LAYOUT (bandas negras) ===== */
function resizeCanvas(){
  const screen=document.querySelector('.screen');
  canvas.width=screen.clientWidth;
  canvas.height=screen.clientHeight;

  const k=Math.min(canvas.width/roomOriginal.w, canvas.height/roomOriginal.h);
  bgRect.dw=roomOriginal.w*k;
  bgRect.dh=roomOriginal.h*k;
  bgRect.dx=(canvas.width-bgRect.dw)/2;
  bgRect.dy=(canvas.height-bgRect.dh)/2;

  applyZoom();
}
window.addEventListener('resize', resizeCanvas);

/* ===== CÁMARA INSTANTÁNEA ===== */
function updateCamera(){
  cam.x = (player.x - cam.w/2);
  cam.y = (player.y - cam.h/2);
  cam.x = clamp(cam.x, 0, world.w - cam.w);
  cam.y = clamp(cam.y, 0, world.h - cam.h);
}

/* ===== UPDATE ===== */
function update(dt){
  const vx=(keys.left?-1:0)+(keys.right?1:0);
  const vy=(keys.up?-1:0)+(keys.down?1:0);
  const moving = !!(vx||vy);
  player.moving = moving;

  let nx = player.x, ny = player.y;
  if(moving){
    player.dir = Math.abs(vx)>Math.abs(vy) ? (vx<0?'left':'right') : (vy<0?'up':'down');
    const len=Math.hypot(vx,vy)||1;
    nx += (vx/len)*player.speed*dt;
    ny += (vy/len)*player.speed*dt;

    // límites del mundo
    const sw=sprites.size.w, sh=sprites.size.h, s=sprites.scale;
    const halfW=Math.round(sw*s)/2, halfH=Math.round(sh*s)/2;
    nx = clamp(nx, halfW, world.w - halfW);
    ny = clamp(ny, halfH, world.h - halfH);

    // colisión ejes (deslizamiento)
    let tryX = true;
    for(const ob of OBSTACLES){ if(circleRectOverlap(nx, player.y, FEET_RADIUS, ob)){ tryX=false; break; } }
    if(tryX) player.x = nx;

    let tryY = true;
    for(const ob of OBSTACLES){ if(circleRectOverlap(player.x, ny, FEET_RADIUS, ob)){ tryY=false; break; } }
    if(tryY) player.y = ny;

    // animación
    player.frameTime+=dt;
    if(player.frameTime>=0.12){ player.frame=(player.frame+1)%2; player.frameTime=0; }
  } else {
    player.frame=0;
  }

  updateCamera();
}

/* ===== ZOOM ===== */
function applyZoom(){
  cam.w = Math.max(64, Math.round(roomOriginal.w / ZOOM));
  cam.h = Math.max(64, Math.round(roomOriginal.h / ZOOM));
  mapScaleX = bgRect.dw / cam.w;
  mapScaleY = bgRect.dh / cam.h;

  cam.x = clamp(cam.x, 0, world.w - cam.w);
  cam.y = clamp(cam.y, 0, world.h - cam.h);
}

/* ===== DRAW ===== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Fondo
  let srcX = Math.round(cam.x), srcY = Math.round(cam.y);
  srcX = clamp(srcX, 0, world.w - cam.w);
  srcY = clamp(srcY, 0, world.h - cam.h);
  ctx.drawImage(bgImg, srcX, srcY, cam.w, cam.h, bgRect.dx, bgRect.dy, bgRect.dw, bgRect.dh);

  // Lista de dibujado con orden por "pie" (Y en pantalla)
  const drawList = [];

  // Añade props
  for(const p of PROPS){
    const scrX = bgRect.dx + (p.x - cam.x) * mapScaleX;
    const scrY = bgRect.dy + (p.y - cam.y) * mapScaleY; // pie
    const drawW = Math.round(p.iw * p.scale * mapScaleX);
    const drawH = Math.round(p.ih * p.scale * mapScaleY);
    const dx = Math.round(scrX - drawW/2);
    const dy = Math.round(scrY - drawH);

    drawList.push({
      y: scrY,
      draw: ()=> ctx.drawImage(p.img, 0,0,p.iw,p.ih, dx, dy, drawW, drawH),
      debug: ()=> {
        if(DEBUG_PROPS && p.collider){
          const c = p.collider;
          const cdx = bgRect.dx + (c.x - cam.x) * mapScaleX;
          const cdy = bgRect.dy + (c.y - cam.y) * mapScaleY;
          const cdw = c.w * mapScaleX;
          const cdh = c.h * mapScaleY;
          ctx.save();
          ctx.globalAlpha = .45;
          ctx.fillStyle = '#33ff66';
          ctx.strokeStyle = '#003300';
          ctx.fillRect(Math.round(cdx), Math.round(cdy), Math.round(cdw), Math.round(cdh));
          ctx.strokeRect(Math.round(cdx), Math.round(cdy), Math.round(cdw), Math.round(cdh));
          ctx.restore();
        }
      }
    });
  }

  // Añade player
  const sw=sprites.size.w, sh=sprites.size.h, s=sprites.scale;
  const dw=Math.round(sw*s), dh=Math.round(sh*s);
  const screenX=Math.round(bgRect.dx + (player.x - cam.x) * mapScaleX);
  const screenY=Math.round(bgRect.dy + (player.y - cam.y) * mapScaleY); // pie

  drawList.push({
    y: screenY,
    draw: ()=>{
      // sombra
      ctx.fillStyle='rgba(0,0,0,.30)';
      ctx.beginPath();
      ctx.ellipse(screenX, screenY + Math.round(dh/2) - 4, dw/2.5, dh/6, 0, 0, Math.PI*2);
      ctx.fill();
      // sprite
      const img=player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];
      ctx.drawImage(img,0,0,sw,sh, Math.round(screenX - dw/2), Math.round(screenY - dh/2), dw, dh);
    }
  });

  // Ordena por Y y pinta
  drawList.sort((a,b)=>a.y-b.y).forEach(item=>item.draw());

  // DEBUG de props (colliders) encima
  drawList.forEach(item=> item.debug && item.debug());

  // DEBUG: obstáculos generales
  if(DEBUG_OBS){
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#ff3355';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;

    for(const ob of OBSTACLES){
      const dx = bgRect.dx + (ob.x - cam.x) * mapScaleX;
      const dy = bgRect.dy + (ob.y - cam.y) * mapScaleY;
      const dw = ob.w * mapScaleX;
      const dh = ob.h * mapScaleY;
      ctx.fillRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.strokeRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    }
    ctx.restore();
  }
}

/* ===== LOOP ===== */
function loop(now){
  if(!loop.last) loop.last=now;
  const dt=Math.min(1/60,(now-loop.last)/1000);
  loop.last=now;
  update(dt); draw();
  requestAnimationFrame(loop);
}

/* ===== INIT ===== */
async function init(){
  const [bg,spr] = await Promise.all([loadImage(BACKGROUND), preloadSprites(SPRITES_JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog(); // carga sprites de props

  world.w=bgImg.width; world.h=bgImg.height;

  resizeCanvas();

  // Posición inicial
  const sw=sprites.size.w, sh=sprites.size.h, s=sprites.scale;
  const halfW=Math.round(sw*s)/2, halfH=Math.round(sh*s)/2;

  if(START.mode==='percent'){
    player.x = world.w * (START.x/100);
    player.y = world.h * (START.y/100);
  }else{
    player.x = START.x; player.y = START.y;
  }
  player.x = clamp(player.x, halfW, world.w - halfW);
  player.y = clamp(player.y, halfH, world.h - halfH);

  // Construye props (y añade sus colliders) + obstáculos ad-hoc
  OBSTACLES = [];              // limpia
  buildProps();
  buildObstaclesFromDefs();

  updateCamera();
  requestAnimationFrame(loop);
}
init();

/* ===== Helpers para consola ===== */
window.setZoom = function(z){ ZOOM = Math.max(1, z); applyZoom(); updateCamera(); };
window.toggleProps = function(){ DEBUG_PROPS = !DEBUG_PROPS; };
window.addPropPercent = function(type,xp,yp){
  if(!PLACED[type]) PLACED[type]=[];
  PLACED[type].push({type:'percent',x:xp,y:yp});
  // reconstruye
  OBSTACLES = [];
  buildProps();
  buildObstaclesFromDefs();
};
window.FOOTS = ()=>console.log('player feet:', player.x, player.y);
</script>
</body>
</html>