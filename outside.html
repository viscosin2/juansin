<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum=1, user-scalable=no" />
<title>Juansin — outside</title>

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

<style>
  html,body { height:100%; margin:0; background:#111; display:flex; justify-content:center; align-items:center; }
  .gameboy { width:100%; max-width:500px; height:100%; background:#000; display:flex; flex-direction:column; padding:12px; box-sizing:border-box; border-radius:20px; box-shadow:0 0 40px rgba(0,0,0,.6); }
  .screen-container { flex:1; display:flex; justify-content:center; align-items:center; background:#0B0A21; border-radius:12px; padding:10px; }
  .screen { aspect-ratio:1/1; width:100%; background:#0B0A21; display:flex; justify-content:center; align-items:center; border-radius:8px; overflow:hidden; position:relative; box-shadow:inset 0 0 20px rgba(0,0,0,.6); }
  .screen::after{ content:""; position:absolute; inset:0; pointer-events:none; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.22) 100%); z-index:5; }
  canvas { width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; background:#000; }

  .controls { height:40%; background:#0B0A21; display:grid; grid-template-columns:1fr 1fr; gap:14px; padding:14px; box-sizing:border-box; }
  .dpad { display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px); justify-content:center; margin-left:12px; align-content:center; }
  .img-btn,.img-act{ border:none; outline:none; padding:0; background:transparent; cursor:pointer; transition:transform .06s ease, filter .06s ease; -webkit-tap-highlight-color:transparent; }
  .img-btn{ width:64px; height:64px; filter:drop-shadow(0 3px 4px rgba(0,0,0,.85)); }
  .img-btn.arrow::before{ content:""; display:block; width:100%; height:100%; background:url("assets/ui/arrow.PNG") center/contain no-repeat; image-rendering:pixelated; transform:rotate(var(--rot,0deg)) scale(1.28); }
  .btn-up{--rot:180deg} .btn-left{--rot:90deg} .btn-right{--rot:-90deg} .btn-down{--rot:0deg}
  .img-act{ width:120px; height:120px; filter:drop-shadow(0 5px 6px rgba(0,0,0,.85)); margin-top:45px; justify-self:center; }
  .img-btn:active,.img-btn.pressed,.img-act:active,.img-act.pressed{ transform:scale(.95); filter:drop-shadow(0 2px 3px rgba(0,0,0,.7)) brightness(.9); }
  .img-act::before{
    content:""; display:block; width:100%; height:100%;
    background:url("assets/ui/action_btn.PNG") center/contain no-repeat; image-rendering:pixelated; transform:scale(1.02);
  }

  #blackfade{
  position:fixed; inset:0;
  background:#000;
  z-index:9999;
  opacity:1;
  transition: opacity 1.5s ease; /* duración del fade */
}
#blackfade.hide{
  opacity:0;
  pointer-events:none;
}


  /* Toast */
  .toast{
    position:absolute; top:19px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.8); color:#fff; font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px; border-radius:8px; opacity:0; transition:opacity .2s ease;
    white-space:nowrap; pointer-events:none; z-index:6;
  }
  .toast.show{ opacity:1; }

  /* Diálogo */
  .dialog{
    position:absolute; left:50%; bottom:10px; transform:translateX(-50%) scaleX(0); transform-origin:center bottom;
    width:calc(100% - 24px); max-width:460px; min-height:20px; box-sizing:border-box;
    padding:12px 16px 16px; display:flex; gap:10px; border-radius:10px; flex-direction:column; text-align:left;
    image-rendering:pixelated; z-index:7; transition:transform .22s ease;
    background:rgba(12,12,24,0.9); border-top:2px solid #3cf;
  }
  .dialog.show{ transform:translateX(-50%) scaleX(1); }
  .dialog-name.juan{ font-family:'Press Start 2P',system-ui; font-size:10px; color:#8df; margin-bottom:4px; text-shadow:0 1px 0 #000; }
  .dialog-name.other{ font-family:'Press Start 2P',system-ui; font-size:10px; color:#f98; margin-bottom:4px; text-shadow:0 1px 0 #000; }
  .dialog-text{ font-family:'VT323',monospace; font-size:18px; letter-spacing:1px; line-height:1.15; color:#E6F6FF; min-height:2.2em; }
  .dialog-hint{ margin-left:auto; color:#B8D7FF; font:600 12px/1 system-ui; opacity:0; transition:opacity .18s ease; }
  .dialog.ready .dialog-hint{ opacity:.9; }
</style>
</head>
<body>
<div class="gameboy">
  <div class="screen-container">
    <div class="screen">
      <div id="blackfade"></div>
      <div id="toast" class="toast"></div>

      <div id="dialog" class="dialog">
        <div id="dialogName" class="dialog-name"></div>
        <div id="dialogText" class="dialog-text"></div>
        <div id="dialogHint" class="dialog-hint">→</div>
      </div>

      <canvas id="game">
        <div id="blackfade"></div>
      </canvas>
    </div>
  </div>

  <div class="controls">
    <div class="dpad">
      <div></div><button id="btn-up" class="img-btn arrow btn-up" aria-label="Arriba"></button><div></div>
      <button id="btn-left" class="img-btn arrow btn-left" aria-label="Izquierda"></button><div></div>
      <button id="btn-right" class="img-btn arrow btn-right" aria-label="Derecha"></button><div></div>
      <button id="btn-down" class="img-btn arrow btn-down" aria-label="Abajo"></button><div></div>
    </div>
    <button id="btn-act" class="img-act" aria-label="Acción"></button>
  </div>
</div>

<script>
/* ========== CONFIG RÁPIDA ========== */
const ROOM = { w:512, h:350 };
const ZOOM = 2.1;
const START = { mode:'percent', x:7, y:81 };
const FEET_RADIUS_X = 7, FEET_RADIUS_Y = 4, FEET_OFFSET_Y = 8;
const DEBUG_OBS = false;
const DEBUG_INTER = false;
const DEBUG_AMBIENT = false;
const DEBUG_CINE = true; 
const DEPTH_BAND = 12;

/* ====== BACKBUFFER para blur en modo cine ====== */
let BACKBUF = document.createElement('canvas');
let BACKCTX = BACKBUF.getContext('2d');

/* ====== ESTADO CINEMÁTICA ====== */
const CUT = {
  active: false,        // hay cinemática en curso (bloquea input libre)
  id: null,             // 'cine1'...
  phase: null,          // subfase
  hijackAction: null,   // handler para el botón de acción durante la cine
  onEnd: null           // callback al terminar
};

// ===== Fog (partículas + “sweep” de cortinas laterales)
const FOG = {
  active:false, parts:[], 
  color:'255,255,255',
  density: 0.5,         // menos partículas para evitar parpadeo
  filling:false, fillT:0, fillDur:3000, _fillT0:0,
  mode:'sweep',         // 'sweep' = cortinas laterales
  focusY: null,         // px de pantalla donde “se concentra” arriba
  baseAlpha: 0.85       // niebla basta/opalina
};



/* ====== CAMERA TWEEN ====== */
const CAM_TWEEN = { on:false, t:0, dur:1000, sx:0, sy:0, ex:0, ey:0 };

/* ====== PORTRAITS (modo cine) ====== */
const PORTRAITS = { active:false, blurPx:3, left:{}, right:{}, script:[], idx:0 };
let IMG_GANDALF_SMALL=null, IMG_GANDALF=null, IMG_JUAN_BIG=null;

  
  const DEFAULT_SHADOW = {
  alpha: 0.30,     // opacidad
  offsetY: -3,     // cuánto “sube”/“baja” desde el pie
  scaleX: 1/2.4,   // ancho relativo al dw del sprite
  scaleY: 1/7,     // alto relativo al dh del sprite
};

/* ========== ASSETS ========== */
const BG_SRC = "assets/locations/outside.png";
const JUAN = { size:{w:36,h:40}, scale:0.9,
  idle:{down:["assets/juan_character/idle_down_shoes.png"], up:["assets/juan_character/idle_up_shoes.png"], left:["assets/juan_character/idle_left_shoes.png"], right:["assets/juan_character/idle_right_shoes.png"]},
  walk:{down:["assets/juan_character/walk_down_0_shoes.png","assets/juan_character/walk_down_1_shoes.png"],
        up:["assets/juan_character/walk_up_0_shoes.png","assets/juan_character/walk_up_1_shoes.png"],
        left:["assets/juan_character/walk_left_0_shoes.png","assets/juan_character/walk_left_1_shoes.png"],
        right:["assets/juan_character/walk_right_0_shoes.png","assets/juan_character/walk_right_1_shoes.png"]}
};

  // justo debajo de: const player={x:0,y:0,dir:'down',speed:150,...};
const BREATH = {
  amp: 0.0,       // píxeles de subida/bajada
  scaleAmp: 0.01, // 2% de zoom al respirar (muy sutil)
  speed: 4      // Hz ~ velocidad del ciclo
};
let _nowSec = 0;  // tiempo en segundos (lo llenamos en loop)

const GAME_FLAGS = {
  talked_gunner: false,   // se activa al hablar con el NPC de la pistola
};

/* ========== LINTERNA (opcional) ========== */
const LIGHT = {
  enabled: false,
  mode: 'cone',
  radius: 70,
  feather: 0.45,
  coneLen: 150,
  coneWidth: Math.PI/5,
  flicker: 0.03,
  brightness: 0.4,
  tint: '255,230,180'
};

async function preloadCinematicImages(){
  IMG_GANDALF_SMALL = await loadImage('assets/npcs/gandalf.png');
  IMG_GANDALF       = await loadImage('assets/characters/gandalf_big.PNG');
  IMG_JUAN_BIG      = await loadImage('assets/characters/juansin_big.PNG');
}

  // ------------------------ ZONAS CINE
  const CINE_ZONES = [
  { id:'cine1', rect:{type:'percent', x:10, y:50, w:10, h:5}, _done:false }
];
  function buildCineZones(){
  return CINE_ZONES.map(z=>{
    const r=z.rect;
    if (r.type==='percent'){
      return { ...z,
        x: Math.round(world.w*(r.x/100)), y: Math.round(world.h*(r.y/100)),
        w: Math.round(world.w*(r.w/100)), h: Math.round(world.h*(r.h/100))
      };
    }
    return {...z, x:r.x,y:r.y,w:r.w,h:r.h};
  });
}
let CINE_BUILT = [];

/* ========== ZONAS AMBIENTE (alphas por paleta, sin saltos) ========== */
const AMBIENT = {
  k: 0,            // intensidad global (sube en la intro)
  introMs: 1200,   // fade-in inicial de k
  fadeMs: 2000,    // duración del crossfade entre paletas
  alphas:  { peach: 1, bluehour: 0, hell: 0 },
  targets: { peach: 1, bluehour: 0, hell: 0 }
};

const AMBIENT_ZONES = [
  {
    name:'Bluehour zone', palette:'bluehour',
    dialogOnEnter:[
      { speaker:'Juan', text:'...' },
      { speaker:'Juan', text:'Mensaje rollo válgame qué oscuro el bosque.' }
    ],
    dialogDelayMs: 500, lockMs: 1000,rect:{type:'percent', x:24, y:0, w:100, h:35}
  },
  {
    name:'Infierno super', palette:'hell',rect:{type:'percent', x:60, y:35, w:50, h:100}
  }
];

let ambientLock = false;
let ambientLockOwner = null;
let AMBIENT_BUILT = [];
let _ambientCurrentZone = null;
let introActive = true;
let initialDialogShown = false;
let NPC_IMAGES = {}, NPCS = [];


  /* ========== NPCs ========== */
// Catálogo de tipos de NPC (sprite, escala, collider, etc.)
const NPC_CATALOG = {
  abuela: { src: 'assets/npcs/abuela.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }},
  gato1: { src: 'assets/npcs/gato1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }},
  voldemort_perfil: { src: 'assets/npcs/voldemort_perfil.png', scale: 0.5, collider: { x:-20, y:0, w:30, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }},
  soldado1: { src: 'assets/npcs/soldado1.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,muzzleOffset: { x: -20, y: -12 },fireFxMs: 140},shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 },
  soldado2: { src: 'assets/npcs/soldado2.png', scale: 0.65, collider: { x:-10, y:0, w:20, h:15 },depthBand: 8, depthAnchorY: 1,shadow:{ alpha:0.28, offsetY:-2, scaleX:1/2.8, scaleY:1/8 }}
};

const NPC_PLACED = {
  abuela: [{type:'percent', x: 2.5, y: 9, interact: { x:-14, y: 12, w:28, h:16 }, 
     dialog: [{ speaker:'Abuelita', text:'Buenas tardes, Juan. ¿Has visto a mi gato?' }, { speaker:'Juan',text:'Mmm… creo que estaba por el río.' }]
    }],
  gato1: [{type:'percent', x: 21, y: 61, interact: { x:-14, y: 12, w:28, h:16 }, 
     dialog: [{ speaker:'Gato', text:'Hola, buenas.' }, { speaker:'Juan',text:'WTF' }],sound: "assets/sounds/miau.mp3"
    }],
  voldemort_perfil: [{type:'percent', x: 82, y: 15.5, interact: { x:-35, y: 12, w:50, h:16 }, 
     dialog: [{ speaker:'Voldemort', text:'Ye.' }, { speaker:'Juan',text:'WTF' }]
    }],
  soldado1: [{id:'gunner1', type:'percent', x: 14, y: 87, interact: { x:-14, y: 8, w:28, h:16 },onFire:true, 
     dialog: [{ speaker:'Armiche', text:'Ahí te va un pequeño perdigón.'}],sound: "assets/sounds/shot.mp3"
    }],
  soldado2: [{id:'guard1', type:'percent', x: 8, y: 87, interact: { x:-14, y: 12, w:28, h:16 },requiresFlag:'talked_gunner', 
     dialogBlocked:[ {speaker:'Boliche', text:'¡Como en el Call of Duty, señores!'}], dialog: [{ speaker:'Boliche', text:'¡Ah! ¡Mi lentilla!' }]
    }]
};


/* ========== CATALOGO / PLACEMENT ========== */
const CATALOG = {
  arbolclaro:   { src:'assets/objects/arbolclaro.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbolmedio:   { src:'assets/objects/arbolmedio.png',   scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arboloscuro:  { src:'assets/objects/arboloscuro.png',  scale:1, collider:{x:-12,y:-6,w:23.8,h:6} },
  arbustoclaro: { src:'assets/objects/arbustoclaro.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustomedio: { src:'assets/objects/arbustomedio.png', scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustooscuro:{ src:'assets/objects/arbustooscuro.png',scale:1, collider:{x:-16,y:-6,w:32,h:16} },
  arbustooscuroescondite:{ src:'assets/objects/arbustooscuro.png', scale:1, collider:null },
  piedra:       { src:'assets/objects/piedra.png',       scale:1, collider:{x:-28,y:-4,w:55,h:27} },
  piedraFlip:   { src:'assets/objects/piedra.png',       scale:1, collider:{x:-28,y:-4,w:55,h:27}, flipX:true },
  piedraBig:    { src:'assets/objects/piedra.png',       scale:1.2, collider:{x:-28,y:-4,w:55,h:27} },
  valla_clara:  { src:'assets/objects/valla_clara.png',  scale:1, collider:null },
  valla_media:  { src:'assets/objects/valla_media.png',  scale:1, collider:{x:-50,y:3,w:50,h:1} },
  valla_oscura: { src:'assets/objects/valla_oscura.png', scale:1, collider:{x:-210,y:-4.5,w:500,h:1}},
  casajuan:     { src:'assets/objects/casajuan.png',     scale:1, collider:{x:-46.5,y:-5,w:91, h:21}, depthBand:1, depthAnchorY:1, interact:{x:-20,y:5,w:38,h:18}},
  casaclara:    { src:'assets/objects/casaclara.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_amarilla:{ src:'assets/objects/casaclara_amarilla.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaclara_azul:{ src:'assets/objects/casaclara_azul.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casamedia:    { src:'assets/objects/casamedia.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casamedia_roja:{ src:'assets/objects/casamedia_roja.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casamedia_rosa:{ src:'assets/objects/casamedia_rosa.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  casaoscura:    { src:'assets/objects/casaoscura.png',    scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaoscura_roja:{ src:'assets/objects/casaoscura_roja.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, depthBand:1, depthAnchorY:1},
  casaoscura_rosa:{ src:'assets/objects/casaoscura_rosa.png', scale:1, collider:{x:-28,y:-5,w:58, h:21}, flipX:true, depthBand:1, depthAnchorY:1},
  puente:       { src:'assets/objects/puente.png', scale:1, collider:{x:-33.5,y:0,w:67.8, h:11} },
  puente2:      { src:'assets/objects/puente2.png', scale:1, collider:null},
  river1:       { src:'assets/objects/rio1.png',   scale:1, collider:null, forceBack: true},
  river2:       { src:'assets/objects/rio2.png',   scale:1, collider:null, forceBack: true},
  super:        { src:'assets/objects/super.png',  scale:1, collider:{x:-63,y:-5,w:120, h:23}, depthBand:1, depthAnchorY:1}
};

const PLACED = {
  arbolclaro:  [{type:'percent',x:4,y:85},{type:'percent',x:17,y:87.5},{type:'percent',x:2,y:64},{type:'percent',x:28.2,y:64},{type:'percent',x:17.5,y:52},{type:'percent',x:22.5,y:31.5},{type:'percent',x:3,y:8}],
  arbolmedio:  [{type:'percent',x:25.8,y:30},{type:'percent',x:25.3,y:12},{type:'percent',x:37,y:19},{type:'percent',x:47,y:19},{type:'percent',x:57,y:20},{type:'percent',x:70,y:14},{type:'percent',x:33,y:10},
                {type:'percent',x:40,y:30},{type:'percent',x:50,y:30},{type:'percent',x:60,y:30},{type:'percent',x:70,y:30},{type:'percent',x:76.5,y:22.5},{type:'percent',x:86.5,y:22.5},{type:'percent',x:78,y:10},
                {type:'percent',x:83,y:10.5},{type:'percent',x:85,y:32},{type:'percent',x:79,y:35},{type:'percent',x:96,y:9},{type:'percent',x:94,y:20},{type:'percent',x:96.5,y:30}],
  arboloscuro:  [{type:'percent',x:83,y:55},{type:'percent',x:78.5,y:58},{type:'percent',x:63,y:61},{type:'percent',x:85,y:79},{type:'percent',x:78,y:100.5}],
  casajuan:    [{type:'percent',x:7.2,y:82,say:'Tengo una misión.'}],
  casaclara_amarilla:[{type:'percent',x:24.5,y:90,interact:[{x:-22,y:5,w:19,h:18,say:'Puerta'},{x:12,y:5,w:13,h:18,say:'Un girasol.'}]}],
  casaclara_azul:    [{type:'percent',x:5.5,y:45}],
  casaclara:         [{type:'percent',x:7,y:20}],
  casamedia_roja:    [{type:'percent',x:42,y:17}],
  casamedia_rosa:    [{type:'percent',x:62,y:17}],
  casamedia:         [{type:'percent',x:52,y:17}],
  casaoscura_roja:   [{type:'percent',x:95.5,y:62}],
  casaoscura_rosa:   [{type:'percent',x:65,y:92}],
  casaoscura:        [{type:'percent',x:95.5,y:85}],
  arbustoclaro: [{type:'percent',x:3.2,y:97},{type:'percent',x:18.5,y:89},{type:'percent',x:25,y:66},{type:'percent',x:17,y:63},{type:'percent',x:9,y:62.5},{type:'percent',x:27.8,y:52},{type:'percent',x:5.3,y:54},
                 {type:'percent',x:23,y:40},{type:'percent',x:22,y:35.5},{type:'percent',x:23.5,y:10}],
  arbustomedio: [{type:'percent',x:27.5,y:33.5},{type:'percent',x:30,y:12},{type:'percent',x:46,y:20},{type:'percent',x:57,y:31},{type:'percent',x:37,y:31},{type:'percent',x:68,y:16},{type:'percent',x:84.5,y:13},
                 {type:'percent',x:72,y:11},{type:'percent',x:74,y:13.5},{type:'percent',x:80,y:12},{type:'percent',x:86,y:9},{type:'percent',x:90,y:12},{type:'percent',x:97,y:11},{type:'percent',x:76,y:25},
                 {type:'percent',x:96,y:25},{type:'percent',x:82,y:33},{type:'percent',x:94,y:32}],
  arbustooscuro: [{type:'percent',x:97,y:49},{type:'percent',x:86,y:57},{type:'percent',x:65,y:63},{type:'percent',x:97,y:96}],
  arbustooscuroescondite: [{type:'percent',x:86,y:81}],
  valla_clara:  [{type:'percent',x:15.25,y:99.75}],
  valla_media:  [{type:'percent',x:53.61,y:31.9}],
  valla_oscura: [{type:'percent',x:80.17,y:99.15}],
  piedra:       [{type:'percent',x:84.66,y:44}],
  piedraFlip:   [{type:'percent',x:80.35,y:41}],
  piedraBig:    [{type:'percent',x:96.1,y:43}],
  puente:       [{type:'percent',x:23.97,y:20.95}],
  puente2:      [{type:'percent',x:23.97,y:13.23}],
  river1:       [{type:'percent', x:5.73,  y:62.37}],
  river2:       [{type:'percent', x:22.91, y:62.37}],
  super:        [{type:'percent', x:72.9, y:77}]
};

/* Obstáculos extra */
const OBSTACLE_DEFS = [
  {type:'percent', x:29.4, y:30.6, w:31.85, h:80,   name:'zona bloqueada 1'},
  {type:'percent', x:60,   y:30.6, w:17.9,  h:24.5, name:'zona bloqueada 2'},
  {type:'percent', x:-4,   y:52,   w:15.5,  h:9.7,  name:'zona bloqueada rio 1'},
  {type:'percent', x:15.3, y:51,   w:22,    h:8.5,  name:'zona bloqueada rio 2'},
  {type:'percent', x:20.6, y:11.5, w:6.5,   h:1.5,  name:'zona bloqueada puente 5'},
  {type:'percent', x:21.8, y:36.5, w:12,    h:1,    name:'zona bloqueada valla pequeña clara'},
  {type:'percent', x:24,   y:20.4, w:0.5,   h:15.7, name:'zona bloqueada valla pequeña clara 2'},
  {type:'percent', x:24,   y:0,    w:0.5,   h:10,   name:'zona bloqueada valla pequeña clara 3'},
  {type:'percent', x:0,    y:1,    w:1,     h:110,  name:'zona bloqueada valla izquiera larga'},
  {type:'percent', x:77.5, y:45.5, w:4,     h:9.5,  name:'zona bloqueada pequeña final bosque'},
  {type:'percent', x:87.3, y:34.8, w:0.8,   h:10.2, name:'zona bloqueada puente oscuro 1'},
  {type:'percent', x:92.1, y:34.8, w:0.8,   h:10.2, name:'zona bloqueada puente oscuro 2'},
  {type:'percent', x:81,   y:45.5, w:0.7,   h:32,   name:'zona bloqueada valla oscura central'}
];

/* ========== STATE BÁSICO ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;

let bgImg=null, sprites=null, world={w:0,h:0};
let PROP_IMAGES={}, PROPS=[], OBSTACLES=[];
let cam={x:0,y:0,w:ROOM.w/ZOOM|0,h:ROOM.h/ZOOM|0};
let screenRect={dx:0,dy:0,dw:0,dh:0}, mapScaleX=1, mapScaleY=1;

const player={x:0,y:0,dir:'down',speed:150,moving:false,frame:0,frameTime:0};

/* ========== INPUT (SOLO D-PAD EN PANTALLA) ========== */
const keys={up:false,down:false,left:false,right:false};
function bindHold(btn,on,off){
  const start=e=>{e.preventDefault();on();};
  const end=e=>{e.preventDefault();off();};
  btn.addEventListener('touchstart',start,{passive:false});
  btn.addEventListener('touchend',end,{passive:false});
  btn.addEventListener('touchcancel',end,{passive:false});
}
bindHold(document.getElementById('btn-up'),   ()=>keys.up=true,   ()=>keys.up=false);
bindHold(document.getElementById('btn-down'), ()=>keys.down=true, ()=>keys.down=false);
bindHold(document.getElementById('btn-left'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btn-right'),()=>keys.right=true,()=>keys.right=false);
function bindPressVisual(el){
  const on=()=>el.classList.add('pressed'), off=()=>el.classList.remove('pressed');
  el.addEventListener('touchstart',e=>{e.preventDefault();on()},{passive:false});
  el.addEventListener('touchend',off,{passive:false}); el.addEventListener('touchcancel',off,{passive:false});
}
bindPressVisual(document.getElementById('btn-act'));

/* ====== TOAST ====== */
function showToast(msg, ms=1800){
  const t = document.getElementById('toast');
  t.textContent = msg; t.classList.add('show');
  clearTimeout(showToast._to);
  showToast._to = setTimeout(()=>t.classList.remove('show'), ms);
}

  
/* ====== NPCS ====== */

  
  async function preloadNPCs(){
  const entries = Object.entries(NPC_CATALOG);
  const res = await Promise.all(entries.map(([k,v]) => loadImage(v.src).then(img => [k,img])));
  res.forEach(([k,img]) => { NPC_IMAGES[k] = img; });
}

function buildNPCs(){
  NPCS = [];
  for (const [type, list] of Object.entries(NPC_PLACED)){
    const spec = NPC_CATALOG[type];
    const img  = NPC_IMAGES[type];
    if(!spec || !list?.length) continue;

    for (const p of list){
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x:p.x, y:p.y };
      const s   = spec.scale || 1;
      const npc = {
        id: p.id || `${type}_${Math.random().toString(36).slice(2,7)}`,
        type, img,
        x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth  : 32,
        ih: img ? img.naturalHeight : 32,
        scale: s,
        depthBand: spec.depthBand ?? DEPTH_BAND,
        depthAnchorY: spec.depthAnchorY ?? 0,
        dialog: Array.isArray(p.dialog) ? p.dialog : null,
        sound: p.sound ? new Audio(p.sound) : null,
        dialogBlocked: Array.isArray(p.dialogBlocked) ? p.dialogBlocked : null,
        requiresFlag: p.requiresFlag || null,
        onFire: !!p.onFire,
        muzzleOffset: spec.muzzleOffset || {x:0,y:0},
        fireFxMs: spec.fireFxMs || 120,
        _fxActive: false,
        _fxUntil: 0,
        shadow: { ...DEFAULT_SHADOW, ...(spec.shadow||{}), ...(p.shadow||{}) }
      };

      // collider opcional (bloquea como obstáculo)
      if (spec.collider){
        const c = spec.collider;
        const col = { x: npc.x + c.x*s, y: npc.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
        npc.collider = col;
        OBSTACLES.push({ ...col, name:`npc:${type}` });
      }

      // zona de interacción para abrir diálogo
      if (p.interact){
  const i = p.interact;
  npc.interacts = [{
    x: npc.x + i.x*s,
    y: npc.y + (i.y*s) - (i.h*s),
    w: i.w*s,
    h: i.h*s,
    npcRefId: npc.id,     // << clave para que el handler encuentre al NPC
    dialog: npc.dialog,
    sound: npc.sound
  }];
}


      NPCS.push(npc);
    }
  }
}


/* ====== DIÁLOGO ====== */
const dialogEl     = document.getElementById('dialog');
const dialogNameEl = document.getElementById('dialogName');
const dialogTextEl = document.getElementById('dialogText');
const dialogHintEl = document.getElementById('dialogHint');

let dialogOpen=false, isTyping=false, typingTimer=null, typingSpeed=22, dialogIndex=0;
let dialogScript = [];
const DIALOG_BEEP = new Audio("assets/sounds/bip.mp3");
DIALOG_BEEP.volume = 0.5;

function openDialog(lines, startTyping=true){
  dialogScript = lines || [];
  dialogIndex = 0;
  dialogEl.classList.add('show');
  dialogEl.classList.remove('ready');
  dialogOpen = true;
  renderCurrentLine(startTyping);
}
function closeDialog(){
  dialogEl.classList.remove('show','ready');
  dialogOpen=false;
  if (ambientLock && ambientLockOwner){
    ambientLock = false;
    ambientLockOwner = null;
  }
}

  function closeCurrentDialogNow(){
  if (!dialogOpen) return;
  if (isTyping) advanceDialog();  // termina de escribir
  if (dialogOpen) advanceDialog(); // y cierra
}

function renderCurrentLine(startTyping=false){
  const line = dialogScript[dialogIndex] || {speaker:'', text:''};
  dialogNameEl.textContent = line.speaker || '';
  if (line.speaker === 'Juan'){
    dialogNameEl.className = 'dialog-name juan';
  } else {
    dialogNameEl.className = 'dialog-name other';
  }
  dialogTextEl.textContent = '';
  dialogHintEl.style.opacity = 0;
  if(startTyping) startTypingEffect(line.text);
  else { dialogTextEl.textContent = line.text; dialogEl.classList.add('ready'); }
}
function startTypingEffect(text){
  clearInterval(typingTimer);
  isTyping = true; let i=0;
  typingTimer = setInterval(()=>{
    if(i < text.length){
      const ch = text[i++]; dialogTextEl.textContent += ch;
      if(i % 2 === 0){ try { DIALOG_BEEP.currentTime = 0; DIALOG_BEEP.play(); } catch(e){} }
    } else {
      clearInterval(typingTimer);
      isTyping=false; dialogEl.classList.add('ready'); dialogHintEl.style.opacity=1;
    }
  }, typingSpeed);
}
function advanceDialog(){
  if(!dialogOpen) return;
  const full = dialogScript[dialogIndex]?.text ?? '';
  if(isTyping){
    clearInterval(typingTimer);
    isTyping=false;
    dialogTextEl.textContent = full;
    dialogEl.classList.add('ready'); dialogHintEl.style.opacity=1;
    return;
  }
  dialogIndex++;
  if(dialogIndex < dialogScript.length){
    dialogEl.classList.remove('ready'); dialogHintEl.style.opacity=0;
    renderCurrentLine(true);
  } else {
    closeDialog();
  }
}
document.getElementById('btn-act').addEventListener('touchstart', e=>{
  e.preventDefault();
  if (CUT.active && typeof CUT.hijackAction === 'function'){
    CUT.hijackAction();
    return;
  }
  
  if (dialogOpen){
    advanceDialog();
    return;
  }

// 1) NPCs con diálogo / lógica especial
const npcHit = getNPCInteractHit();
if (npcHit){
  // localizar el npc por id
  const npc = NPCS.find(n => n.id === npcHit.npcRefId) || null;
  if (npc){
    // gating por flag
    if (npc.requiresFlag && !GAME_FLAGS[npc.requiresFlag]){
      if (npc.dialogBlocked && npc.dialogBlocked.length){
        openDialog(npc.dialogBlocked, true);
      } else {
        showToast('No parece querer hablar ahora.', 1400);
      }
      return;
    }

    // diálogo normal
    if (npc.dialog && npc.dialog.length){
      openDialog(npc.dialog, true);
    }

    // efecto disparo + sonido + flag
if (npc.onFire){
  setTimeout(() => {
    triggerNPCShot(npc);
  }, 1500); // 1000 ms = 1 segundo
  GAME_FLAGS.talked_gunner = true;
}

    return;
  }
}


  // 2) Props con "say" => toast
  const propHit = getInteractHit();
  if (propHit && propHit.say){
    showToast(propHit.say, 1800);
    return;
  }
}, {passive:false});



/* ========== UTILS ========== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const loadImage=src=>new Promise(r=>{ const i=new Image(); i.onload=()=>r(i); i.onerror=()=>{console.warn('No carga',src); r(null)}; i.src=src; });
async function preloadSprites(map){
  const out={idle:{},walk:{},size:map.size,scale:map.scale};
  for(const s of ['idle','walk']) for(const d of Object.keys(map[s])) out[s][d]=await Promise.all(map[s][d].map(loadImage));
  return out;
}
const percentToWorld=(p)=>({x:Math.round(world.w*(p.x/100)), y:Math.round(world.h*(p.y/100))});
const lerpT=(t,dt,ms)=> (ms<=0?1: Math.min(1, t + (dt*1000)/ms));
function triggerNPCShot(npc){
  npc._fxActive = true;
  npc._fxUntil  = performance.now() + npc.fireFxMs;

  // sonido si existe (mapa y sample)
  if (typeof NPC_SOUNDS !== 'undefined' && NPC_SOUNDS && NPC_SOUNDS[npc.type]) {
    const snd = NPC_SOUNDS[npc.type];
    try { snd.currentTime = 0; snd.play(); } catch(e){}
  }
}


function isNPCFxActive(npc){
  if (!npc._fxActive) return false;
  if (performance.now() > npc._fxUntil){
    npc._fxActive = false;
    return false;
  }
  return true;
}



  // -------------------- FUNCIONES NIEBLA
  
 function fogStart(){ FOG.active=true; FOG.parts.length=0; }
function fogStop(){ FOG.active=false; FOG.parts.length=0; FOG.filling=false; FOG.fillT=0; }

function fogBeginFill(ms=3000, opts={}){
  FOG.filling = true; 
  FOG.fillT   = 0; 
  FOG._fillT0 = performance.now(); 
  FOG.fillDur = ms;

  // opciones
  if (opts.mode)     FOG.mode = opts.mode;
  if (typeof opts.baseAlpha === 'number') FOG.baseAlpha = opts.baseAlpha;
  if (typeof opts.density   === 'number') FOG.density   = opts.density;
  FOG.focusY = typeof opts.focusY === 'number' ? opts.focusY : (screenRect.dy + screenRect.dh*0.28);

  if (!FOG.active) fogStart();
}


function fogUpdate(dt){
  if (!FOG.active) return;

  // partículas: si estamos en "fill", baja el ritmo y fija alfas
  const targetDensity = FOG.filling ? (FOG.density * 0.35) : FOG.density;
  const rate = 120 * targetDensity * dt;
  const toSpawn = Math.floor(rate);

  for (let i=0;i<toSpawn;i++){
    const r = 10 + Math.random()*16;
    const y = screenRect.dy + Math.random()*screenRect.dh;
    const fromLeft = Math.random()<0.5;
    const x = fromLeft ? screenRect.dx - r*2 : screenRect.dx + screenRect.dw + r*2;
    const vx = fromLeft ? (16+Math.random()*22) : -(16+Math.random()*22);
    const vy = (Math.random()-0.5)*4;
    // alfa casi fija para evitar parpadeo
    const a = 0.22;
    FOG.parts.push({x,y,r,vx,vy,alpha:a, life: 3.0+Math.random()*2.0});
  }

  for (let i=FOG.parts.length-1;i>=0;i--){
    const p=FOG.parts[i];
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    if (p.life<=0 || p.x < screenRect.dx-120 || p.x > screenRect.dx+screenRect.dw+120) FOG.parts.splice(i,1);
  }

  if (FOG.filling){
    const elapsed = performance.now() - FOG._fillT0;
    FOG.fillT = Math.min(1, elapsed / FOG.fillDur);
    if (FOG.fillT>=1) FOG.filling = false;
  }
}


function fogDraw(){
  if (!FOG.active) return;

  // --- (1) Partículas suaves encima ---
  if (FOG.parts.length){
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    for (const p of FOG.parts){
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
      g.addColorStop(0, `rgba(${FOG.color}, ${p.alpha})`);
      g.addColorStop(1, `rgba(255,255,255, 0)`);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // --- (2) Sweep lateral: dos cortinas desde lados hacia el centro ---
  if (FOG.mode === 'sweep'){
    const t = FOG.fillT;        // 0 → 1 en 3s
    const center = screenRect.dx + screenRect.dw/2;
    const focusY = FOG.focusY ?? (screenRect.dy + screenRect.dh*0.28);
    const alpha  = FOG.baseAlpha; // opacidad “basta”

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    // ancho de cortina que avanza
    const halfW = (screenRect.dw/2) * t;

    // función helper: cortina con degradé y “barriga” hacia focusY
    function drawCurtain(fromLeft){
      const x0 = fromLeft ? (center - halfW) : center;
      const w  = halfW;
      if (w <= 0) return;

      // 3 pasadas con gradientes radiales grandes para gaseoso
      for (let i=0;i<3;i++){
        const cx = fromLeft 
          ? (x0 - w*0.6 + Math.random()*w*1.2)
          : (x0 + w*0.6 - Math.random()*w*1.2);
        // concentrar más arriba (zona Gandalf)
        const cy = focusY + (Math.random()-0.5) * (screenRect.dh*0.25);

        const R = Math.max(screenRect.dw, screenRect.dh) * (0.7 + Math.random()*0.5);
        const a = alpha * (0.55 + Math.random()*0.25); // variación suave

        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R);
        g.addColorStop(0, `rgba(${FOG.color}, ${a})`);
        g.addColorStop(1, `rgba(255,255,255, 0)`);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // izquierda y derecha
    drawCurtain(true);
    drawCurtain(false);

    ctx.restore();
  } else {
    // Modo antiguo de “velo suave” si quisieras mantenerlo:
    if (FOG.fillT>0){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const passes = 3;
      for (let i=0;i<passes;i++){
        const alpha = 0.12 * FOG.fillT;
        const cx = screenRect.dx + screenRect.dw * (0.2 + 0.6*Math.random());
        const cy = screenRect.dy + screenRect.dh * (0.3 + 0.4*Math.random());
        const R  = Math.max(screenRect.dw, screenRect.dh) * (0.7 + 0.6*Math.random());
        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R);
        g.addColorStop(0, `rgba(${FOG.color}, ${alpha})`);
        g.addColorStop(1, `rgba(255,255,255, 0)`);
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }
}


  function portraitsOpen(script){
  PORTRAITS.active = true; PORTRAITS.script = script.slice(); PORTRAITS.idx = 0;

  const padX = 24, padBottom = 12;
  const leftImg  = IMG_GANDALF;
  const rightImg = IMG_JUAN_BIG;

  const maxW = Math.floor(screenRect.dw * 0.52); // que no se salga por las bandas
  const scaleToFit = (img)=> Math.min(1, maxW / img.naturalWidth);

  const sL = scaleToFit(leftImg), sR = scaleToFit(rightImg);
  PORTRAITS.left  = {
    img: leftImg,
    w: Math.round(leftImg.naturalWidth*sL),
    h: Math.round(leftImg.naturalHeight*sL),
    x: screenRect.dx - 9999,
    targetX: screenRect.dx + padX,
    y: screenRect.dy + screenRect.dh - padBottom, // pegado abajo
    side:'left', name:'Gandalf'
  };
  PORTRAITS.right = {
    img: rightImg,
    w: Math.round(rightImg.naturalWidth*sR),
    h: Math.round(rightImg.naturalHeight*sR),
    x: screenRect.dx + screenRect.dw + 9999,
    targetX: screenRect.dx + screenRect.dw - padX - Math.round(rightImg.naturalWidth*sR),
    y: screenRect.dy + screenRect.dh - padBottom,
    side:'right', name:'Juan'
  };

  portraitsApplyTurn();
  CUT.hijackAction = portraitsNext;
}

function portraitsApplyTurn(){
  const line = PORTRAITS.script[PORTRAITS.idx] || {speaker:'', text:''};
  // mete el que habla
  if (line.speaker === 'Gandalf'){
    PORTRAITS.left.x = PORTRAITS.left.targetX;
  } else {
    PORTRAITS.right.x = PORTRAITS.right.targetX;
  }
  openDialog([line], true);
}

function portraitsNext(){
  if (dialogOpen){ advanceDialog(); return; }
  PORTRAITS.idx++;
  if (PORTRAITS.idx < PORTRAITS.script.length){
    portraitsApplyTurn();
  } else {
    PORTRAITS.active = false;
    CUT.hijackAction = null;
    closeDialog();
    if (typeof CUT.onEnd === 'function') CUT.onEnd();
  }
}

function portraitsUpdate(dt){
  if (!PORTRAITS.active) return;
  const lerp = (a,b,k)=> a+(b-a)*Math.min(1,k);
  PORTRAITS.left.x  = lerp(PORTRAITS.left.x,  PORTRAITS.left.targetX,  dt*6);
  PORTRAITS.right.x = lerp(PORTRAITS.right.x, PORTRAITS.right.targetX, dt*6);
}

function portraitsDrawOverlay(){
  if (!PORTRAITS.active) return;

  // blur del frame actual
  BACKCTX.clearRect(0,0,BACKBUF.width,BACKBUF.height);
  BACKCTX.drawImage(canvas,0,0);
  ctx.save();
  ctx.filter = `blur(${PORTRAITS.blurPx}px)`;
  ctx.drawImage(BACKBUF,0,0);
  ctx.filter = 'none';
  // oscurecer suavemente
  ctx.fillStyle='rgba(0,0,0,0.25)';
  ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  // retratos (abajo)
  const L = PORTRAITS.left, R = PORTRAITS.right;
  if (L.img){
    const lx = Math.round(L.x), ly = Math.round(L.y - L.h);
    ctx.drawImage(L.img, 0,0, L.img.naturalWidth, L.img.naturalHeight, lx, ly, L.w, L.h);
  }
  if (R.img){
    const rx = Math.round(R.x), ry = Math.round(R.y - R.h);
    ctx.drawImage(R.img, 0,0, R.img.naturalWidth, R.img.naturalHeight, rx, ry, R.w, R.h);
  }
  ctx.restore();
}


/* ========== LAYOUT / CÁMARA ========== */
function resize(){
  const sc=document.querySelector('.screen');
  canvas.width=sc.clientWidth; canvas.height=sc.clientHeight;
  const k=Math.min(canvas.width/ROOM.w, canvas.height/ROOM.h);
  screenRect.dw=ROOM.w*k; screenRect.dh=ROOM.h*k;
  screenRect.dx=(canvas.width-screenRect.dw)/2;
  screenRect.dy=(canvas.height-screenRect.dh)/2;
  cam.w=Math.max(64,Math.round(ROOM.w/ZOOM));
  cam.h=Math.max(64,Math.round(ROOM.h/ZOOM));
  mapScaleX=screenRect.dw/cam.w; mapScaleY=screenRect.dh/cam.h;
  cam.x=clamp(cam.x,0,world.w-cam.w); cam.y=clamp(cam.y,0,world.h-cam.h);
  BACKBUF.width = canvas.width; BACKBUF.height = canvas.height;
}
addEventListener('resize',resize);
function centerCameraOnPlayer(){
  cam.x=clamp(player.x-cam.w/2,0,world.w-cam.w);
  cam.y=clamp(player.y-cam.h/2,0,world.h-cam.h);
}

  function cameraPanTo(x, y, ms=1200){
  CAM_TWEEN.on = true; CAM_TWEEN.t = 0; CAM_TWEEN.dur = ms;
  CAM_TWEEN.sx = cam.x; CAM_TWEEN.sy = cam.y;
  CAM_TWEEN.ex = clamp(x, 0, world.w - cam.w);
  CAM_TWEEN.ey = clamp(y, 0, world.h - cam.h);
}


/* ========== COLISIÓN ========== */
function ellipseRectOverlap(cx, cy, rx, ry, rect){
  const qx = clamp(cx, rect.x, rect.x + rect.w);
  const qy = clamp(cy, rect.y, rect.y + rect.h);
  const dx = (cx - qx) / rx;
  const dy = (cy - qy) / ry;
  return (dx*dx + dy*dy) <= 1;
}
function anyOverlap(cx, cy){
  for(const ob of OBSTACLES) if(ellipseRectOverlap(cx, cy + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) return true;
  return false;
}

/* ========== PROPS / OBSTÁCULOS ========== */
function getInteractHit(){
  for (const pr of PROPS){
    if(!pr.interacts) continue;
    for (const zone of pr.interacts){
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
        return zone; // devolvemos la zona encontrada
      }
    }
  }
  return null;
}

  function getNPCInteractHit(){
  for (const npc of NPCS){
    if (!npc.interacts) continue;
    for (const zone of npc.interacts){
      if (ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, zone)){
        return zone; // trae .dialog si existe
      }
    }
  }
  return null;
}


async function preloadCatalog(){
  const entries=Object.entries(CATALOG);
  const res=await Promise.all(entries.map(([k,v])=>loadImage(v.src).then(img=>[k,img])));
  res.forEach(([k,img])=>{ PROP_IMAGES[k]=img; });
}
function buildPropsAndObstacles(){
  PROPS=[]; OBSTACLES=[];
  for(const [type,list] of Object.entries(PLACED)){
    const spec=CATALOG[type]; const img=PROP_IMAGES[type];
    if(!spec || !list?.length) continue;
    for (const p of list) {
      const pos = (p.type === 'percent') ? percentToWorld(p) : { x: p.x, y: p.y };
      const prop = { type, img, x: pos.x, y: pos.y,
        iw: img ? img.naturalWidth : 32, ih: img ? img.naturalHeight : 32, scale: spec.scale || 1 };
      if (spec.collider){
        const c = spec.collider, s = prop.scale;
        const col = { x: prop.x + c.x*s, y: prop.y + (c.y*s) - (c.h*s), w: c.w*s, h: c.h*s };
        prop.collider = col; OBSTACLES.push({ ...col, name: type });
      }
      const s = prop.scale;
      const srcInteract = p.interact ?? spec.interact ?? null;

if (srcInteract){
  const inters = Array.isArray(srcInteract) ? srcInteract : [srcInteract];
  prop.interacts = inters.map(i => ({
    x: prop.x + i.x*s,
    y: prop.y + (i.y*s) - (i.h*s),
    w: i.w*s,
    h: i.h*s,
    say: (typeof i.say === 'string' ? i.say : (typeof p.say === 'string' ? p.say : null))
  }));
}

      if (typeof p.say === 'string') prop.say = p.say;

      PROPS.push(prop);
    }
  }
  for(const o of OBSTACLE_DEFS){
    const r=(o.type==='percent') ? { ...percentToWorld(o), w:Math.round(world.w*(o.w/100)), h:Math.round(world.h*(o.h/100)) } : o;
    OBSTACLES.push({x:r.x,y:r.y,w:r.w,h:r.h,name:o.name||'extra'});
  }
}


/* ========== AMBIENTE: zonas + overlay ========== */
function buildAmbientZones(){
  const out=[];
  for (const z of AMBIENT_ZONES){
    if (z.rect?.type==='percent'){
      out.push({
        ...z,
        x: Math.round(world.w*(z.rect.x/100)),
        y: Math.round(world.h*(z.rect.y/100)),
        w: Math.round(world.w*(z.rect.w/100)),
        h: Math.round(world.h*(z.rect.h/100)),
      });
    } else out.push({...z, x:z.rect.x, y:z.rect.y, w:z.rect.w, h:z.rect.h});
  }
  return out;
}
function feetWorld(){ return { x: player.x, y: player.y + FEET_OFFSET_Y }; }
function pointInRect(px,py,r){return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;}

/* === LINTERNA: helpers + draw === */
function dirToAngle(dir){
  switch(dir){
    case 'up': return -Math.PI/2;
    case 'down': return  Math.PI/2;
    case 'left': return  Math.PI;
    case 'right': return  0;
    default: return 0;
  }
}

function drawFlashlightEnhance(){
  if (!LIGHT.enabled) return;

  // tamaño y posición del jugador en pantalla
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);

  const t = performance.now() * 0.003;
  const flick = 1 + (Math.sin(t*2.3)+Math.sin(t*1.7))*0.5*LIGHT.flicker;

  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = LIGHT.brightness;

  // halo circular
  if (LIGHT.mode === 'circle' || LIGHT.mode === 'both'){
    const baseR = LIGHT.radius * Math.max(mapScaleX, mapScaleY);
    const R = baseR * flick;
    const inner = R * (1 - LIGHT.feather);
    const g = ctx.createRadialGradient(jx, jy, inner, jx, jy, R);
    g.addColorStop(0.00, `rgba(${LIGHT.tint}, 0.95)`);
    g.addColorStop(0.50, `rgba(${LIGHT.tint}, 0.35)`);
    g.addColorStop(1.00,  'rgba(255,255,255, 0.00)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(jx, jy, R, 0, Math.PI*2); ctx.fill();
  }

  // haz cónico
  if (LIGHT.mode === 'cone' || LIGHT.mode === 'both'){
    const ang = dirToAngle(player.dir);
    const len = LIGHT.coneLen * Math.max(mapScaleX, mapScaleY);
    const half = LIGHT.coneWidth * 0.5;

    ctx.save();
    ctx.translate(jx, jy);
    ctx.rotate(ang);

    const lg = ctx.createLinearGradient(0, 0, len, 0);
    lg.addColorStop(0.00, `rgba(${LIGHT.tint}, 0.70)`);
    lg.addColorStop(0.25, `rgba(${LIGHT.tint}, 0.38)`);
    lg.addColorStop(1.00,  'rgba(255,255,255, 0.00)');
    ctx.fillStyle = lg;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(len,  Math.tan(half)*len);
    ctx.lineTo(len, -Math.tan(half)*len);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  ctx.restore();
}

/* Gradientes por paleta */
function makePaletteGradient(palette){
  const g = ctx.createLinearGradient(screenRect.dx, screenRect.dy, screenRect.dx, screenRect.dy + screenRect.dh);
  if (palette === 'bluehour'){
    g.addColorStop(0.00, '#0A516B');
    g.addColorStop(0.50, '#164D8C');
    g.addColorStop(1.00, '#0C3F62');
    return { gradient:g, mode:'multiply', alpha:0.85 };
  }
  if (palette === 'hell'){
    // Evitamos rojo puro con multiply (apagaba todo). Usamos screen y tonos cálidos.
    g.addColorStop(0.00, '#EB9460');
    g.addColorStop(0.55, '#DF5800');
    g.addColorStop(1.00, '#DF5800');
    return { gradient:g, mode:'multiply', alpha:0.45 };
  }
  // peach (base)
  g.addColorStop(0.00, '#FB557C');
  g.addColorStop(0.55, '#FB557C');
  g.addColorStop(1.00, '#DF5800');
  return { gradient:g, mode:'multiply', alpha:0.65 };
}

function drawPalette(palette, alphaScale){
  if (alphaScale <= 0) return;
  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  const { gradient, mode, alpha } = makePaletteGradient(palette);
  ctx.globalCompositeOperation = mode;
  ctx.globalAlpha = Math.min(1, alpha * alphaScale);
  ctx.fillStyle = gradient;
  ctx.fillRect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  ctx.restore();
}

  // ========== CINEMÁTICA 1 ==========
function startCinematic1(){
  CUT.active = true; CUT.id='cine1'; CUT.phase='lock';
  ambientLock = true; player.moving=false;

  // F1: bloquea y muestra "¿Qué pasa?"
  openDialog([{speaker:'Juan', text:'¿Qué pasa?'}], true);

  // Acción → cerrar y pasar a F2 (niebla)
  CUT.hijackAction = ()=>{
    closeCurrentDialogNow();
    CUT.hijackAction = null;
    phaseFogFill();
  };

  function phaseFogFill(){
    CUT.phase='fogFill';
    fogBeginFill(3000, {
  mode: 'sweep',
  baseAlpha: 0.88,           // bien opaco
  density: 0.4,              // menos partículas mientras llena → menos parpadeo
  // foco un poco por encima del centro para “zona Gandalf”
  focusY: screenRect.dy + screenRect.dh * 0.28
});
    const check = ()=>{
      if (!CUT.active || CUT.id!=='cine1') return;
      if (FOG.filling) requestAnimationFrame(check);
      else phaseCameraPan();
    };
    requestAnimationFrame(check);
  }

  function phaseCameraPan(){
  CUT.phase='pan';
  const targetY = clamp(cam.y - 70, 0, world.h - cam.h);

  // 1) Pan SOLO cámara
  cameraPanTo(cam.x, targetY, 1200);

  // 2) Spawnea a Gandalf mini ya pensando en el encuadre destino
  spawnTempGandalfAhead(targetY);

  // 3) Espera al fin del pan
  const waitPan = setInterval(()=>{
    if (!CAM_TWEEN.on){
      clearInterval(waitPan);
      phaseJuanAutoWalk();
    }
  }, 16);
}

function spawnTempGandalfAhead(targetCamY){
  const gx = player.x;
  const gy = targetCamY + cam.h/2 - 40; // más cerca del centro → seguro en pantalla
  const iw = IMG_GANDALF_SMALL ? IMG_GANDALF_SMALL.naturalWidth  : 32;
  const ih = IMG_GANDALF_SMALL ? IMG_GANDALF_SMALL.naturalHeight : 32;

  const npc = {
    id:'gandalf_temp', type:'gandalf_temp', img: IMG_GANDALF_SMALL,
    x: gx, y: gy, iw, ih,
    scale: 0.55,                   // más visible
    depthBand: DEPTH_BAND, depthAnchorY: 1,
    _debug: true                // flag para overlay de depuración
  };

  NPCS.push(npc);
}



  function phaseJuanAutoWalk(){
  CUT.phase='autowalk';
  // Objetivo: centro vertical de la cámara YA paneada
  const targetY = cam.y + cam.h/2;
  const startY  = player.y;
  const dy = targetY - startY;
  const dur = Math.max(400, Math.min(1200, Math.abs(dy)*6));
  const t0  = performance.now();

  (function step(){
    if (!CUT.active || CUT.id!=='cine1') return;
    const t = Math.min(1, (performance.now()-t0)/dur);
    player.y = startY + dy*t;
    if (t<1) requestAnimationFrame(step);
    else phaseWorldDialogue();
  })();
}


  function phaseWorldDialogue(){
    CUT.phase='worldTalk';
    const script = [
      {speaker:'Juan', text:'?'},
      {speaker:'???',  text:'Hola, muchacho.'},
      {speaker:'Juan', text:'No me digas que eres...'}
    ];
    let idx = 0;
    openDialog([script[idx]], true);
    CUT.hijackAction = ()=>{
      if (dialogOpen){ advanceDialog(); return; }
      idx++;
      if (idx < script.length){
        openDialog([script[idx]], true);
      } else {
        CUT.hijackAction = null;
        phasePortraits();
      }
    };
  }

  function phasePortraits(){
    CUT.phase='cineOverlay';
    const cineScript = [
      { speaker:'Gandalf', text:'Gandalf el Gris.' },
      { speaker:'Juan',    text:'Wow.' }
    ];
    portraitsOpen(cineScript);
    CUT.onEnd = ()=>{ fadeOutFogThenEnd(); };
  }

  function fadeOutFogThenEnd(){
    CUT.phase='fadeFog';
    let t0 = performance.now(), dur=800;
    function tick(){
      if (!CUT.active || CUT.id!=='cine1') return;
      const k = Math.min(1, (performance.now()-t0)/dur);
      FOG.fillT = (1-k)*FOG.fillT;
      for (const p of FOG.parts) p.alpha *= (1 - 0.85*k);
      if (k<1) requestAnimationFrame(tick);
      else {
        fogStop();
        const i = NPCS.findIndex(n=>n.id==='gandalf_temp');
        if (i>=0) NPCS.splice(i,1);
        endCine();
      }
    }
    requestAnimationFrame(tick);
  }

  function endCine(){
    CUT.active=false; CUT.id=null; CUT.phase=null; CUT.hijackAction=null; CUT.onEnd=null;
    ambientLock=false;
  }
}

  
/* ========== MOVIMIENTO / MEGAUPDATE ========== */
function cornerSlide(targetX, targetY, vx, vy){
  const SLIDE = 3;
  if(Math.abs(vx) > Math.abs(vy)){
    for(const off of [-SLIDE, SLIDE]){
      const ty = clamp(player.y + off, 0, world.h);
      if(!anyOverlap(targetX, ty)){ player.y = ty; player.x = targetX; return true; }
    }
  } else {
    for(const off of [-SLIDE, SLIDE]){
      const tx = clamp(player.x + off, 0, world.w);
      if(!anyOverlap(tx, targetY)){ player.x = tx; player.y = targetY; return true; }
    }
  }
  return false;
}
  
function nudgeOut(){
  let moved = false;
  for(const ob of OBSTACLES){
    if(!ellipseRectOverlap(player.x, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)) continue;
    const qx = clamp(player.x, ob.x, ob.x + ob.w);
    const qy = clamp(player.y + FEET_OFFSET_Y, ob.y, ob.y + ob.h);
    let dx = player.x - qx, dy = (player.y + FEET_OFFSET_Y) - qy;
    const ndx = dx / FEET_RADIUS_X, ndy = dy / FEET_RADIUS_Y;
    const len = Math.hypot(ndx, ndy) || 1e-6;
    const overlap = 1 - len + 0.001;
    if(overlap > 0){
      const pushX = (ndx/len) * overlap * FEET_RADIUS_X;
      const pushY = (ndy/len) * overlap * FEET_RADIUS_Y;
      player.x += pushX; player.y += pushY; moved = true;
    }
  }
  return moved;
}

function update(dt){
  const vx = (keys.left?-1:0) + (keys.right?1:0);
  const vy = (keys.up?-1:0) + (keys.down?1:0);

  if (!dialogOpen && ambientLock && !ambientLockOwner) ambientLock = false;

  // Intro: sube intensidad global y lanza primer diálogo
  if (introActive){
    AMBIENT.k = Math.min(1, AMBIENT.k + dt / (AMBIENT.introMs / 1000));
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
if (canCenterCam) centerCameraOnPlayer();




    if (AMBIENT.k >= 1 && !initialDialogShown){
      initialDialogShown = true;
      setTimeout(()=>{
        openDialog([{speaker:'Juan', text:'Se está haciendo tarde...'}], true);
        introActive = false;
      }, 300);
    }
    return;
  }

  if (!CUT.active){
  const feet = feetWorld();
  const cz = CINE_BUILT.find(z=> !z._done && feet.x>=z.x && feet.x<=z.x+z.w && feet.y>=z.y && feet.y<=z.y+z.h);
  if (cz && cz.id==='cine1'){
    cz._done = true;
    startCinematic1();
    return;
  }
}

  if (dialogOpen){
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
if (canCenterCam) centerCameraOnPlayer();

    return;
  }

  if (ambientLock){
    player.moving = false; player.frame = 0;
    const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
if (canCenterCam) centerCameraOnPlayer();

  }


portraitsUpdate(dt);
if (CAM_TWEEN.on){
  CAM_TWEEN.t = Math.min(1, CAM_TWEEN.t + dt*1000 / CAM_TWEEN.dur);
  const ease = (x)=> x<0.5 ? 2*x*x : 1 - Math.pow(-2*x+2,2)/2;
  const k = ease(CAM_TWEEN.t);
  cam.x = CAM_TWEEN.sx + (CAM_TWEEN.ex - CAM_TWEEN.sx)*k;
  cam.y = CAM_TWEEN.sy + (CAM_TWEEN.ey - CAM_TWEEN.sy)*k;
  if (CAM_TWEEN.t>=1) CAM_TWEEN.on=false;
}

  // Movimiento
  const wantsToMove = !!(vx || vy);
  player.moving = !ambientLock && wantsToMove;

  if (player.moving){
    player.dir = Math.abs(vx) > Math.abs(vy) ? (vx < 0 ? 'left' : 'right') : (vy < 0 ? 'up' : 'down');
    const len   = Math.hypot(vx, vy) || 1;
    const stepx = (vx/len) * player.speed * dt;
    const stepy = (vy/len) * player.speed * dt;

    const s = JUAN.scale, halfW = Math.round(JUAN.size.w*s)/2, halfH = Math.round(JUAN.size.h*s)/2;
    const nx = clamp(player.x + stepx, halfW, world.w - halfW);
    const ny = clamp(player.y + stepy, halfH, world.h - halfH);

    let blockedX = false, blockedY = false;
    for (const ob of OBSTACLES) if (ellipseRectOverlap(nx, player.y + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedX = true; break; }
    if (!blockedX) player.x = nx;
    for (const ob of OBSTACLES) if (ellipseRectOverlap(player.x, ny + FEET_OFFSET_Y, FEET_RADIUS_X, FEET_RADIUS_Y, ob)){ blockedY = true; break; }
    if (!blockedY) player.y = ny;

    if (blockedX && blockedY){
      if (!cornerSlide(nx, ny, stepx, stepy)) nudgeOut();
    }

    player.frameTime += dt;
    if (player.frameTime >= 0.12){ player.frame = (player.frame + 1) % 2; player.frameTime = 0; }
  } else {
    player.frame = 0;
  }

  if (!ambientLock) nudgeOut();

  const canCenterCam = !CUT.active && !CAM_TWEEN.on && !dialogOpen && !ambientLock;
if (canCenterCam) centerCameraOnPlayer();

  fogUpdate(dt);

  // Zonas
  const feet = feetWorld();
  const newZone = AMBIENT_BUILT.find(z => pointInRect(feet.x, feet.y, z));
  const prevZone = _ambientCurrentZone;

  // Cambio de zona
  if (newZone !== prevZone){
    // limpiar anterior
    if (prevZone){
      if (ambientLockOwner === prevZone){
        ambientLock = false;
        ambientLockOwner = null;
      }
      clearTimeout(prevZone._lockTO);
      clearTimeout(prevZone._dialogTO);
    }

    // bloqueo SOLO si habrá diálogo y solo primera vez
    if (newZone){
      const willShowDialog =
        Array.isArray(newZone.dialogOnEnter) &&
        newZone.dialogOnEnter.length > 0 &&
        !newZone._dialogShown;

      const lockMs   = newZone.lockMs ?? 0;
      const talkWait = newZone.dialogDelayMs ?? 0;

      if (willShowDialog && lockMs > 0){
        ambientLock = true;
        ambientLockOwner = newZone;
        newZone._lockTO = setTimeout(() => {
          if (!newZone._dialogShown){
            newZone._dialogShown = true;
            newZone._dialogTO = setTimeout(() => openDialog(newZone.dialogOnEnter, true), talkWait);
          }
        }, lockMs);
      } else if (willShowDialog){
        newZone._dialogShown = true;
        newZone._dialogTO = setTimeout(() => openDialog(newZone.dialogOnEnter, true), talkWait);
      }
    }

    // Objetivos de paleta (crossfade sin saltos)
const targetPal = newZone ? newZone.palette : 'peach';
AMBIENT.targets.peach    = (targetPal === 'peach')    ? 1 : 0;
AMBIENT.targets.bluehour = (targetPal === 'bluehour') ? 1 : 0;
AMBIENT.targets.hell     = (targetPal === 'hell')     ? 1 : 0;

    _ambientCurrentZone = newZone;
  }

 // Sube la intensidad global durante la intro
// (si prefieres que solo suba en intro, deja como lo tenías)
AMBIENT.k = Math.min(1, AMBIENT.k + dt / (AMBIENT.introMs / 1000));

// Interpolar alphas hacia sus objetivos (crossfade continuo)
for (const key of Object.keys(AMBIENT.alphas)) {
  const a = AMBIENT.alphas[key];
  const t = AMBIENT.targets[key];
  AMBIENT.alphas[key] = (AMBIENT.fadeMs <= 0)
    ? t
    : a + (t - a) * Math.min(1, (dt * 1000) / AMBIENT.fadeMs);
}

}

/* ========== MEGADRAW ========== */
function draw(){
  if(!bgImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  let sx = Math.round(cam.x), sy = Math.round(cam.y);
  sx = clamp(sx, 0, world.w - cam.w);
  sy = clamp(sy, 0, world.h - cam.h);
  ctx.drawImage(bgImg, sx, sy, cam.w, cam.h, screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);

  ctx.save();
  ctx.beginPath();
  ctx.rect(screenRect.dx, screenRect.dy, screenRect.dw, screenRect.dh);
  ctx.clip();

  // jugador en coords pantalla
  const sw = JUAN.size.w, sh = JUAN.size.h, s = JUAN.scale;
  const jw = Math.round(sw*s), jh = Math.round(sh*s);
  const jx = Math.round(screenRect.dx + (player.x - cam.x) * mapScaleX);
  const jy = Math.round(screenRect.dy + (player.y - cam.y) * mapScaleY);
  const jFoot = jy + jh/2;

  const list = [];
  // props
  for(const p of PROPS){
    const px = screenRect.dx + (p.x - cam.x) * mapScaleX;
    const py = screenRect.dy + (p.y - cam.y) * mapScaleY;
    const dw = Math.round(p.iw * p.scale * mapScaleX);
    const dh = Math.round(p.ih * p.scale * mapScaleY);
    const dx = Math.round(px - dw/2), dy = Math.round(py - dh);
    const spec = CATALOG[p.type] || {};
    const band = spec.depthBand ?? DEPTH_BAND;
    const anchor = (spec.depthAnchorY ?? 0) * mapScaleY;
    const pyCut = py + anchor;

    const sortY = spec.forceBack ? -9999 :
                  (jFoot < pyCut - band) ? (py + 0.5) :
                  (jFoot > pyCut + band) ? (py - 0.5) :
                  py;

    list.push({
      y: sortY,
      draw: ()=>{
        if(!p.img){ ctx.fillStyle='#777'; ctx.fillRect(dx,dy,dw,dh); ctx.strokeStyle='#222'; ctx.strokeRect(dx,dy,dw,dh); return; }
        if(spec.flipX){ ctx.save(); ctx.scale(-1,1); ctx.drawImage(p.img, 0,0, p.iw,p.ih, -dx-dw, dy, dw, dh); ctx.restore(); }
        else { ctx.drawImage(p.img, 0,0, p.iw,p.ih, dx,dy, dw,dh); }
      }
    });
  }


  fogDraw();

  // NPCs
for (const n of NPCS){
  const px = screenRect.dx + (n.x - cam.x) * mapScaleX;
  const py = screenRect.dy + (n.y - cam.y) * mapScaleY;
  const dw = Math.round(n.iw * n.scale * mapScaleX);
  const dh = Math.round(n.ih * n.scale * mapScaleY);
  const dx = Math.round(px - dw/2);
  const dy = Math.round(py - dh);

  const band   = n.depthBand ?? DEPTH_BAND;
  const anchor = (n.depthAnchorY ?? 0) * mapScaleY;
  const pyCut  = py + anchor;

  const sortY = (jFoot < pyCut - band) ? (py + 0.5) :
                (jFoot > pyCut + band) ? (py - 0.5) :
                py;

list.push({
  y: sortY,
  draw: () => {

const sh = (n.shadow || DEFAULT_SHADOW);
const footX = Math.round(px);
const footY = Math.round(py); // base real del sprite
const shadowW = Math.max(6, Math.round(dw * sh.scaleX));
const shadowH = Math.max(3, Math.round(dh * sh.scaleY));

ctx.save();
ctx.globalAlpha = sh.alpha;
ctx.fillStyle = 'black';
ctx.beginPath();
ctx.ellipse(footX, footY + sh.offsetY, shadowW, shadowH, 0, 0, Math.PI * 2);
ctx.fill();
ctx.restore();

// --- sprite encima ---
if (!n.img) {
  ctx.fillStyle = '#999';
  ctx.fillRect(dx, dy, dw, dh);
} else {
  ctx.drawImage(n.img, 0, 0, n.iw, n.ih, dx, dy, dw, dh);
}


    // --- FX disparo encima del sprite ---
    if (isNPCFxActive(n)) {
      // coordenadas del fogonazo
      const mx = Math.round(px + (n.muzzleOffset.x * mapScaleX));
      const my = Math.round(py + (n.muzzleOffset.y * mapScaleY));

      // pequeño flash radial
      const r = Math.max(10, 18 * Math.max(mapScaleX, mapScaleY));
      const g = ctx.createRadialGradient(mx, my, 0, mx, my, r);
      g.addColorStop(0, 'rgba(255, 240, 200, .95)');
      g.addColorStop(0.5, 'rgba(255, 200, 80, .55)');
      g.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(mx, my, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }
  }
});

}

  // jugador con “respiración” en idle (pies pegados al suelo)
list.push({
  y: jFoot,
  draw: () => {
    const img = player.moving ? sprites.walk[player.dir][player.frame] : sprites.idle[player.dir][0];

    // sombra en el suelo (siempre en el suelo)
    const footX = Math.round(jx);
    const footY = Math.round(jy + jh/2);
    ctx.fillStyle = 'rgba(0,0,0,.3)';
    ctx.beginPath();
    ctx.ellipse(footX, footY - 4, jw/2.5, jh/6, 0, 0, Math.PI*2);
    ctx.fill();

    // respiración: squash & stretch muy sutil, anclado a los pies
    const canBreathe = !player.moving && !dialogOpen && !ambientLock && !introActive;
    const phase  = canBreathe ? Math.sin(_nowSec * BREATH.speed) : 0;
    const sY     = 1 + phase * BREATH.scaleAmp;      // estira/encoge en vertical
    const sX     = 1 - phase * BREATH.scaleAmp*0.6;  // compensa un pelín en horizontal
    const compY  = (1 - sY) * jh;                    // al escalar, el “bottom” subiría: empuja hacia abajo

    ctx.save();
    // ancla: pies
    ctx.translate(footX, footY);
    // compensa para que la suela no se mueva
    ctx.translate(0, compY);
    ctx.scale(sX, sY);

    // dibuja alineado por abajo (bottom = 0), centrado en X
    ctx.drawImage(
      img, 0, 0, sw, sh,
      Math.round(-jw/2), -jh,
      jw, jh
    );
    ctx.restore();
  }
});

  // pintar ordenado
  list.sort((a,b)=>a.y - b.y).forEach(it=>it.draw());
  ctx.restore();

  /* --- AMBIENT OVERLAYS (alphas por paleta) --- */
if (AMBIENT.k > 0.001){
  // Orden estable por modos de mezcla
  const order = ['peach','bluehour','hell'];
  for (const pal of order){
    const a = AMBIENT.alphas[pal] || 0;
    if (a > 0.001) drawPalette(pal, a * AMBIENT.k);
  }
}
  /* --- LINTERNA encima --- */
  drawFlashlightEnhance();


  // DEBUG AMBIENT
  if (DEBUG_AMBIENT && AMBIENT_BUILT.length){
    ctx.save();
    ctx.globalAlpha = 0.30;
    for (const z of AMBIENT_BUILT){
      const dx = screenRect.dx + (z.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (z.y - cam.y) * mapScaleY;
      const dw = z.w * mapScaleX, dh = z.h * mapScaleY;
      ctx.fillStyle = (z.palette==='bluehour') ? '#66a3ff' : '#ff66aa';
      ctx.fillRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = '#ffffff';
      ctx.strokeRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 12px monospace';
      ctx.fillText(z.name || z.palette || 'zone', Math.round(dx)+4, Math.round(dy)+14);
      ctx.globalAlpha = 0.30;
    }
    ctx.restore();
  }

  // DEBUG obstáculos
  if(DEBUG_OBS){
    ctx.save();
    ctx.globalAlpha = .5; ctx.fillStyle = '#ff3366'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
    for(const ob of OBSTACLES){
      const dx = screenRect.dx + (ob.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (ob.y - cam.y) * mapScaleY;
      const dw = ob.w * mapScaleX, dh = ob.h * mapScaleY;
      ctx.fillRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      ctx.strokeRect(Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    }
    ctx.restore();
  }

// DEBUG ZONAS INTERACCIÓN
if (DEBUG_INTER){
  ctx.save();
  ctx.globalAlpha = .45;

  // Props: azul
  ctx.fillStyle = '#33ccff';
  ctx.strokeStyle = '#00334d';
  for (const p of PROPS){
    if (!p.interacts) continue;
    for (const r of p.interacts){
      const dx = screenRect.dx + (r.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (r.y - cam.y) * mapScaleY;
      const dw = r.w * mapScaleX, dh = r.h * mapScaleY;
      ctx.fillRect(Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));
      ctx.strokeRect(Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));
    }
  }

  // NPCs: verde
  ctx.fillStyle = 'rgba(0,255,120,0.45)';
  ctx.strokeStyle = '#024d2a';
  for (const n of NPCS){
    if (!n.interacts) continue;
    for (const r of n.interacts){
      const dx = screenRect.dx + (r.x - cam.x) * mapScaleX;
      const dy = screenRect.dy + (r.y - cam.y) * mapScaleY;
      const dw = r.w * mapScaleX, dh = r.h * mapScaleY;
      ctx.fillRect(Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));
      ctx.strokeRect(Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));
    }
  }

  ctx.restore();
}



  // DEBUG zonas de cinemática
if (DEBUG_CINE && CINE_BUILT.length){
  ctx.save();
  ctx.globalAlpha = 0.45; ctx.fillStyle='#ff00ff'; ctx.strokeStyle='#660066'; ctx.lineWidth=2;
  for(const z of CINE_BUILT){
    const dx = screenRect.dx + (z.x - cam.x) * mapScaleX;
    const dy = screenRect.dy + (z.y - cam.y) * mapScaleY;
    const dw = z.w * mapScaleX, dh = z.h * mapScaleY;
    ctx.fillRect(Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));
    ctx.strokeRect(Math.round(dx),Math.round(dy),Math.round(dw),Math.round(dh));
    ctx.globalAlpha=0.95; ctx.fillStyle='#fff'; ctx.font='bold 12px monospace';
    ctx.fillText(z.id, Math.round(dx)+4, Math.round(dy)+14);
    ctx.globalAlpha=0.45; ctx.fillStyle='#ff00ff';
  }
  ctx.restore();
}




portraitsDrawOverlay();

  }
/* ========== LOOP / MEGAINIT ========== */
function loop(t){ if(!loop.last) loop.last=t; const dt=Math.min(1/60,(t-loop.last)/1000); loop.last=t; _nowSec = t / 1000;  update(dt); draw(); requestAnimationFrame(loop); }

async function init(){
  const [bg,spr] = await Promise.all([loadImage(BG_SRC), preloadSprites(JUAN)]);
  bgImg=bg; sprites=spr;
  await preloadCatalog();
  await preloadNPCs();
  await preloadCinematicImages();

  world.w=bgImg.naturalWidth; world.h=bgImg.naturalHeight;
  CINE_BUILT = buildCineZones();
  AMBIENT_BUILT = buildAmbientZones();
  resize();

  const s=JUAN.scale; const halfW=Math.round(JUAN.size.w*s)/2, halfH=Math.round(JUAN.size.h*s)/2;
  if(START.mode==='percent'){ player.x=world.w*(START.x/100); player.y=world.h*(START.y/100); } else { player.x=START.x; player.y=START.y; }
  player.x=clamp(player.x,halfW,world.w-halfW); player.y=clamp(player.y,halfH,world.h-halfH);
  player.dir='down'; player.moving=false; player.frame=0; player.frameTime=0;
  keys.up=keys.down=keys.left=keys.right=false;

  buildPropsAndObstacles();
    buildNPCs();                  // << NUEVO

  centerCameraOnPlayer();

  // Arranque del ambiente base desde 0 con fade
  AMBIENT.k = 0;
AMBIENT.alphas  = { peach:1, bluehour:0, hell:0 };
AMBIENT.targets = { peach:1, bluehour:0, hell:0 };
  requestAnimationFrame(loop);
  // fade negro inicial
setTimeout(()=> document.getElementById('blackfade').classList.add('hide'), 100);

}
init();
</script>
</body>
</html>
