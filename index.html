<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Minijuego con colisiones escaladas</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .gameboy {
    width: 100%;
    max-width: 500px;
    height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    padding: 12px;
    box-sizing: border-box;
    border-radius: 20px;
    box-shadow: 0 0 40px rgba(0,0,0,0.6);
  }
  .screen-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #0B0A21;
    border-radius: 12px;
    padding: 10px;
  }
  .screen {
    aspect-ratio: 1/1; /* Proporción exacta de la imagen */
    width: 100%;
    background: #0B0A21;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.6);
  }
  canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: black;
  }
  .controls {
    height: 40%;
    background: #0B0A21;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    padding: 14px;
  }
  .dpad {
    display: grid;
    grid-template-columns: repeat(3, 64px);
    grid-template-rows: repeat(3, 64px);
    gap: 8px;
    justify-content: center;
    align-content: center;
  }
  .btn, .act {
    border: none;
    border-radius: 16px;
    background: linear-gradient(180deg, #1b1c24, #0d0e14);
    color: #e5e7eb;
    font-size: 16px;
    font-weight: 600;
    box-shadow: 0 6px 20px rgba(0,0,0,.45),
                inset 0 0 0 1px rgba(255,255,255,.06);
    display: grid;
    place-items: center;
    outline: none;
    transition: transform .05s ease;
  }
  .btn:active, .act:active { transform: translateY(2px); }
  .btn { width: 64px; height: 64px; }
  .btn span { font-size: 26px; }
  .act {
    width: 120px; height: 120px;
    margin: auto;
    letter-spacing: .5px;
  }
</style>
</head>
<body>

<div class="gameboy">
  <div class="screen-container">
    <div class="screen">
      <canvas id="game"></canvas>
    </div>
  </div>
  <div class="controls">
    <div class="dpad">
      <div></div>
      <button class="btn" id="btn-up"><span>▲</span></button>
      <div></div>
      <button class="btn" id="btn-left"><span>◀</span></button>
      <div></div>
      <button class="btn" id="btn-right"><span>▶</span></button>
      <div></div>
      <button class="btn" id="btn-down"><span>▼</span></button>
      <div></div>
    </div>
    <button class="act" id="btn-act">ACCIÓN</button>
  </div>
</div>

<script>
const SPRITES = {
  size: { w: 36, h: 40 },
  scale: 1,
  idle: {
    down:  ["assets/juan_character/idle_down.png"],
    up:    ["assets/juan_character/idle_up.png"],
    left:  ["assets/juan_character/idle_left.png"],
    right: ["assets/juan_character/idle_right.png"],
  },
  walk: {
    down:  ["assets/juan_character/walk_down_0.png",  "assets/juan_character/walk_down_1.png"],
    up:    ["assets/juan_character/walk_up_0.png",    "assets/juan_character/walk_up_1.png"],
    left:  ["assets/juan_character/walk_left_0.png",  "assets/juan_character/walk_left_1.png"],
    right: ["assets/juan_character/walk_right_0.png", "assets/juan_character/walk_right_1.png"],
  }
};
const BACKGROUND = "assets/locations/room.png";
let bgImg = null;

const SOFA_IMG = "assets/sofa.png";
let sofaImg = null;

// Tamaño original del PNG de la habitación
const roomOriginal = { w: 512, h: 412 }; 

// Definir en coordenadas originales
const boundsBase = { x: 15, y: 135, w: 490, h: 230 };
const obstaclesBase = [
  { x: 50, y: 60, w: 80, h: 40 },
  { x: 20, y: 40, w: 30, h: 60 },
];

const sofaPosBase = { x: 200, y: 300, w: 100, h: 50 };
let sofaPos = {};

let bounds = {};
let obstacles = [];
let scaleFactor = 1;

function updateScaledBounds() {
  bounds = {
    x: boundsBase.x * scaleFactor,
    y: boundsBase.y * scaleFactor,
    w: boundsBase.w * scaleFactor,
    h: boundsBase.h * scaleFactor
  };
  sofaPos = {
  x: sofaPosBase.x * scaleFactor,
  y: sofaPosBase.y * scaleFactor,
  w: sofaPosBase.w * scaleFactor,
  h: sofaPosBase.h * scaleFactor
  };
  obstacles = obstaclesBase.map(o => ({
    x: o.x * scaleFactor,
    y: o.y * scaleFactor,
    w: o.w * scaleFactor,
    h: o.h * scaleFactor
  }));
}

const loadImage = (src) => new Promise(res => {
  const img = new Image();
  img.onload = () => res(img);
  img.onerror = () => res(null);
  img.src = src;
});
async function preloadSprites(map) {
  const result = { idle: {}, walk: {} };
  for (const state of ["idle","walk"]) {
    for (const dir of Object.keys(map[state])) {
      result[state][dir] = await Promise.all(map[state][dir].map(loadImage));
    }
  }
  return result;
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

function resizeCanvas() {
  const screen = document.querySelector('.screen');
  canvas.width = screen.clientWidth;
  canvas.height = screen.clientHeight;
  if (bgImg) {
    scaleFactor = Math.min(canvas.width / roomOriginal.w, canvas.height / roomOriginal.h);
    updateScaledBounds();
  }
}
window.addEventListener('resize', resizeCanvas);

const player = { x:0, y:0, speed:200, dir:'down', moving:false, frame:0, frameTime:0 };
const keys = { up:false, down:false, left:false, right:false };

function bindHold(btn, on, off) {
  const start = e => { e.preventDefault(); on(); };
  const end   = e => { e.preventDefault(); off(); };
  btn.addEventListener('touchstart', start, {passive:false});
  btn.addEventListener('touchend', end, {passive:false});
  btn.addEventListener('touchcancel', end, {passive:false});
  btn.addEventListener('mousedown', start);
  window.addEventListener('mouseup', end);
}
bindHold(document.getElementById('btn-up'),    () => keys.up=true,    () => keys.up=false);
bindHold(document.getElementById('btn-down'),  () => keys.down=true,  () => keys.down=false);
bindHold(document.getElementById('btn-left'),  () => keys.left=true,  () => keys.left=false);
bindHold(document.getElementById('btn-right'), () => keys.right=true, () => keys.right=false);

const mapKey = { ArrowUp:'up', KeyW:'up', ArrowDown:'down', KeyS:'down', ArrowLeft:'left', KeyA:'left', ArrowRight:'right', KeyD:'right' };
window.addEventListener('keydown', e => { const d=mapKey[e.code]; if(d){keys[d]=true; e.preventDefault();}});
window.addEventListener('keyup',   e => { const d=mapKey[e.code]; if(d){keys[d]=false; e.preventDefault();}});

function collides(x, y) {
  const halfW = SPRITES.size.w * SPRITES.scale / 2;
  const halfH = SPRITES.size.h * SPRITES.scale / 2;
  const px = x - halfW;
  const py = y - halfH;
  const pw = halfW * 2;
  const ph = halfH * 2;
  if (x < bounds.x || x > bounds.x + bounds.w ||
      y < bounds.y || y > bounds.y + bounds.h) {
    return true;
  }
  for (const o of obstacles) {
    if (px < o.x + o.w && px + pw > o.x &&
        py < o.y + o.h && py + ph > o.y) {
      return true;
    }
  }
  return false;
}

let assets = null;
function update(dt){
  const vx = (keys.left?-1:0)+(keys.right?1:0);
  const vy = (keys.up?-1:0)+(keys.down?1:0);
  player.moving = vx!==0 || vy!==0;

  if(player.moving){
    if(Math.abs(vx)>Math.abs(vy)) player.dir = vx<0?'left':'right';
    else if(Math.abs(vy)>0)       player.dir = vy<0?'up':'down';
    const len = Math.hypot(vx,vy)||1;
    const nx = (vx/len)*player.speed*dt;
    const ny = (vy/len)*player.speed*dt;

    const newX = player.x + nx;
    const newY = player.y + ny;

    if(!collides(newX, newY)){
      player.x = newX;
      player.y = newY;
    }

    player.frameTime += dt;
    if(player.frameTime>=0.14){ player.frame=(player.frame+1)%2; player.frameTime=0; }
  } else player.frame=0;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 1. Fondo
  if(bgImg){
    const s = Math.min(canvas.width / roomOriginal.w, canvas.height / roomOriginal.h);
    const dw = roomOriginal.w * s;
    const dh = roomOriginal.h * s;
    const dx = (canvas.width - dw) / 2;
    const dy = (canvas.height - dh) / 2;
    ctx.drawImage(bgImg, dx, dy, dw, dh);

    // Guardamos offset del fondo (para saber dónde colocar cosas)
    bgOffsetX = dx;
    bgOffsetY = dy;
  }

  if(!assets) return;

  const sw = SPRITES.size.w, sh = SPRITES.size.h;
  const dw = sw * SPRITES.scale, dh = sh * SPRITES.scale;
  const img = player.moving ? assets.walk[player.dir][player.frame] : assets.idle[player.dir][0];

  // 2. Si el personaje está "detrás" del sofá → lo dibujamos primero
  if (player.y < sofaPos.y + sofaPos.h/2) {
    ctx.drawImage(img, 0, 0, sw, sh, player.x - dw/2, player.y - dh/2, dw, dh);
    ctx.drawImage(sofaImg, sofaPos.x, sofaPos.y, sofaPos.w, sofaPos.h);
  } 
  // 3. Si está "delante" → dibujamos sofá primero y luego personaje
  else {
    ctx.drawImage(sofaImg, sofaPos.x, sofaPos.y, sofaPos.w, sofaPos.h);
    ctx.drawImage(img, 0, 0, sw, sh, player.x - dw/2, player.y - dh/2, dw, dh);
  }
}


function loop(now){
  if(!loop.last) loop.last=now;
  const dt = Math.min(1/30,(now-loop.last)/1000);
  loop.last=now;
  update(dt); draw();
  requestAnimationFrame(loop);
}

[bgImg, sofaImg, assets] = await Promise.all([
  loadImage(BACKGROUND),
  loadImage(SOFA_IMG),
  preloadSprites(SPRITES)
]);

  resizeCanvas();
  player.x = canvas.width/2;
  player.y = canvas.height/2;
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
