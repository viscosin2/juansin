<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Minijuego con colisiones escaladas</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .gameboy {
    width: 100%;
    max-width: 500px;
    height: 100%;
    background: #000;
    display: flex;
    flex-direction: column;
    padding: 12px;
    box-sizing: border-box;
    border-radius: 20px;
    box-shadow: 0 0 40px rgba(0,0,0,0.6);
  }
  .screen-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #0B0A21;
    border-radius: 12px;
    padding: 10px;
  }
  .screen {
    aspect-ratio: 1/1;
    width: 100%;
    background: #0B0A21;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.6);
  }
  canvas {
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: black;
  }
  .controls {
    height: 40%;
    background: #0B0A21;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    padding: 14px;
  }
  .dpad {
    display: grid;
    grid-template-columns: repeat(3, 64px);
    grid-template-rows: repeat(3, 64px);
    gap: 8px;
    justify-content: center;
    align-content: center;
  }
  .btn, .act {
    border: none;
    border-radius: 16px;
    background: linear-gradient(180deg, #1b1c24, #0d0e14);
    color: #e5e7eb;
    font-size: 16px;
    font-weight: 600;
    box-shadow: 0 6px 20px rgba(0,0,0,.45),
                inset 0 0 0 1px rgba(255,255,255,.06);
    display: grid;
    place-items: center;
    outline: none;
    transition: transform .05s ease;
  }
  .btn:active, .act:active { transform: translateY(2px); }
  .btn { width: 64px; height: 64px; }
  .btn span { font-size: 26px; }
  .act {
    width: 120px; height: 120px;
    margin: auto;
    letter-spacing: .5px;
  }
</style>
</head>
<body>

<div class="gameboy">
  <div class="screen-container">
    <div class="screen">
      <canvas id="game"></canvas>
    </div>
  </div>
  <div class="controls">
    <div class="dpad">
      <div></div>
      <button class="btn" id="btn-up"><span>▲</span></button>
      <div></div>
      <button class="btn" id="btn-left"><span>◀</span></button>
      <div></div>
      <button class="btn" id="btn-right"><span>▶</span></button>
      <div></div>
      <button class="btn" id="btn-down"><span>▼</span></button>
      <div></div>
    </div>
    <button class="act" id="btn-act">ACCIÓN</button>
  </div>
</div>

<script>
const SPRITES = {
  size: { w: 36, h: 40 },
  scale: 0.9,
  idle: {
    down:  ["assets/juan_character/idle_down.png"],
    up:    ["assets/juan_character/idle_up.png"],
    left:  ["assets/juan_character/idle_left.png"],
    right: ["assets/juan_character/idle_right.png"],
  },
  walk: {
    down:  ["assets/juan_character/walk_down_0.png",  "assets/juan_character/walk_down_1.png"],
    up:    ["assets/juan_character/walk_up_0.png",    "assets/juan_character/walk_up_1.png"],
    left:  ["assets/juan_character/walk_left_0.png",  "assets/juan_character/walk_left_1.png"],
    right: ["assets/juan_character/walk_right_0.png", "assets/juan_character/walk_right_1.png"],
  }
};
const BACKGROUND = "assets/locations/room.PNG";
let bgImg = null;

const SOFA_IMG = "assets/objects/sofa.png";
let sofaImg = null;
    
const TVON_IMG = "assets/objects/tv_on.png";
let tvOnImg = null;

const BED_IMG = "assets/objects/bed.png";
let bedImg = null;

const roomOriginal = { w: 512, h: 350 }; 
let bgRect = { dx: 0, dy: 0, dw: 0, dh: 0 };

const boundsBase = { x: 20, y: 85, w: 470, h: 235 };
const obstaclesBase = [
  { x: 230, y: 25, w: 70, h: 50 }, // TV
  { x: 195, y: 170, w: 170, h: 2 }  // Sofa
];
const sofaBase = { x: 170, y: 75, w: 220, h: 180 };    
const tvOnBase = { x: 200, y: 35, w: 130, h: 90 };
    
const playerStartBase = { x: 260, y: 150 };

let bounds={}, obstacles=[], sofaPos={}, tvPos={};
let scaleFactor = 1;

function updateScaledBounds() {
  bounds = {
    x: bgRect.dx + Math.round(boundsBase.x * scaleFactor),
    y: bgRect.dy + Math.round(boundsBase.y * scaleFactor),
    w: Math.round(boundsBase.w * scaleFactor),
    h: Math.round(boundsBase.h * scaleFactor),
  };
  obstacles = obstaclesBase.map(o => ({
    x: bgRect.dx + Math.round(o.x * scaleFactor),
    y: bgRect.dy + Math.round(o.y * scaleFactor),
    w: Math.round(o.w * scaleFactor),
    h: Math.round(o.h * scaleFactor),
  }));
  sofaPos = {
    x: bgRect.dx + Math.round(sofaBase.x * scaleFactor),
    y: bgRect.dy + Math.round(sofaBase.y * scaleFactor),
    w: Math.round(sofaBase.w * scaleFactor),
    h: Math.round(sofaBase.h * scaleFactor),
  };
  tvPos = {
    x: bgRect.dx + Math.round(tvOnBase.x * scaleFactor),
    y: bgRect.dy + Math.round(tvOnBase.y * scaleFactor),
    w: Math.round(tvOnBase.w * scaleFactor),
    h: Math.round(tvOnBase.h * scaleFactor),
  };
  player.x = bgRect.dx + Math.round(playerStartBase.x * scaleFactor);
  player.y = bgRect.dy + Math.round(playerStartBase.y * scaleFactor);
}

const loadImage = (src) => new Promise(res => {
  const img = new Image();
  img.onload = () => res(img);
  img.onerror = () => res(null);
  img.src = src;
});

async function preloadSprites(map) {
  const result = { idle: {}, walk: {} };
  for (const state of ["idle","walk"]) {
    for (const dir of Object.keys(map[state])) {
      result[state][dir] = await Promise.all(map[state][dir].map(loadImage));
    }
  }
  return result;
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

function resizeCanvas() {
  const screen = document.querySelector('.screen');
  canvas.width = screen.clientWidth;
  canvas.height = screen.clientHeight;
  if (bgImg) {
    scaleFactor = Math.min(canvas.width / roomOriginal.w, canvas.height / roomOriginal.h);

    bgRect.dw = roomOriginal.w * scaleFactor;
    bgRect.dh = roomOriginal.h * scaleFactor;
    bgRect.dx = (canvas.width - bgRect.dw) / 2;
    bgRect.dy = (canvas.height - bgRect.dh) / 2;

    updateScaledBounds();
  }
}

window.addEventListener('resize', resizeCanvas);

const player = { x:0, y:0, speed:200, dir:'up', moving:false, frame:0, frameTime:0 };
const keys = { up:false, down:false, left:false, right:false };

function bindHold(btn, on, off) {
  const start = e => { e.preventDefault(); on(); };
  const end   = e => { e.preventDefault(); off(); };
  btn.addEventListener('touchstart', start, {passive:false});
  btn.addEventListener('touchend', end, {passive:false});
  btn.addEventListener('touchcancel', end, {passive:false});
  btn.addEventListener('mousedown', start);
  window.addEventListener('mouseup', end);
}
bindHold(document.getElementById('btn-up'),    () => keys.up=true,    () => keys.up=false);
bindHold(document.getElementById('btn-down'),  () => keys.down=true,  () => keys.down=false);
bindHold(document.getElementById('btn-left'),  () => keys.left=true,  () => keys.left=false);
bindHold(document.getElementById('btn-right'), () => keys.right=true, () => keys.right=false);

const mapKey = { ArrowUp:'up', KeyW:'up', ArrowDown:'down', KeyS:'down', ArrowLeft:'left', KeyA:'left', ArrowRight:'right', KeyD:'right' };
window.addEventListener('keydown', e => { const d=mapKey[e.code]; if(d){keys[d]=true; e.preventDefault();}});
window.addEventListener('keyup',   e => { const d=mapKey[e.code]; if(d){keys[d]=false; e.preventDefault();}});

function collides(x, y) {
  const halfW = SPRITES.size.w * SPRITES.scale / 2;
  const halfH = SPRITES.size.h * SPRITES.scale / 2;
  const px = x - halfW;
  const py = y - halfH;
  const pw = halfW * 2;
  const ph = halfH * 2;
  if (x < bounds.x || x > bounds.x + bounds.w ||
      y < bounds.y || y > bounds.y + bounds.h) {
    return true;
  }
  for (const o of obstacles) {
    if (px < o.x + o.w && px + pw > o.x &&
        py < o.y + o.h && py + ph > o.y) {
      return true;
    }
  }
  return false;
}

let assets = null;
function update(dt){
  const vx = (keys.left?-1:0)+(keys.right?1:0);
  const vy = (keys.up?-1:0)+(keys.down?1:0);
  player.moving = vx!==0 || vy!==0;

  if(player.moving){
    if(Math.abs(vx)>Math.abs(vy)) player.dir = vx<0?'left':'right';
    else if(Math.abs(vy)>0)       player.dir = vy<0?'up':'down';
    const len = Math.hypot(vx,vy)||1;
    const nx = (vx/len)*player.speed*dt;
    const ny = (vy/len)*player.speed*dt;
    const newX = player.x + nx;
    const newY = player.y + ny;
    if(!collides(newX, newY)){
      player.x = newX;
      player.y = newY;
    }
    player.frameTime += dt;
    if(player.frameTime>=0.14){ player.frame=(player.frame+1)%2; player.frameTime=0; }
  } else player.frame=0;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.imageSmoothingEnabled = false; // pixel art crisp

  // 1. Fondo
  if (bgImg) {
    const s = Math.min(canvas.width / roomOriginal.w, canvas.height / roomOriginal.h);
    bgRect.dw = roomOriginal.w * s;
    bgRect.dh = roomOriginal.h * s;
    bgRect.dx = (canvas.width - bgRect.dw) / 2;
    bgRect.dy = (canvas.height - bgRect.dh) / 2;
    ctx.drawImage(bgImg, bgRect.dx, bgRect.dy, bgRect.dw, bgRect.dh);
  }

  if (!assets) return;

  // 2. Sofá y personaje con lógica de superposición
  const sw = SPRITES.size.w, sh = SPRITES.size.h;
  const dw = Math.round(sw * SPRITES.scale);
  const dh = Math.round(sh * SPRITES.scale);
  const img = player.moving ? assets.walk[player.dir][player.frame] : assets.idle[player.dir][0];

  if (tvOnImg) ctx.drawImage(tvOnImg, tvPos.x, tvPos.y, tvPos.w, tvPos.h);

  // 4. Luz dinámica de la tele
  const flicker = 0.35 + Math.random() * 0.05;
  drawLight(tvPos.x + tvPos.w / 2, tvPos.y + tvPos.h / 2, 100, flicker);

  if (sofaImg) ctx.drawImage(sofaImg, sofaPos.x, sofaPos.y, sofaPos.w, sofaPos.h);

  // === RESPIRACIÓN: 1 píxel hacia arriba, pies clavados ===
  // Solo cuando está idle: alterna entre 0 y 1 px para mantenerlo nítido
  let stretchPx = 0;
  if (!player.moving) {
    const Hz = 0.6;
    const t = performance.now() / 1000;
    const s = Math.sin(t * Math.PI * 2 * Hz);      // -1..1
    stretchPx = Math.round((s * 0.5 + 0.5) * 1);   // 0..1 (entero)
  }

  // coordenadas base (tu player.x/y es el centro)
  const baseX = Math.round(player.x - dw / 2);
  const baseY = Math.round(player.y - dh / 2);

  // dibuja sombra (no se estira ni se mueve)
  const drawShadow = () => {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(
      Math.round(player.x),
      Math.round(player.y + dh / 2 - 4),
      dw / 2.5,
      dh / 6,
      0, 0, Math.PI * 2
    );
    ctx.fill();
  };

  // dibuja personaje con estiramiento hacia arriba
  const drawPlayer = () => {
    // para que los pies no se muevan:
    // aumentamos altura a (dh + stretchPx) y subimos Y exactamente stretchPx
    const destX = baseX;
    const destY = baseY - stretchPx;            // pies se quedan donde estaban
    const destW = dw;
    const destH = dh + stretchPx;               // estira 1 px hacia arriba
    ctx.drawImage(img, 0, 0, sw, sh, destX, destY, destW, destH);
  };

  // z-order con el sofá
  if (player.y < sofaPos.y + sofaPos.h / 2) {
    // personaje detrás del sofá
    drawShadow();
    drawPlayer();
    ctx.drawImage(sofaImg, sofaPos.x, sofaPos.y, sofaPos.w, sofaPos.h);
  } else {
    // personaje delante del sofá
    ctx.drawImage(sofaImg, sofaPos.x, sofaPos.y, sofaPos.w, sofaPos.h);
    drawShadow();
    drawPlayer();
  }

  // 3. Oscurecer todo
  ctx.fillStyle = 'rgba(0,0,0,0.40)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}



    
function drawLight(x, y, radius, intensity) {
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
  gradient.addColorStop(0, `rgba(255, 255, 200, ${intensity})`); // centro amarillo claro
  gradient.addColorStop(1, 'rgba(255, 255, 200, 0)'); // borde transparente

  ctx.globalCompositeOperation = "lighter"; 
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalCompositeOperation = "source-over"; // volver a normal
}

function loop(now){
  if(!loop.last) loop.last=now;
  const dt = Math.min(1/30,(now-loop.last)/1000);
  loop.last=now;
  update(dt); draw();
  requestAnimationFrame(loop);
}

async function init() {
  [bgImg, sofaImg, tvOnImg, assets] = await Promise.all([
    loadImage(BACKGROUND),
    loadImage(SOFA_IMG),
    loadImage(TVON_IMG),
    preloadSprites(SPRITES)
  ]);
  resizeCanvas();
  requestAnimationFrame(loop);
}

init();
</script>
</body>
</html>
